<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="SampsonKY" type="application/atom+xml">






<meta name="description" content="Dreams are destined to be lonely, and there is no doubt and ridicule on the road, but what about it, even if it is bruised and bruised, it must live beautifully.">
<meta property="og:type" content="website">
<meta property="og:title" content="SampsonKY">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SampsonKY">
<meta property="og:description" content="Dreams are destined to be lonely, and there is no doubt and ridicule on the road, but what about it, even if it is bruised and bruised, it must live beautifully.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SampsonKY">
<meta name="twitter:description" content="Dreams are destined to be lonely, and there is no doubt and ridicule on the road, but what about it, even if it is bruised and bruised, it must live beautifully.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>SampsonKY</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SampsonKY</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/封装fetch请求/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SampsonKY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SampsonKY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/封装fetch请求/" itemprop="url">封装fetch请求</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T19:26:13+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端学习/" itemprop="url" rel="index">
                    <span itemprop="name">前端学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="封装-fetch-请求"><a href="#封装-fetch-请求" class="headerlink" title="封装 fetch 请求"></a>封装 fetch 请求</h3><ul>
<li>如果只是简单的请求，没必要引入 <code>aixos</code>，通过将fetch请求的相关代码封装在request.js/request.ts文件中，在使用的时候引入相关请求方法即可，好处有几点：<ul>
<li>请求的地方代码更少。</li>
<li>公共的错误统一在一个地方添加即可。</li>
<li>请求定制的错误还是请求自己也可以处理。</li>
<li>扩展性好，添加功能只需要改一个地方。</li>
</ul>
</li>
<li>下面给出我在项目中封装的 request.ts 文件具体内容：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path：src/utils/request.ts</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="function">(<span class="params">url: <span class="built_in">string</span>, config: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(url, config)</span><br><span class="line">    .then(<span class="function">(<span class="params">res: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!res.ok) &#123;</span><br><span class="line">        <span class="comment">// 服务器异常返回</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'接口请求异常'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res.json();</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">error: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">get</span> = <span class="function">(<span class="params">url: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> request(url, &#123; method: <span class="string">'GET'</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST请求</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> post = <span class="function">(<span class="params">url: <span class="built_in">string</span>, data: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> request(url, &#123;</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(data),</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据功能建立不同的请求模块，如列表模块：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path：src/services/api/list.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Fetch <span class="keyword">from</span> <span class="string">'../../utils/request'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getListData</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Fetch.get(<span class="string">'URL1'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getListItemDetail</span> (<span class="params">id: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Fetch.get(</span><br><span class="line">    <span class="string">`URL2/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">  ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>暴露 api：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path：src/services/api.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./api/list'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>组件中使用：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path：src/components/xxx.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> api <span class="keyword">from</span> <span class="string">'../../services/api'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> HomePage <span class="keyword">extends</span> React.Component&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="comment">/* 省略代码 */</span> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> loadListData () &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> api.getListData();</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        listData: res.data.list,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 省略代码 */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HomePage;</span><br></pre></td></tr></table></figure>

<ul>
<li>以上则成功完成 <code>fetch</code> 请求的封装。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/Nextjs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SampsonKY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SampsonKY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/Nextjs/" itemprop="url">Nextjs入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T19:24:47+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端学习/" itemprop="url" rel="index">
                    <span itemprop="name">前端学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Next-js"><a href="#Next-js" class="headerlink" title="Next.js"></a>Next.js</h1><blockquote>
<p> Next.js 是一个轻量级的 React 服务端渲染应用框架。有了它我们可以简单轻松的实现React的<strong>服务端渲染</strong>，从而加快首屏打开速度，也可以作<strong>SEO</strong>（收索引擎优化了）。在没有Next.js的时候，用React开发需要配置很多繁琐的参数，如Webpack配置，Router配置和服务器端配置等….。如果需要作SEO，要考虑的事情就更多了，怎么样服务端渲染和客户端渲染保持一致就是一件非常麻烦的事情，需要引入很多第三方库。但有了Next.js，这些问题都解决了，使开发人员可以将精力放在业务逻辑上，从繁琐的配置中解放出来。 </p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Next.js 是一个轻量级的 React 服务端渲染应用框架。</p>
</blockquote>
<p>用一个框架，就要知道它的优点（或者是解决了我们什么问题）:</p>
<ul>
<li>完善的React项目架构，搭建轻松。比如：Webpack配置，服务器启动，路由配置，缓存能力，这些在它内部已经完善的为我们搭建完成了。</li>
<li>自带数据同步策略，解决服务端渲染最大难点。把服务端渲染好的数据，拿到客户端重用，这个在没有框架的时候，是非常复杂和困难的。有了Next.js，它为我们提供了非常好的解决方法，让我们轻松的就可以实现这些步骤。</li>
<li>丰富的插件帮开发人员增加各种功能。每个项目的需求都是不一样的，包罗万象。无所不有，它为我们提供了插件机制，让我们可以在使用的时候按需使用。你也可以自己写一个插件，让别人来使用。</li>
<li>灵活的配置，让开发变的更简单。它提供很多灵活的配置项，可以根据项目要求的不同快速灵活的进行配置。</li>
</ul>
<p>目前Next.js是React服务端渲染的最佳解决方案，所以如果想使用React来开发需要SEO的应用，基本上就要使用Next.js。</p>
<h2 id="create-next-app-快速创建Next-js项目"><a href="#create-next-app-快速创建Next-js项目" class="headerlink" title="create-next-app 快速创建Next.js项目"></a>create-next-app 快速创建Next.js项目</h2><p><strong>项目结构介绍</strong>：</p>
<ul>
<li><strong>components</strong>文件夹:这里是专门放置自己写的组件的，这里的组件不包括页面，指公用的或者有专门用途的组件。</li>
<li><strong>node_modules</strong>文件夹：Next项目的所有依赖包都在这里，一般我们不会修改和编辑这里的内容。</li>
<li><strong>pages</strong>文件夹：这里是放置页面的，这里边的内容会自动生成路由，并在服务器端渲染，渲染好后进行数据同步。</li>
<li><strong>public</strong>文件夹： 这个是静态文件夹，比如项目需要的图片、图标和静态资源都可以放到这里。</li>
<li><strong>.gitignore</strong>文件： 这个主要是控制git提交和上传文件的，简称就是忽略提交。</li>
<li><strong>package.json</strong>文件：定义了项目所需要的文件和项目的配置信息（名称、版本和许可证），最主要的是使用<code>npm install</code> 就可以下载项目所需要的所有包。</li>
</ul>
<h2 id="Page和Component的使用"><a href="#Page和Component的使用" class="headerlink" title="Page和Component的使用"></a>Page和Component的使用</h2><p>直接在<strong>pages</strong>文件夹下，新建一个<code>xxx.js</code>页面，写好相应的代码后，<code>Next</code>框架就自动做好了路由。如果要做更深的路由，在pages文件夹下再建相应的文件夹，然后在新的文件夹里面新建页面，以此类推即可。</p>
<p>pages里面的文件名和components文件夹里面的文件名可以相同，不会冲突。</p>
<p>在components文件夹目录新建组件，在pages里面引入即可。</p>
<h2 id="路由-基础和基本跳转"><a href="#路由-基础和基本跳转" class="headerlink" title="路由-基础和基本跳转"></a>路由-基础和基本跳转</h2><p>路由跳转两种形式：</p>
<ul>
<li><p><strong>标签式导航</strong>：利用标签<code>&lt;Link&gt;</code></p>
<p><em>引入</em>：<code>import Link from &#39;next/link&#39;</code></p>
<p><em>使用</em>：<code>&lt;Link href=&quot;/&quot;&gt;&lt;a&gt;返回首页&lt;/a&gt;&lt;/Link&gt;</code></p>
<p><em>注意</em>：不写<code>&lt;a&gt;</code>标签时不支持兄弟标签并列，使用<code>&lt;a&gt;</code>便可使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=&quot;/jspangA&quot;&gt;</span><br><span class="line">  &lt;a&gt;</span><br><span class="line">    &lt;span&gt;去JspangA页面&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;前端博客&lt;/span&gt;</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编程式跳转</strong>：用js编程的方式进行跳转，也就是利用<code>Router</code>组件</p>
<p><em>引入</em>：<code>import Router from &#39;next/router&#39;</code></p>
<p><em>使用：</em> <code>&lt;button onClick={()=&gt;{Router.push(&#39;/jspangA&#39;)}}&gt;去JspangA页面&lt;/button&gt;</code>这种写法简单，但是耦合性太高，可以修改一下 ，把跳转放到一个方法里，然后调用方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gotoA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Router.push(<span class="string">'/jspangA'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;gotoA&#125;&gt;去JspangA页面&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="路由-跳转时用query传递和接收参数"><a href="#路由-跳转时用query传递和接收参数" class="headerlink" title="路由-跳转时用query传递和接收参数"></a>路由-跳转时用query传递和接收参数</h2><p>项目开发中一般需要<strong>动态跳转</strong>，动态跳转就是跳转时需要带一个参数或几个参数过去，然后在到达的页面接受这个传递的参数，并根据参数不同显示不同的内容。比如新闻列表，然后点击一个要看的新闻就会跳转到具体内容。这些类似这样的需求都都是通过传递参数实现的。</p>
<p><strong>只能用query传递参数</strong>：在<code>Next.js</code>中只能通过通过query（<code>?id=1</code>）来传递参数，而不能通过(<code>path:id</code>)的形式传递参数。</p>
<p><strong>标签式导航传递参数：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=<span class="string">"/jpangA?name=技胖"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>技胖<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"> 或者（优雅的写法）   </span><br><span class="line">&lt;Link href=&#123;&#123;<span class="attr">pathname</span>:<span class="string">'/jpangA'</span>,<span class="attr">query</span>:&#123;<span class="attr">name</span>:<span class="string">'技胖'</span>&#125;&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>技胖<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>这种写法有两个参数，一个是<code>pathname</code>，一个是<code>query</code>，<code>query</code>里面包含传递的参数</p>
<p><strong>编程式跳转传递参数：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gotojpang</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Router.push(<span class="string">'/jpangA?name=技胖'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;button onClick=&#123;gotojpang&#125;&gt;技胖&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p>​    或者：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gotojpang</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   Router.push(&#123;</span><br><span class="line">     pathname:<span class="string">'/jpangA'</span>,</span><br><span class="line">     query:&#123;</span><br><span class="line">       name:<span class="string">'技胖'</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>接受参数</strong>：<code>withRouter</code>是Next.js框架的高级组件，用来处理路由用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//①引入withRouter</span><br><span class="line">import &#123;withRouter&#125; from &apos;next/router&apos;</span><br><span class="line">import Link from &apos;next/link&apos;</span><br><span class="line"></span><br><span class="line">//②这里要传入参数router</span><br><span class="line">const Jspang = (&#123;router&#125;)=&gt;&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        	//③通过这种形式获得参数</span><br><span class="line">            &lt;div&gt;&#123;router.query.name&#125;，他来了&lt;/div&gt;</span><br><span class="line">            &lt;Link href=&quot;/&quot;&gt;&lt;a&gt;返回首页&lt;/a&gt;&lt;/Link&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//④导出要使用withRouter</span><br><span class="line">export default withRouter(Jspang)</span><br></pre></td></tr></table></figure>

<h2 id="路由-六个钩子事件"><a href="#路由-六个钩子事件" class="headerlink" title="路由-六个钩子事件"></a>路由-六个钩子事件</h2><blockquote>
<p> 路由的钩子事件，也就是当路由发生变化时，可以监听到这些变化事件，执行对应的函数。利用钩子事件是可以作很多事情的，比如转换时的加载动画，关掉页面的一些资源计数器…..</p>
</blockquote>
<ul>
<li><p><code>routerChangeStart</code>路由发生变化时</p>
<p>使用Router组件，然后用<code>on</code>方法来进行兼听</p>
</li>
<li><p><code>routerChangeComplete</code>路由结束变化时</p>
</li>
<li><p><code>beforeHistoryChange</code>浏览器history触发前</p>
<p>history就是HTMP中的API，<code>Next.js</code>路由变化默认都是通过history进行的，所以每次都会调用。 不适用history的话，也可以通过hash。</p>
<p>正确顺序为：①③②</p>
</li>
<li><p><code>routeChangeError</code>路由跳转发生错误时</p>
<p>注意：404找不到路由页面不算错误</p>
</li>
</ul>
<p><strong>转变成hash路由模式</strong></p>
<p>以下两种事件都是针对hash的。</p>
<ul>
<li><code>hashChangeStart</code>：hash跳转开始时执行</li>
<li><code>hashChangeComplete</code>：hash跳转完成时执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import Link from &apos;next/link&apos;</span><br><span class="line">import Router from &apos;next/router&apos;</span><br><span class="line"></span><br><span class="line">function gotojpang()&#123;</span><br><span class="line">  Router.push(&apos;/jspang?name=技术胖&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用Router组件，on方法进行兼听</span><br><span class="line">Router.events.on(&apos;routeChangeStart&apos;, (...args) =&gt; &#123;</span><br><span class="line">  console.log(&apos;1.routeChangeStart-&gt;路由开始变化,参数为:&apos;, ...args)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Router.events.on(&apos;routeChangeComplete&apos;, (...args) =&gt; &#123;</span><br><span class="line">  console.log(&apos;2.routeChangeComplete-&gt;路由结束变化,参数为:&apos;, ...args)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Router.events.on(&apos;beforeHistoryChange&apos;, (...args) =&gt; &#123;</span><br><span class="line">  console.log(&apos;3,beforeHistoryChange-&gt;在改变浏览器 history之前触发,参数为:&apos;, ...args)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Router.events.on(&apos;routeChangeError&apos;, (...args) =&gt; &#123;</span><br><span class="line">  console.log(&apos;4,routeChangeError-&gt;跳转发生错误,参数为:&apos;, ...args)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Router.events.on(&apos;hashChangeStart&apos;, (...args) =&gt; &#123;</span><br><span class="line">  console.log(&apos;5,hashChangeStart-&gt;hash跳转开始时执行,参数为:&apos;, ...args)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Router.events.on(&apos;hashChangeComplete&apos;, (...args) =&gt; &#123;</span><br><span class="line">  console.log(&apos;6,hashChangeComplete-&gt;hash跳转完成时,参数为:&apos;, ...args)</span><br><span class="line">&#125;)</span><br><span class="line">const Home = () =&gt; (</span><br><span class="line">  </span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;div&gt;我是首页&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Link href=&quot;/jspang?name=技胖&quot;&gt;&lt;a&gt;技胖&lt;/a&gt;&lt;/Link&gt;</span><br><span class="line">      &lt;Link href=&quot;/jspang?name=术胖&quot;&gt;&lt;a&gt;术胖&lt;/a&gt;&lt;/Link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;gotojpang&#125;&gt;技胖&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    //hash模式</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Link href=&quot;#jspang&quot;&gt;&lt;a&gt;技术胖&lt;/a&gt;&lt;/Link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default Home</span><br></pre></td></tr></table></figure>

<h2 id="在getInitialProps中使用Axios获取远端数据"><a href="#在getInitialProps中使用Axios获取远端数据" class="headerlink" title="在getInitialProps中使用Axios获取远端数据"></a>在getInitialProps中使用Axios获取远端数据</h2><p>在<code>Next.js</code>框架中提供了<code>getInitialProps</code>静态方法用来获取远端数据，这个是框架的约定，所以你也只能在这个方法里获取远端数据。不要在生命周期里面获得，虽然可以，但是不符合约定。</p>
<p><em>安装axios</em>: <code>yarn add axios</code></p>
<p><em>引入</em>： <code>import axios from &#39;axios&#39;</code></p>
<p>获取数据例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//使用getInitialProps远程获取数据</span><br><span class="line">Jspang.getInitialProps = async ()=&gt;&#123;</span><br><span class="line">    const promise =new Promise((resolve)=&gt;&#123;</span><br><span class="line">            axios(&apos;https://www.easy-mock.com/xxx&apos;).then(</span><br><span class="line">                (res)=&gt;&#123;</span><br><span class="line">                    console.log(&apos;远程数据结果：&apos;,res)</span><br><span class="line">                    resolve(res.data.data)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">    &#125;)</span><br><span class="line">    return await promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取数据之后，把得到的数据传递给页面组件，用&#123;&#125;显示出来就可以了。</span><br><span class="line">//res.data.data里面有一个list数组</span><br><span class="line">const Jspang = (&#123;router,list&#125;)=&gt;&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;&#123;router.query.name&#125;,来了 .&lt;br/&gt;&#123;list&#125;&lt;/div&gt;//直接就可以使用</span><br><span class="line">            &lt;Link href=&quot;/&quot;&gt;&lt;a&gt;返回首页&lt;/a&gt;&lt;/Link&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Style-JSX编写页面的CSS样式"><a href="#使用Style-JSX编写页面的CSS样式" class="headerlink" title="使用Style JSX编写页面的CSS样式"></a>使用Style JSX编写页面的CSS样式</h2><p>在<code>Next.js</code>中引入一个CSS样式是不可以用的，如果想用，需要作额外的配置。因为框架为我们提供了一个<code>style jsx</code>特性，也就是把CSS用JSX的语法写出来。</p>
<p>一个特性：<strong>自动添加随机类名，不会污染全局css</strong>—加入了<code>Style jsx</code>代码后，<code>Next.js</code>会自动加入一个随机类名，这样就防止了CSS的全局污染。比如我们把代码写成下面这样，然后在浏览器的控制台中进行查看，你会发现自动给我们加入了类名，类似<code>jsx-xxxxxxxx</code></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Jspang()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;技术胖免费前端教程&lt;/div&gt;</span><br><span class="line">            &lt;div className=&quot;jspang&quot;&gt;技术胖免费前端教程&lt;/div&gt;</span><br><span class="line">		//使用这种形式些样式</span><br><span class="line">            &lt;style jsx&gt;</span><br><span class="line">                &#123;`</span><br><span class="line">                    div &#123; color:blue;&#125;</span><br><span class="line">                    .jspang &#123;color:red;&#125;</span><br><span class="line">                `&#125;</span><br><span class="line">            &lt;/style&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default Jspang</span><br></pre></td></tr></table></figure>

<p><strong>动态显示样式</strong>：</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState&#125; from &apos;react&apos;</span><br><span class="line">function Jspang()&#123;</span><br><span class="line">    const [color,setColor] = useState(&apos;blue&apos;)</span><br><span class="line">    const changeColor=()=&gt;&#123;</span><br><span class="line">        setColor(color==&apos;blue&apos;?&apos;red&apos;:&apos;blue&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;技术胖免费前端教程&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;&lt;button onClick=&#123;changeColor&#125;&gt;改变颜色&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">            &lt;style jsx&gt;</span><br><span class="line">                &#123;`</span><br><span class="line">                    div &#123; color:$&#123;color&#125;;&#125;</span><br><span class="line">                `&#125;</span><br><span class="line">            &lt;/style&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default Jspang</span><br></pre></td></tr></table></figure>

<h2 id="Lazy-Loading实现模块懒加载"><a href="#Lazy-Loading实现模块懒加载" class="headerlink" title="Lazy Loading实现模块懒加载"></a>Lazy Loading实现模块懒加载</h2><p>当项目越来越大的时候，模块的加载是需要管理的，如果不管理会出现首次打开过慢，页面长时间没有反应一系列问题。这时候可用<code>Next.js</code>提供的<code>LazyLoading</code>来解决这类问题。让模块和组件只有在用到的时候在进行加载，一般我把这种东西叫做“懒加载”.它一般分为两种情况，一种是<strong>懒加载</strong>（或者说是<strong>异步加载</strong>）<strong>模块</strong>，另一种是<strong>异步加载组件</strong>。</p>
<blockquote>
<p>当我们作的应用存在首页打开过慢和某个页面加载过慢时，就可以采用<code>Lazy Loading</code>的形式，用懒加载解决这些问题。</p>
</blockquote>
<p><strong>懒加载模块</strong>：</p>
<p>比如我们引入开发中常用的模块<code>Moment.js</code>,它是一个JavaScript日期处理类库。安装：<code>yarn add moment</code>。</p>
<p>例如（未使用懒加载）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState&#125; from &apos;react&apos;</span><br><span class="line">import moment from &apos;moment&apos; //引入模块</span><br><span class="line"></span><br><span class="line">function Time()&#123;</span><br><span class="line"></span><br><span class="line">    const [nowTime,setTime] = useState(Date.now())</span><br><span class="line"></span><br><span class="line">    const changeTime=()=&gt;&#123;</span><br><span class="line">        //使用</span><br><span class="line">        setTime(moment(Date.now()).format())</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;显示时间为:&#123;nowTime&#125;&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;&lt;button onClick=&#123;changeTime&#125;&gt;改变时间格式&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default Time</span><br></pre></td></tr></table></figure>

<p><strong>这个看起来很简单和清晰的案例，缺存在着一个潜在的风险，就是如何有半数以上页面使用了这个<code>momnet</code>的库，那它就会以公共库的形式进行打包发布，就算项目第一个页面不使用<code>moment</code>也会进行加载，这就是资源浪费，对于我这样有代码洁癖的良好程序员是绝对不允许的。下面我们就通过<code>Lazy Loading</code>来进行改造代码。</strong></p>
<p>改良（使用懒加载）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;useState&#125; from &apos;react&apos;</span><br><span class="line">//删除import moment</span><br><span class="line">function Time()&#123;</span><br><span class="line">    const [nowTime,setTime] = useState(Date.now())</span><br><span class="line">    </span><br><span class="line">    const changeTime= async ()=&gt;&#123; //把方法变成异步模式</span><br><span class="line">        const moment = await import(&apos;moment&apos;) //等待moment加载完成</span><br><span class="line">        setTime(moment.default(Date.now()).format()) //注意使用defalut</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;显示时间为:&#123;nowTime&#125;&lt;/div&gt;</span><br><span class="line">            &lt;div&gt;&lt;button onClick=&#123;changeTime&#125;&gt;改变时间格式&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default Time</span><br></pre></td></tr></table></figure>

<p><strong>懒加载自定义组件</strong></p>
<p>首先要在懒加载这个组件的文件汇总引入<code>dynamic</code>，<code>import dynamic from &#39;next/dynamic&#39;</code></p>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import dynamic from &apos;next/dynamic&apos; //引入dynamic</span><br><span class="line">//使用如下方式引入组件</span><br><span class="line">const One = dynamic(import(&apos;../components/one&apos;))</span><br><span class="line">function Time()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;//使用</span><br><span class="line">            &lt;One/&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default Time</span><br></pre></td></tr></table></figure>

<p>写完代码后，可以看到自定义组件是懒加载的，只有在<code>jsx</code>里用到``时，才会被加载进来，如果不使用就不会被加载。</p>
<h2 id="自定义Head更加友好的SEO操作"><a href="#自定义Head更加友好的SEO操作" class="headerlink" title="自定义Head更加友好的SEO操作"></a>自定义Head更加友好的SEO操作</h2><p><strong>定制<code>&lt;Head&gt;</code>标签</strong></p>
<ul>
<li><p>方法一：<strong>在各个页面加上<code>&lt;Head&gt;</code>标签</strong>(推荐)    </p>
<p>例如在pages中的某一个页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Head from &apos;next/head&apos; //引入Head</span><br><span class="line">function Header()&#123; </span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        //使用Head</span><br><span class="line">            &lt;Head&gt;</span><br><span class="line">                &lt;title&gt;技术胖是最胖的！&lt;/title&gt;</span><br><span class="line">                &lt;meta charSet=&apos;utf-8&apos; /&gt;</span><br><span class="line">            &lt;/Head&gt;</span><br><span class="line">            &lt;div&gt;JSPang.com&lt;/div&gt;</span><br><span class="line">        &lt;/&gt; </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">export default Header</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：<strong>定义全局的<code>&lt;Head&gt;</code></strong></p>
<p>这种方法相当于自定义了一个组件，然后把在组件里定义好，以后每个页面都使用这个组件,其实这种方法用处不大，也不灵活。因为<code>Next.js</code>已经把<code>&lt;Head&gt;</code>封装好了，本身就是一个组件，我们再次封装的意义不大。</p>
</li>
</ul>
<h2 id="Next-js框架下使用Ant-Design-UI"><a href="#Next-js框架下使用Ant-Design-UI" class="headerlink" title="Next.js框架下使用Ant Design UI"></a>Next.js框架下使用Ant Design UI</h2><p><strong>让Next.js支持CSS文件</strong>：</p>
<p><em>安装</em><code>@zeit/next-css</code>包，它的主要功能就是让<code>Next.js</code>可以加载CSS文件，有了这个包才可以进行配置：<code>yarn add @zeit/next-css</code></p>
<p><em>配置：</em>建立一个<code>next.config.js</code>（建在最外面的那个目录）这个就是<code>Next.js</code>的总配置文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withCss = <span class="built_in">require</span>(<span class="string">'@zeit/next-css'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">require</span> !== <span class="string">'undefined'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.extensions[<span class="string">'.css'</span>]=<span class="function"><span class="params">file</span>=&gt;</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = withCss(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>按需加载Ant Design</strong></p>
<p>加载<code>Ant Design</code>在我们打包的时候会把<code>Ant Design</code>的所有包都打包进来，这样就会产生性能问题，让项目加载变的非常慢。这肯定是不行的，现在的目的是只加载项目中用到的模块，这就需要我们用到一个<strong><code>babel-plugin-import</code></strong>文件。</p>
<p>先安装<code>Ant Design</code>库：<code>yarn add antd</code></p>
<p>安装<code>babel-plugin-import</code>插件：<code>yarn add babel-plugin-import</code></p>
<p>配置<code>babel-plugin-import</code>插件：在项目根目录建立<code>.babelrc</code>文件，然后写入如下配置文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;	<span class="comment">//Next.js的总配置文件，相当于继承了它本身的所有配置</span></span><br><span class="line">    <span class="string">"presets"</span>:[<span class="string">"next/babel"</span>], </span><br><span class="line">    <span class="string">"plugins"</span>:[     </span><br><span class="line">        <span class="comment">//增加新的插件，这个插件就是让antd可以按需引入，包括CSS</span></span><br><span class="line">        [</span><br><span class="line">            <span class="string">"import"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"libraryName"</span>:<span class="string">"antd"</span>,</span><br><span class="line">                <span class="string">"style"</span>:<span class="string">"css"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置好了以后，<code>webpack</code>就不会默认把整个<code>Ant Design</code>的包都进行打包到生产环境了，而是我们使用那个组件就打包那个组件,同样CSS也是按需打包的。</p>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Button&#125; from &apos;antc&apos;</span><br><span class="line">function Page()&#123;</span><br><span class="line">    return(</span><br><span class="line">    	&lt;&gt;</span><br><span class="line">        &lt;Button&gt;我是按需引入的按钮&lt;/Button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Next-js生产环境打包"><a href="#Next-js生产环境打包" class="headerlink" title="Next.js生产环境打包"></a>Next.js生产环境打包</h2><p>其实Next.js大打包时非常简单的，只要一个命令就可以打包成功。但是当你使用了<code>Ant Desgin</code>后，在打包的时候会遇到一些坑。</p>
<blockquote>
<p>打包 ：next build</p>
</blockquote>
<blockquote>
<p>运行：next start -p 80</p>
</blockquote>
<p>先把这两个命令配置到<code>package.json</code>文件里，比如配置成下面的样子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"next dev"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"next build"</span>,</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"next start -p 80"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>然后在终端里运行一下<code>yarn build</code>，如果这时候报错，其实是我们在加入<code>Ant Design</code>的样式时产生的，你可以改用<strong>全局引入CSS</strong>解决问题。</p>
<p>在page目录下，新建一个<code>_app.js</code>文件，然后写入下面的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'next/app'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>

<p>这样配置一下，就可以打包成功了，然后再运行<code>yarn start</code>来运行服务器，看一下我们的<code>header</code>页面，也是有样式的。说明打包已经成功了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/Nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SampsonKY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SampsonKY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/Nginx/" itemprop="url">Nginx基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T19:24:13+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><blockquote>
<p>Nginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡。</p>
</blockquote>
<h2 id="初识Nginx和环境准备"><a href="#初识Nginx和环境准备" class="headerlink" title="初识Nginx和环境准备"></a>初识Nginx和环境准备</h2><p><strong>Nginx的优点</strong></p>
<ul>
<li>支持海量高并发：采用IO多路复用epoll。官方测试Nginx能够支持5万并发链接，实际生产环境中可以支撑2-4万并发连接数。</li>
<li>内存消耗少：在主流的服务器中Nginx目前是内存消耗最小的了，比如我们用Nginx+PHP，在3万并发链接下，开启10个Nginx进程消耗150M内存。</li>
<li>免费使用可以商业化：Nginx为开源软件，采用的是2-clause BSD-like协议，可以免费使用，并且可以用于商业。</li>
<li>配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。</li>
</ul>
<ul>
<li>反向代理功能，负载均衡功能等</li>
</ul>
<p>可以通过<code>https://w3techs.com/</code>这个网站看到nginx的热度。</p>
<p>阿里云校园生态：<code>https://promotion.aliyun.com/ntms/act/campus2018.html</code></p>
<p><strong>用yum进行安装必要程序</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ autoconf pcre-devel make automake</span><br><span class="line">yum -y install wget httpd-tools vim</span><br></pre></td></tr></table></figure>

<h2 id="Nginx的快速搭建"><a href="#Nginx的快速搭建" class="headerlink" title="Nginx的快速搭建"></a>Nginx的快速搭建</h2><p><strong>Nginx版本说明</strong></p>
<ul>
<li>Mainline version ：开发版,主要是给广大Nginx爱好者，测试、研究和学习的，但是不建议使用于生产环境。</li>
<li>Stable version : 稳定版,也就是我们说的长期更新版本。这种版本一般比较成熟，经过长时间的更新测试，所以这种版本也是主流版本。</li>
<li>legacy version : 历史版本，如果你需要以前的版本，Nginx也是有提供的。</li>
</ul>
<p><strong>基于Yum的方式安装Nginx</strong></p>
<ul>
<li><p>检查yum是否存在：<code>yum list | grep nginx</code></p>
</li>
<li><p>若原来源版本过低，可以自行配置yum源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo  <span class="comment">#先进入到指定文件</span></span><br><span class="line"><span class="comment">#再添加如下代码</span></span><br><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/OS/OSRELEASE/<span class="variable">$basearch</span>/     <span class="comment">#这里OS换成centos,OSRELEASE换成7；视情况而定</span></span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置好yum源后，安装nginx：<code>yum install nginx</code></p>
</li>
<li><p>安装好后，检测Nginx版本：<code>nginx -v</code></p>
</li>
</ul>
<h2 id="Nginx基本配置文件详解"><a href="#Nginx基本配置文件详解" class="headerlink" title="Nginx基本配置文件详解"></a>Nginx基本配置文件详解</h2><p><strong>查看Nginx的安装目录</strong></p>
<p><code>rpm -ql nginx</code>这条命令可以找到nginx的所有安装位置。</p>
<p><strong>nginx.conf 文件解读</strong></p>
<blockquote>
<p>nginx.conf 文件是Nginx<em>总配置文件</em>，在我们搭建服务器时经常调整的文件。</p>
</blockquote>
<p>进入etc/nginx目录，用vim打开nginx.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行用户，默认即是nginx，可以不进行设置</span></span><br><span class="line">user  nginx;</span><br><span class="line"><span class="comment">#Nginx进程，一般设置为和CPU核数一样</span></span><br><span class="line">worker_processes  1;   </span><br><span class="line"><span class="comment">#错误日志存放目录</span></span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line"><span class="comment">#进程pid存放位置</span></span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024; <span class="comment"># 单个后台进程的最大并发数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;   <span class="comment">#文件扩展名与类型映射表</span></span><br><span class="line">    default_type  application/octet-stream;  <span class="comment">#默认文件类型</span></span><br><span class="line">    <span class="comment">#设置日志模式</span></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;   <span class="comment">#nginx访问日志存放位置</span></span><br><span class="line"></span><br><span class="line">    sendfile        on;   <span class="comment">#开启高效传输模式</span></span><br><span class="line">    <span class="comment">#tcp_nopush     on;    #减少网络报文段的数量</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;  <span class="comment">#保持连接的时间，也叫超时时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;  #开启gzip压缩</span></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf; <span class="comment">#包含的子配置项位置和文件</span></span><br></pre></td></tr></table></figure>

<p><strong>default.conf 配置项讲解</strong> </p>
<p>我们看到最后有一个子文件的配置项，那我们打开这个include子文件配置项看一下里边都有些什么内容。</p>
<p>进入conf.d目录，然后使用<code>vim default.conf</code>进行查看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;   <span class="comment">#配置监听端口</span></span><br><span class="line">    server_name  localhost;  //配置域名</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;     </span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;     <span class="comment">#服务默认启动目录</span></span><br><span class="line">        index  index.html index.htm;    <span class="comment">#默认访问文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;   # 配置404页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;   <span class="comment">#错误状态码的显示页面，配置后需要重启</span></span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx's one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明白了这些配置项，我们知道我们的服务目录放在了<code>/usr/share/nginx/html</code>下，可以使用命令进入看一下目录下的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>可以看到目录下面有两个文件，50x.html 和 index.html。我们可以使用vim进行编辑。</p>
<p><strong>阿里云的安全组配置</strong></p>
<p>如果你使用的是阿里云，记得到ECS实例一下打开端口。</p>
<p>步骤如下：</p>
<ol>
<li>进入阿里云控制台，并找到ECS实例。</li>
<li>点击实例后边的“更多”</li>
<li>点击“网络和安全组” ，再点击“安全组配置”</li>
<li>右上角添加“安全组配置”</li>
<li>进行80端口的设置。</li>
</ol>
<h2 id="Nginx服务启动、停止、重启"><a href="#Nginx服务启动、停止、重启" class="headerlink" title="Nginx服务启动、停止、重启"></a>Nginx服务启动、停止、重启</h2><p><strong>启动Nginx服务</strong></p>
<ul>
<li>直接启动：<code>nginx</code></li>
<li>使用systemctl命令启动：<code>systemctl start nginx.service</code></li>
<li>检查是否启动：<code>ps aux | grep nginx</code></li>
</ul>
<p><strong>停止Nginx服务</strong></p>
<ul>
<li>立即停止：<code>nginx -s stop</code>，这种方法比较强硬，无论进程是否在工作，都直接停止进程。</li>
<li>从容停止服务：<code>nginx -s quit</code>，这种方法较stop相比就比较温和一些了，需要进程完成当前工作后再停止。</li>
<li>killall 方法杀死进程：<code>killall nginx</code>，也是比较野蛮的方法，当上面方法没起作用的时候，可以用这种。</li>
<li>systemctl停止：<code>systemctl stop nginx.service</code></li>
</ul>
<p><strong>重启Nginx服务</strong></p>
<ul>
<li>重启服务：<code>systemctl restart nginx.service</code></li>
<li>重新载入配置文件：<code>nginx -s reload</code>，在重新编写或者修改Nginx的配置文件后，都需要作一下重新载入。</li>
</ul>
<p><strong>查看端口号</strong></p>
<p>在默认情况下，Nginx启动后会监听80端口，从而提供HTTP访问，如果80端口已经被占用则会启动失败。我么可以使用<code>netstat -tlnp</code>命令查看端口号的占用情况。</p>
<h2 id="自定义错误页"><a href="#自定义错误页" class="headerlink" title="自定义错误页"></a>自定义错误页</h2><blockquote>
<p>真正好的网站会武装到牙齿，即便是不同种类的错误页面的显示</p>
</blockquote>
<p><strong>多错误指向一个页面</strong></p>
<p>在/etc/nginx/conf.d/default.conf 是可以看到下面这句话的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page   500 502 503 504  /50x.html;</span><br></pre></td></tr></table></figure>

<p>error_page指令用于自定义错误页面，500，502，503，504 这些就是HTTP中最常见的错误代码，/50.html 用于表示当发生上述指定的任意一个错误的时候，都是用网站根目录下的/50.html文件进行处理。</p>
<p><strong>单独为错误指定处理方式</strong></p>
<p>有些时候是要把这些错误页面单独的表现出来，给用户更好的体验。所以就要为每个错误码设置不同的页面。设置方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page 404  /404.html;</span><br></pre></td></tr></table></figure>

<p>然后到网站目录下新建一个404.html 文件，并写入一些信息。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>404页面没有找到!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后重启我们的服务，再进行访问，你会发现404页面发生了变化。</p>
<p><strong>把错误码换成一个地址</strong></p>
<p>处理错误的时候，不仅可以只使用本服务器的资源，还可以使用外部的资源。比如我们将配置文件设置成这样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page  404 http://jspang.com;</span><br></pre></td></tr></table></figure>

<p>我们使用了技术胖的博客地址作为404页面没有找到的提示，就形成了，没有找到文件，就直接跳到了技术胖的博客上了。</p>
<h2 id="Nginx访问权限"><a href="#Nginx访问权限" class="headerlink" title="Nginx访问权限"></a>Nginx访问权限</h2><p><strong>简单实现访问控制</strong></p>
<p>有时候我们的服务器<em>只允许特定主机访问</em>，比如内部OA系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些IP访问，我们可以直接在<code>location</code>里进行配置。</p>
<p>可以直接在default.conf里进行配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">       deny   123.9.51.42; <span class="comment">#禁止这个ip地址访问</span></span><br><span class="line">       allow  45.76.202.231; <span class="comment">#允许这个ip地址访问</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后，重启一下服务器就可以实现限制和允许访问了。</p>
<p><strong>指定优先级</strong></p>
<p>我们先来看一下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">       allow  45.76.202.231;</span><br><span class="line">       deny   all;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置表示只允许<code>45.76.202.231</code>进行访问，其他的IP是禁止访问的。但是如果我们把<code>deny all</code>指令，移动到 <code>allow 45.76.202.231</code>之前，会发生什么那？会发现所有的IP都不允许访问了。<strong>这说明了一个问题：就是在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（也就是谁先触发，谁起作用）</strong>。</p>
<p><strong>复杂访问控制权限匹配</strong></p>
<p>在工作中，访问权限的控制需求更加复杂，例如，对于网站下的img（图片目录）是运行所有用户访问，但对于网站下的admin目录则只允许公司内部固定IP访问。这时候仅靠deny和allow这两个指令，是无法实现的。我们需要location块来完成相关的需求匹配。</p>
<p>上面的需求，配置代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location =/img&#123;</span><br><span class="line">    allow all;</span><br><span class="line">&#125;</span><br><span class="line">location =/admin&#123;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>=</code>号代表精确匹配，使用了<code>=</code>后是根据其后的模式进行精确匹配。这个直接关系到我们网站的安全，一定要学会。</p>
<p><strong>使用正则表达式设置访问权限</strong></p>
<p>只有精确匹配有时是完不成我们的工作任务的，比如现在我们要禁止访问所有php的页面，php的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。</p>
<p>代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~\.php$ &#123;</span><br><span class="line">       deny all;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这样我们再访问的时候就不能访问以php结尾的文件了。这样让网站变的安全很多了。</p>
<h2 id="Nginx设置虚拟主机"><a href="#Nginx设置虚拟主机" class="headerlink" title="Nginx设置虚拟主机"></a>Nginx设置虚拟主机</h2><blockquote>
<p>虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供Web服务，并且互不干扰。在外界看来，虚拟主机就是一台独立的服务器主机，这意味着用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上，而不必再为建立一个网站单独购买一台服务器，既解决了维护服务器技术的难题，同时又极大地节省了服务器硬件成本和相关的维护费用。</p>
</blockquote>
<p>我们可以用一台服务器，建立多个网站，为其划分不同端口即可。</p>
<p>配置虚拟主机可以基于<strong>端口号</strong>、<strong>基于IP</strong>和<strong>基于域名</strong>。</p>
<p><strong>基于端口号配置虚拟主机</strong></p>
<blockquote>
<p>原理就是Nginx监听多个端口，根据不同的端口号，来区分不同的网站。</p>
</blockquote>
<p>我们可以直接配置在主文件里<code>etc/nginx/nginx.conf</code>文件里， 也可以配置在子配置文件里<code>etc/nginx/conf.d/default.conf</code>。我这里为了配置方便，就配置在子文件里了。当然你也可以再新建一个文件，只要在conf.d文件夹下就可以了。</p>
<p>修改配置文件中的server选项，这时候就会有两个server。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 8001;</span><br><span class="line">        server_name localhost;</span><br><span class="line">        root /usr/share/nginx/html/html8001;</span><br><span class="line">        index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编在<code>usr/share/nginx/html/html8001/</code>目录下的index.html文件并查看结果。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>welcome port 8001<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后在浏览器中分别访问地址和带端口的地址。看到的结果是不同的。</p>
<p>然后我们就可以在浏览器中访问<code>http://112.74.164.244:8001</code>了。</p>
<p><strong>基于IP的虚拟主机</strong></p>
<p>基于IP和基于端口的配置几乎一样，只是把<code>server_name</code>选项，配置成IP就可以了。</p>
<p>比如上面的配置，我们可以修改为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name 112.74.164.244;</span><br><span class="line">        root /usr/share/nginx/html/html8001;</span><br><span class="line">        index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基于域名配置虚拟主机</strong></p>
<p>在真实的上线环境中，一个网站是需要域名和公网IP才可以访问的。</p>
<p>先要对<strong>域名进行解析</strong>，这样域名才能正确定位到你需要的IP上。 我这里新建了两个解析，分别是:</p>
<ul>
<li>nginx.jspang.com :这个域名映射到默认的Nginx首页位置。</li>
<li>nginx2.jspang.com : 这个域名映射到原来的8001端口的位置。</li>
</ul>
<p>我们修改<code>etc/nginx/conf.d</code>目录下的<strong>default.conf</strong> 文件，把原来的80端口虚拟主机改为以域名划分的虚拟主机。代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  nginx.jspang.com;</span><br></pre></td></tr></table></figure>

<p>我们再把同目录下的<code>8001.conf</code>文件进行修改，改成如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name nginx2.jspang.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">                root /usr/share/nginx/html/html8001;</span><br><span class="line">                index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们用平滑重启的方式，进行重启，这时候我们在浏览器中访问这两个网页。</p>
<p>其实域名设置虚拟主机也非常简单，主要操作的是配置文件的server_name项，还需要域名解析的配合。</p>
<h2 id="Nginx反向代理设置"><a href="#Nginx反向代理设置" class="headerlink" title="Nginx反向代理设置"></a>Nginx反向代理设置</h2><blockquote>
<p>现在的web模式基本的都是标准的CS结构，即Client端到Server端。那代理就是在Client端和Server端之间增加一个提供特定功能的服务器，这个服务器就是我们说的代理服务器。</p>
</blockquote>
<p><strong>正向代理：</strong>如果你觉的反向代理不好理解，那先来了解一下正向代理。比如翻墙工具（我这里说的不是物理梯子），它就是一个典型的正向代理工具。它会把我们不让访问的服务器的网页请求，代理到一个可以访问该网站的代理服务器上来，一般叫做proxy服务器，再转发给客户。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1010792/vr3pz3ovzh.png?imageView2/2/w/1620" alt="img">简单来说就是你想访问目标服务器的权限，但是没有权限。这时候代理服务器有权限访问服务器，并且你有访问代理服务器的权限，这时候你就可以通过访问代理服务器，代理服务器访问真实服务器，把内容给你呈现出来。</p>
<p><strong>反向代理</strong>：反向代理跟代理正好相反（需要说明的是，现在基本所有的大型网站的页面都是用了反向代理），客户端发送的请求，想要访问server服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。<img src="https://ask.qcloudimg.com/http-save/yehe-1010792/md21eo1izs.png?imageView2/2/w/1620" alt="img"></p>
<p>通过图片的对比，应该看出一些区别，这里proxy服务器代理的并不是客户端，而是服务器,即向外部客户端提供了一个统一的代理入口，客户端的请求都要先经过这个proxy服务器。具体访问那个服务器server是由Nginx来控制的。再简单点来讲，一般代理指代理的客户端，反向代理是代理的服务器。</p>
<p><strong>反向代理的好处和用途</strong></p>
<ul>
<li>安全性：正向代理的客户端能够在隐藏自身信息的同时访问任意网站，这个给网络安全代理了极大的威胁。因此，我们必须把服务器保护起来，使用反向代理客户端用户只能通过外来网来访问代理服务器，并且用户并不知道自己访问的真实服务器是那一台，可以很好的提供安全保护。</li>
<li>功能性：反向代理的主要用途是为多个服务器提供负债均衡、缓存等功能。负载均衡就是一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那Nginx可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配，也叫负载均衡。</li>
</ul>
<p><strong>最简单的反向代理</strong></p>
<p>现在我们要访问<code>http://nginx2.jspang.com</code>然后反向代理到<code>jspang.com</code>这个网站。我们直接到<code>etc/nginx/con.d/8001.conf</code>进行修改。</p>
<p>修改后的配置文件如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name nginx2.jspang.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">        #使用proxy_pass指令</span><br><span class="line">               proxy_pass http://jspang.com;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般我们反向代理的都是一个IP，但是我这里代理了一个域名也是可以的。其实这时候我们反向代理就算成功了，我们可以在浏览器中打开<code>http://nginx2.jspang.com</code>来测试一下。</p>
<p><strong>其它反向代理指令</strong></p>
<ul>
<li>proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。</li>
<li>proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。</li>
<li>proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。</li>
<li>proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。</li>
<li>proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。</li>
</ul>
<h2 id="Nginx适配PC或移动端"><a href="#Nginx适配PC或移动端" class="headerlink" title="Nginx适配PC或移动端"></a>Nginx适配PC或移动端</h2><p>现在很多网站都是有了PC端和H5站点的，因为这样就可以根据客户设备的不同，显示出体验更好的，不同的页面了。</p>
<p>这样的需求有人说拿自适应就可以搞定，比如我们常说的bootstrap和24格布局法，这些确实是非常好的方案，但是无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东……这些大型网站就都没有采用自适应，而是用<strong>分开制作的方式</strong>。</p>
<p>那分开制作如何通过配置Nginx来识别出应该展示哪个页面呢？</p>
<p><strong>$http_user_agent的使用：</strong></p>
<p>Nginx通过内置变量<code>$http_user_agent</code>，可以获取到请求客户端的userAgent，就可以用户目前处于移动端还是PC端，进而展示不同的页面给用户。</p>
<p>操作步骤如下：</p>
<ol>
<li><p>在/usr/share/nginx/目录下新建两个文件夹，分别为：pc和mobile目录</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/nginx</span><br><span class="line">mkdir pc</span><br><span class="line">mkdir mobile</span><br></pre></td></tr></table></figure>
</li>
<li><p>在pc和moblic目录下，新建两个index.html文件，文件里下面内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>I am pc!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>I am mobile!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进入<code>etc/nginx/conf.d</code>目录下，修改8001.conf文件，改为下面的形式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">     listen 80;</span><br><span class="line">     server_name nginx2.jspang.com;</span><br><span class="line">     location / &#123;</span><br><span class="line">      root /usr/share/nginx/pc;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~* <span class="string">'(Android|webOS|iPhone|iPod|BlackBerry)'</span>) &#123;</span><br><span class="line">         root /usr/share/nginx/mobile;</span><br><span class="line">      &#125;</span><br><span class="line">      index index.html;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Nginx的Gzip压缩配置"><a href="#Nginx的Gzip压缩配置" class="headerlink" title="Nginx的Gzip压缩配置"></a>Nginx的Gzip压缩配置</h2><blockquote>
<p>Gzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip网页压缩的实现需要浏览器和服务器的支持。</p>
</blockquote>
<p>gzip是需要服务器和浏览器同事支持的。当浏览器支持gzip压缩时，会在请求消息中包含Accept-Encoding:gzip,这样Nginx就会向浏览器发送听过gzip后的内容，同时在相应信息头中加入Content-Encoding:gzip，声明这是gzip后的内容，告知浏览器要先解压后才能解析输出。</p>
<p><strong>gzip的配置项</strong></p>
<p>Nginx提供了专门的gzip模块，并且模块中的指令非常丰富。</p>
<ul>
<li>gzip : 该指令用于开启或 关闭gzip模块。</li>
<li>gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。</li>
<li>gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。</li>
<li>gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。</li>
<li>gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。</li>
<li>gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0.</li>
<li>gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。</li>
<li>gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。</li>
</ul>
<p><strong>gzip最简单的配置</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">   .....</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_types text/plain application/javascript text/css;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gzip on</code>是启用gizp模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和CSS文件进行压缩输出。</p>
<p>配置好后，我们就可以重启Nginx服务，让我们的gizp生效了。</p>
<p>如果你是windows操作系统，你可以按F12键打开开发者工具，单机当前的请求，在标签中选择Headers，查看HTTP响应头信息。你可以清楚的看见<code>Content-Encoding</code>为gzip类型。</p>
<p><a href="https://tool.chinaz.com/gzips/" target="_blank" rel="noopener">网页GZIP压缩检测</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/ReactHooks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SampsonKY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SampsonKY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/ReactHooks/" itemprop="url">React Hooks</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T19:22:23+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端学习/" itemprop="url" rel="index">
                    <span itemprop="name">前端学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h1><h2 id="React-Hooks-简介"><a href="#React-Hooks-简介" class="headerlink" title="React Hooks 简介"></a>React Hooks 简介</h2><p><code>React Hooks</code>就是用函数形式代替原来的继承类的形式，并且使用预函数的形式管理<code>state</code>,有Hooks可以不再使用类的形式定义组件了。原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。现在所有的组件都可以用函数来声明了。 </p>
<p> Hooks本质上就是一类特殊的函数，他们可以为你的函数型组件（function component）注入一些特殊的功能。 </p>
<p>原始写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>:<span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123; </span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;this.addCount.bind(this)&#125;&gt;Chlick me&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    addCount()&#123;</span></span><br><span class="line"><span class="regexp">        this.setState(&#123;count:this.state.count+1&#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Example;</span></span><br></pre></td></tr></table></figure>

<p>React Hooks 写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Example;</span></span><br></pre></td></tr></table></figure>

<h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>count为定义的变量，为它赋予初始值0，setCount为其对应的方法；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>

<p>读取它的值，只要使用<code>{count}</code>就可以了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;()=&gt;&#123;setCount(count+<span class="number">1</span>)&#125;&#125;&gt;click me&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<p> 直接调用setCount函数，这个函数接收的参数是修改过的新状态值 。</p>
<p> 接下来的事情就交给<code>React</code>,他会重新渲染组件。<strong><code>React</code>自动帮助我们记忆了组件的上一次状态值 。</strong></p>
<p> <strong>React Hooks不能出现在条件判断语句中，因为它必须有完全一样的渲染顺序</strong>。 </p>
<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>代替<code>componentDidMount</code>和<code>componentDidUpdate</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState , useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`useEffect=&gt;You clicked <span class="subst">$&#123;count&#125;</span> times`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Example;</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>React首次渲染和之后的 每次渲染都会调用一遍<code>useEffect</code>函数，而之前我们要用两个生命周期函数分别表示首次渲染(<code>componentDidMonut</code>)和更新导致的重新渲染(<code>componentDidUpdate</code>)。 </li>
<li>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时<strong>异步执行</strong>的，而<code>componentDidMonut</code>和<code>componentDidUpdate</code>中的代码都是同步执行的。个人认为这个有好处也有坏处吧，比如我们要根据页面的大小，然后绘制当前弹出窗口的大小，如果时异步的就不好操作了。 </li>
</ol>
<p>实现<code>componentWillUnmount</code>生命周期函数</p>
<p> 在写React应用的时候，在组件中经常用到<code>componentWillUnmount</code>生命周期函数（组件将要被卸载时执行）。比如我们的定时器要清空，避免发生内存泄漏;比如登录状态要取消掉，避免下次进入信息出错。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'useEffect=&gt;老弟你来了！Index页面'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'老弟，你走了!Index页面'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>JSPang.com<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>return用与解绑组件。</p>
<p> <code>useEffect</code>的第二个参数，它是一个数组，数组中可以写入很多状态对应的变量，意思是当<strong>状态值</strong>发生变化时，我们才进行解绑。但是当传空数组<code>[]</code>时，就是当组件将被销毁时才进行解绑，这也就实现了<code>componentWillUnmount</code>的生命周期函数。 </p>
<h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p> <code>useContext</code>，它可以帮助我们跨越组件层级直接传递变量，实现共享。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState , createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="comment">//===关键代码</span></span><br><span class="line"><span class="keyword">const</span> CountContext = createContext()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example4</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , setCount ] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount(count+1)&#125;&#125;&gt;click me&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">            &lt;CountContext.Provider value=&#123;count&#125;&gt;</span><br><span class="line">                &lt;Counter /&gt;</span><br><span class="line">            &lt;<span class="regexp">/CountContext.Provider&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = useContext(CountContext)  <span class="comment">//一句话就可以得到count</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example4;</span><br></pre></td></tr></table></figure>

<p>使用<code>const CountContext = createContext()</code>创建全局上下文；再使用<code>CountContext.Provider</code>实现共享，在子组件中使用<code>useContext()</code>接收值。</p>
<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p> <code>reducer</code>其实就是一个函数，这个函数接收两个参数，一个是<strong>状态</strong>，一个用来<strong>控制业务逻辑的判断参数</strong> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReducerDemo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ count , dispatch ] =useReducer(<span class="function">(<span class="params">state,action</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(action)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">                <span class="keyword">return</span> state+<span class="number">1</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'sub'</span>:</span><br><span class="line">                <span class="keyword">return</span> state<span class="number">-1</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">           &lt;h2&gt;现在的分数是&#123;count&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">           &lt;button onClick=&#123;()=&gt;dispatch('add')&#125;&gt;Increment&lt;/</span>button&gt;</span><br><span class="line">           &lt;button onClick=&#123;()=&gt;dispatch(<span class="string">'sub'</span>)&#125;&gt;Decrement&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">       &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReducerDemo</span><br></pre></td></tr></table></figure>

<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p> <code>useMemo</code>主要用来解决使用React hooks产生的无用渲染的性能问题。使用function的形式来声明组件，失去了<code>shouldCompnentUpdate</code>（在组件更新之前）这个生命周期，也就是说我们没有办法通过组件更新前条件来决定组件是否更新。而且在函数组件中，也不再区分<code>mount</code>和<code>update</code>两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。<code>useMemo</code>和<code>useCallback</code>都是解决上述性能问题的 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React , &#123;useState,useMemo&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count1 , setCount1] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [count2 , setCount2] = useState(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;button onClick=&#123;()=&gt;&#123;setCount1(count1+<span class="number">1</span>)&#125;&#125;&gt;count1加<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;&#123;setCount2(count2-1)&#125;&#125;&gt;count2减1&lt;/</span>button&gt;</span><br><span class="line">            &lt;ChildComponent name=&#123;count2&#125;&gt;&#123;count1&#125;&lt;<span class="regexp">/ChildComponent&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildComponent</span>(<span class="params">&#123;name,children&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeCount2</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'count2减1了！！'</span>)</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> actionCount2 = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> changeCount2(name), [name])</span><br><span class="line">    <span class="comment">// const actionCount2 = changeCount2(name)</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;div&gt;count1:&#123;children&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;count2:&#123;actionCount2&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义Hooks函数"><a href="#自定义Hooks函数" class="headerlink" title="自定义Hooks函数"></a>自定义Hooks函数</h2><p> 其实自定义Hooks函数和用Hooks创建组件很相似，跟我们平时用JavaScript写函数几乎一模一样，可能就是多了些<code>React Hooks</code>的特性，自定义Hooks函数偏向于功能，而组件偏向于界面和业务逻辑。由于差别不大，所以使用起来也是很随意的。如果是小型项目是可以的，但是如果项目足够复杂，这会让项目结构不够清晰。所以学习自定义Hooks函数还是很有必要的。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useWinSize</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [ size , setSize] = useState(&#123;</span><br><span class="line">        width:<span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">        height:<span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> onResize = useCallback(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        setSize(&#123;</span><br><span class="line">            width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">            height: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,[]) </span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>,onResize)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>,onResize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example9</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> size = useWinSize()</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;页面Size:&#123;size.width&#125;x&#123;size.height&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Example9</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/生命周期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SampsonKY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SampsonKY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/生命周期/" itemprop="url">react生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T19:22:14+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端学习/" itemprop="url" rel="index">
                    <span itemprop="name">前端学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="react生命周期"><a href="#react生命周期" class="headerlink" title="react生命周期"></a>react生命周期</h1><p><strong>React 生命周期图</strong></p>
<p><img src="https://jspang.com/images/React1901.png" alt="React声明周期图"></p>
<p>React生命周期四大阶段：</p>
<ol>
<li><code>Initialization</code>:初始化阶段。</li>
<li><code>Mounting</code>: 挂载阶段。</li>
<li><code>Updation</code>: 更新阶段。</li>
<li><code>Unmounting</code>: 销毁阶段</li>
</ol>
<p><strong>什么是生命周期函数？</strong></p>
<p>一句话：</p>
<blockquote>
<p>生命周期函数指在某一个时刻组件会自动调用执行的函数。</p>
</blockquote>
<p>比如：todo里的<code>reder()</code>函数就是一个生命周期函数，它在 state发生改变时自动执行。这就是一个标准的自动执行函数。 </p>
<ul>
<li><code>constructor</code>不算生命周期函数。</li>
</ul>
<p><code>constructor</code>我们叫构造函数，它是ES6的基本语法。虽然它和生命周期函数的性质一样，但不能认为是生命周期函数。</p>
<p>但是你要心里把它当成一个生命周期函数，可以看成React的<code>Initialization</code>阶段，定义属性（props）和状态(state)。</p>
<p><strong>Mounting阶段（挂载阶段）</strong></p>
<p>Mounting阶段伴随着整个虚拟DOM的生成，它里面包括三个小的生命周期函数，分别是：</p>
<ol>
<li><p><strong><code>componentWillMount</code></strong> : 在组件即将被挂载到页面的时刻执行。</p>
</li>
<li><p><strong><code>render</code></strong> : 页面state或props发生变化时执行。</p>
<p>render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染</p>
</li>
<li><p><strong><code>componentDidMount</code></strong> : 组件挂载完成时被执行。</p>
<p>组件第一次渲染完成，此时的dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染</p>
</li>
</ol>
<ul>
<li><code>componentWillMount</code>和<code>componentDidMount</code>这两个生命周期函数，只在页面刷新时执行一次，而<code>render</code>函数是只要有state和props变化就会执行 </li>
</ul>
<p><strong>Updation阶段（更新阶段）</strong></p>
<p> <code>Updation</code>阶段是组件发生改变的更新阶段，这是React生命周期中比较复杂的一部分，它有两个基本部分组成，一个是<code>props</code>属性改变，一个是<code>state</code>状态改变 </p>
<ul>
<li><p><strong>shouldComponentUpdate函数</strong></p>
<p> <code>shouldComponentUpdate</code>函数会在组件更新之前，自动被执行。  它要求返回一个布尔类型的结果，必须有返回值 ， 返回true，就同意组件更新；返回false,就反对组件更新。 </p>
<p>shouldComponentUpdate有两个参数：</p>
<ul>
<li><p>nextProps:变化后的属性;</p>
</li>
<li><p>nextState:变化后的状态;</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//避免子组件频繁无用渲染render</span></span><br><span class="line">shouldComponentUpdate(nextProps,nextState)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nextProps.content !== <span class="keyword">this</span>.props.content)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>componentWillUpadate函数</strong></p>
<p> <code>componentWillUpdate</code>在组件更新之前，但<code>shouldComponenUpdate</code>之后被执行。但是如果<code>shouldComponentUpdate</code>返回false，这个函数就不会被执行了。 </p>
</li>
<li><p><strong>componentDidUpdate函数</strong></p>
<p> <code>componentDidUpdate</code>在组件更新之后执行，它是组件更新的最后一个环节。 </p>
</li>
<li><p><strong>componentWillReceiveProps函数</strong></p>
<blockquote>
<p> 子组件接收到父组件传递过来的参数，父组件render函数重新被执行，这个生命周期就会被执行。 </p>
</blockquote>
<ul>
<li>也就是说这个组件第一次存在于Dom中，函数是不会被执行的;</li>
<li>如果已经存在于Dom中，函数才会被执行。</li>
</ul>
</li>
</ul>
<p><strong>Unmounting阶段（卸载阶段）</strong></p>
<ul>
<li><p><strong>componentWillUnmount函数</strong></p>
<p> 这个函数是组件从页面中删除的时候执行 。</p>
<blockquote>
<ol>
<li>clear你在组件中所有的setTimeout、setInterval</li>
<li>移除所有组件中的兼听 removeEventListener</li>
</ol>
</blockquote>
</li>
</ul>
<p><strong>参考：</strong></p>
<p><a href="[https://jspang.com/posts/2019/05/04/new-react-base.html#%E7%AC%AC20%E8%8A%82%EF%BC%9Areact%E9%AB%98%E7%BA%A7-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AE%B2%E8%A7%A3-2](https://jspang.com/posts/2019/05/04/new-react-base.html#第20节：react高级-生命周期讲解-2)">技术胖</a></p>
<p><a href="https://www.jianshu.com/p/c9bc994933d5" target="_blank" rel="noopener">react生命周期基本用法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/利用react-router4的react-router-config做路由鉴权/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SampsonKY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SampsonKY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/利用react-router4的react-router-config做路由鉴权/" itemprop="url">利用react-router4的react-router-config做路由鉴权</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T19:20:32+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端学习/" itemprop="url" rel="index">
                    <span itemprop="name">前端学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="利用react-router4的react-router-config做路由鉴权"><a href="#利用react-router4的react-router-config做路由鉴权" class="headerlink" title="利用react-router4的react-router-config做路由鉴权"></a>利用react-router4的react-router-config做路由鉴权</h1><p>文章来源：<a href="https://segmentfault.com/a/1190000015282620" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015282620</a></p>
<p>一、react-router-config 是一个帮助我们配置静态路由的小助手。<br>其源码就是一个高阶函数 利用一个map函数生成静态路由</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> Switch <span class="keyword">from</span> <span class="string">"react-router/Switch"</span>;</span><br><span class="line"><span class="keyword">import</span> Route <span class="keyword">from</span> <span class="string">"react-router/Route"</span>;</span><br><span class="line"><span class="keyword">const</span> renderRoutes = <span class="function">(<span class="params">routes, extraProps = &#123;&#125;, switchProps = &#123;&#125;</span>) =&gt;</span></span><br><span class="line">routes ? (</span><br><span class="line">    &lt;Switch &#123;...switchProps&#125;&gt;</span><br><span class="line">        &#123;routes.map(<span class="function">(<span class="params">route, i</span>) =&gt;</span> ( </span><br><span class="line">        &lt;Route</span><br><span class="line">          key=&#123;route.key || i&#125;</span><br><span class="line">          path=&#123;route.path&#125;</span><br><span class="line">          exact=&#123;route.exact&#125;</span><br><span class="line">          strict=&#123;route.strict&#125;</span><br><span class="line">          render=&#123;props =&gt; (</span><br><span class="line">            &lt;route.component &#123;...props&#125; &#123;...extraProps&#125; route=&#123;route&#125; /&gt;</span><br><span class="line">          )&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">  ) : null;</span></span><br><span class="line"><span class="regexp"> export default renderRoutes;</span></span><br></pre></td></tr></table></figure>

<p>//router.js 假设这是我们设置的路由数组（这种写法和vue很相似是不是?)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/'</span>,</span><br><span class="line">        exact: <span class="literal">true</span>,</span><br><span class="line">        component: Home,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/login'</span>,</span><br><span class="line">        component: Login,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/user'</span>,</span><br><span class="line">        component: User,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'*'</span>,</span><br><span class="line">        component: NotFound</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>//app.js 那么我们在app.js里这么使用就能帮我生成静态的路由了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; renderRoutes &#125; <span class="keyword">from</span> <span class="string">'react-router-config'</span></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'./router.js'</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">   &lt;main&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">         &#123;renderRoutes(routes)&#125;</span><br><span class="line">      &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/m</span>ain&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>

<p>扯了半天，要如何利用这个插件帮我们路由鉴权呢？<br>用过vue的小朋友都知道，vue的router.js 里面添加 <code>meta: { requiresAuth: true }</code><br>然后利用<code>导航守卫</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在每次路由进入之前判断requiresAuth的值，如果是true的话呢就先判断是否已登陆</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>二、<strong>基于类似vue的路由鉴权想法，我们稍稍改造一下react-router-config</strong><br>// utils/renderRoutes.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Route, Redirect, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">const</span> renderRoutes = <span class="function">(<span class="params">routes, authed, authPath = <span class="string">'/login'</span>, extraProps = &#123;&#125;, switchProps = &#123;&#125;</span>) =&gt;</span> routes ? (</span><br><span class="line">  &lt;Switch &#123;...switchProps&#125;&gt;</span><br><span class="line">    &#123;routes.map(<span class="function">(<span class="params">route, i</span>) =&gt;</span> (</span><br><span class="line">      &lt;Route</span><br><span class="line">        key=&#123;route.key || i&#125;</span><br><span class="line">        path=&#123;route.path&#125;</span><br><span class="line">        exact=&#123;route.exact&#125;</span><br><span class="line">        strict=&#123;route.strict&#125;</span><br><span class="line">        render=&#123;(props) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (!route.requiresAuth || authed || route.path === authPath) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">route.component</span> &#123;<span class="attr">...props</span>&#125; &#123;<span class="attr">...extraProps</span>&#125; <span class="attr">route</span>=<span class="string">&#123;route&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          &#125;</span></span><br><span class="line">          return &lt;Redirect to=&#123;&#123; pathname: authPath, state: &#123; from: props.location &#125; &#125;&#125; /&gt;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">) : null</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default renderRoutes</span></span><br></pre></td></tr></table></figure>

<p>修改后的源码增加了两个参数 authed 、 authPath 和一个属性 route.requiresAuth<br>然后再来看一下最关键的一段代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!route.requiresAuth || authed || route.path === authPath) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">route.component</span> &#123;<span class="attr">...props</span>&#125; &#123;<span class="attr">...extraProps</span>&#125; <span class="attr">route</span>=<span class="string">&#123;route&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line">    return &lt;Redirect to=&#123;&#123; pathname: authPath, state: &#123; from: props.location &#125; &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>很简单 如果 route.requiresAuth = false 或者 authed = true 或者 route.path === authPath（参数默认值’/login’）则渲染我们页面，否则就渲染我们设置的<strong>authPath</strong>页面，并记录从哪个页面跳转。</p>
<p>相应的router.js也要稍微修改一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/'</span>,</span><br><span class="line">        exact: <span class="literal">true</span>,</span><br><span class="line">        component: Home,</span><br><span class="line">        requiresAuth: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/login'</span>,</span><br><span class="line">        component: Login,</span><br><span class="line">        requiresAuth: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/user'</span>,</span><br><span class="line">        component: User,</span><br><span class="line">        requiresAuth: <span class="literal">true</span>, <span class="comment">//需要登陆后才能跳转的页面</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'*'</span>,</span><br><span class="line">        component: NotFound,</span><br><span class="line">        requiresAuth: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>//app.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="comment">//import &#123; renderRoutes &#125; from 'react-router-config'</span></span><br><span class="line"><span class="keyword">import</span> renderRoutes <span class="keyword">from</span> <span class="string">'./utils/renderRoutes'</span></span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'./router.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> authed = <span class="literal">false</span> <span class="comment">// 如果登陆之后可以利用redux修改该值(关于redux不在我们这篇文章的讨论范围之内）</span></span><br><span class="line"><span class="keyword">const</span> authPath = <span class="string">'/login'</span> <span class="comment">// 默认未登录的时候返回的页面，可以自行设置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">   &lt;main&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">         &#123;renderRoutes(routes, authed, authPath)&#125;</span><br><span class="line">      &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">   &lt;/m</span>ain&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br><span class="line"><span class="comment">//登陆之后返回原先要去的页面login函数</span></span><br><span class="line">login()&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">from</span> &#125; = <span class="keyword">this</span>.props.location.state || &#123; <span class="attr">from</span>: &#123; <span class="attr">pathname</span>: <span class="string">'/'</span> &#125; &#125;</span><br><span class="line">     <span class="comment">// authed = true // 这部分逻辑自己写吧。。。</span></span><br><span class="line">    <span class="keyword">this</span>.props.history.push(<span class="keyword">from</span>.pathname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上～修改了部分源码并完成了我们想要的效果。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/作用域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SampsonKY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SampsonKY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/作用域/" itemprop="url">作用域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T17:55:32+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端学习/" itemprop="url" rel="index">
                    <span itemprop="name">前端学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h2><p>作用域是代码在运行时，某些特定部分中的变量，函数，和对象的可访问性。作用域负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。换句话说，作用域决定了变量和函数的可访问范围，即<strong>作用域控制着变量和函数的可见性和生命周期</strong>。</p>
<h2 id="JavaScript中的作用域"><a href="#JavaScript中的作用域" class="headerlink" title="JavaScript中的作用域"></a>JavaScript中的作用域</h2><ul>
<li>全局作用域</li>
<li>局部作用域</li>
</ul>
<p>如果一个变量在函数外或者大括号<code>{}</code>外声明的，那么就定义了一个<strong>全局作用域</strong>；在ES6之前局部作用域只包含了函数作用域，ES6为我们提供了<strong>块级作用域</strong>，也属于<strong>局部作用域。</strong></p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p><strong>拥有全局作用域的对象可以在代码的任何地方访问到。</strong></p>
<p>以下情形拥有全局作用域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;           <span class="comment">//①最外层变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;     <span class="comment">//②最外层函数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a = <span class="number">3</span>;   <span class="comment">//③未经定义直接赋值的变量（由于变量提升使之成为全局变量）</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.a = <span class="number">5</span>;  <span class="comment">//④通过window来添加一个全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p><strong>局部作用域一般只能在固定代码片段中可以访问到。最常见的为函数作用域</strong></p>
<h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><blockquote>
<p>定义在函数中的变量就在函数作用域中。并且函数在每次调用时都有一个不同的作用域。这意味着<strong>同名变量可以用在不同的函数中</strong>。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。</p>
</blockquote>
<p>函数作用域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">5</span>;    <span class="comment">//局部变量，【注意】：不能省略var，否则会因为变量提升成为全局变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//函数内可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//函数外不可访问</span></span><br></pre></td></tr></table></figure>

<p>块级作用域测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">   <span class="keyword">var</span> num+=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//3 ---此处for语句块内部与外面是同一个作用域</span></span><br></pre></td></tr></table></figure>

<h4 id="关于变量提升"><a href="#关于变量提升" class="headerlink" title="关于变量提升"></a>关于变量提升</h4><blockquote>
<p> 在Javascript中，函数及变量的声明都将被提升到函数的最顶部，也就是说我们可以先使用后声明,但函数表达式和变量表达式只是将函数或者变量的声明提升到函数顶部，函数表达式和变量的初始化将不被提升</p>
</blockquote>
<p>变量提升的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp);<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp=<span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【注意】这里申明提升了，定义的内容并不会提升</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        tmp=<span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在重复声明的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//3</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">4</span>;  <span class="comment">//此处声明会被忽略！！！仅用于赋值！</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//4</span></span><br><span class="line"><span class="comment">//【注意】在同一作用域用var声明变量多次，后面的var声明会被忽略</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//3</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    a = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<p>变量和函数同时提升：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//[Function: a]</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//函数声明形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//函数表达式形式</span></span><br></pre></td></tr></table></figure>

<p>情况二就相当于重复声明的例子，容易理解。对于情况一，其等价形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数声明被提升到最顶上；</li>
<li>申明只进行一次，因此后面<code>var a = 1</code>的申明会被忽略。</li>
<li><strong>函数申明的优先级优于变量申明，且函数声明会连带定义一起被提升</strong>（这里与变量不同）</li>
</ul>
<h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><blockquote>
<p>ES6新增了<code>let</code>和<code>const</code>命令，可以用来创建<strong>块级作用域变量</strong>，使用<code>let</code>命令声明的变量只在<code>let</code>命令所在<strong>代码块</strong>内有效。</p>
</blockquote>
<p>使用<code>let</code>声明变量，会将变量的作用域限制在当前代码块中。特点：</p>
<ul>
<li>变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量</li>
<li>不允许反复声明</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//error</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;<span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><h3 id="关于编译原理"><a href="#关于编译原理" class="headerlink" title="关于编译原理"></a>关于编译原理</h3><p><img src="/images/zuoyongyu1.jpg" alt="编译原理"></p>
<p>传统编译语言流程：</p>
<ol>
<li>分词/词法解析：这个过程会由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元（token）。例如：<code>var a = 2;</code>通常被分解为：var、a、=、2、; 。</li>
<li>解析/语法分析：这个过程将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个数被抽象为“抽象语法树”（AST)。</li>
<li>代码生成。将AST转换为可执行的过程被称为代码生成。</li>
</ol>
<p>JavaScript编译过程不同之处：</p>
<ul>
<li><code>JavaScript</code> 大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内</li>
<li><code>JavaScript</code> 引擎用尽了各种办法(比如 <code>JIT</code>，可以延 迟编译甚至实施重编译)来保证性能最佳</li>
</ul>
<h3 id="JavaScript是如何执行的"><a href="#JavaScript是如何执行的" class="headerlink" title="JavaScript是如何执行的"></a>JavaScript是如何执行的</h3><p><img src="/images/zuoyongyu2.jpg" alt="JavaScript编译过程"></p>
<ul>
<li>核心重点：变量和函数在内的所有声明都会在任何代码被执行前首先被处理。</li>
<li>函数运行的瞬间，创建一个<strong>AO</strong> (Active Object 活动对象)运行载体。</li>
</ul>
<h3 id="作用域链是什么？"><a href="#作用域链是什么？" class="headerlink" title="作用域链是什么？"></a>作用域链是什么？</h3><p>JavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到window（全局作用域）。而这一条形成的“AO链” 就是JavaScript中的作用域链。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>《你不知道的JavaScript》上卷</li>
<li><a href="https://segmentfault.com/a/1190000019783405" target="_blank" rel="noopener">深入理解JavaScript</a></li>
<li><a href="https://www.jianshu.com/p/0c69c777e0a4" target="_blank" rel="noopener">javascript作用域</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/11/vim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SampsonKY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SampsonKY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/11/vim/" itemprop="url">Vim基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-11T15:02:00+08:00">
                2020-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><h2 id="Vim快速入门"><a href="#Vim快速入门" class="headerlink" title="Vim快速入门"></a>Vim快速入门</h2><h3 id="Vim模式简介"><a href="#Vim模式简介" class="headerlink" title="Vim模式简介"></a>Vim模式简介</h3><blockquote>
<p>从vi衍生出来的Vim具有多种模式，这种独特的设计容易使初学者产生混淆。几乎所有的编辑器都会有<em>插入</em>和<em>执行</em>命令两种模式，并且大多数的编辑器使用了与Vim截然不同的方式：命令目录（鼠标或者键盘驱动），组合键（通常通过control键（CTRL）和alt键（ALT）组成）或者鼠标输入。Vim和vi一样，仅仅通过键盘来在这些模式之中切换。这就使得Vim可以不用进行菜单或者鼠标操作，并且最小化组合键的操作。对文字录入员或者程序员可以大大增强速度和效率。</p>
</blockquote>
<p>Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式：</p>
<ul>
<li>普通模式(Normal mode)</li>
</ul>
<blockquote>
<p>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</p>
</blockquote>
<blockquote>
<p>Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令<code>dd</code>删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个<code>d</code>，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，<code>2dd</code>（重复<code>dd</code>两次），和<code>dj</code>的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。</p>
</blockquote>
<blockquote>
<p>在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按<code>a</code>（append／追加）键或者<code>i</code>（insert／插入）键。</p>
</blockquote>
<ul>
<li>插入模式(Insert mode)</li>
</ul>
<blockquote>
<p>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。</p>
</blockquote>
<blockquote>
<p>在插入模式中，可以按<code>ESC</code>键回到普通模式。</p>
</blockquote>
<ul>
<li>可视模式(Visual mode)</li>
</ul>
<blockquote>
<p>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。</p>
</blockquote>
<ul>
<li>选择模式(Select mode)</li>
</ul>
<blockquote>
<p>这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p>
</blockquote>
<ul>
<li>命令行模式(Command line mode)</li>
</ul>
<blockquote>
<p>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（<code>:</code>键），搜索（<code>/</code>和<code>?</code>键）或者过滤命令（<code>!</code>键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</p>
</blockquote>
<ul>
<li>Ex模式(Ex mode)</li>
</ul>
<blockquote>
<p>这和命令行模式比较相似，在使用<code>:visual</code>命令离开Ex模式前，可以一次执行多条命令。</p>
</blockquote>
<blockquote>
<p>这其中我们常用到就是普通模式、插入模式和命令行模式，本课程也只涉及这三个常用模式的内容</p>
</blockquote>
<h3 id="进入vim"><a href="#进入vim" class="headerlink" title="进入vim"></a>进入vim</h3><p><strong>使用vim命令进入vim界面</strong></p>
<p>vim后面加上你要打开的已存在的文件名或者不存在（则作为新建文件）的文件名。 打开Xfce终端，输入以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim practice_1.txt</span><br></pre></td></tr></table></figure>

<p>直接使用vim也可以打开vim编辑器，但是不会打开任何文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim</span><br></pre></td></tr></table></figure>

<p>进入命令行模式后输入<code>:e 文件路径</code> 同样可以打开相应文件。</p>
<p><strong>游标移动</strong></p>
<p>在进入vim后，按下<code>i</code>键进入插入模式。在该模式下您可以输入文本信息.</p>
<p>按<code>Esc</code>进入普通模式，在该模式下使用方向键或者<code>h</code>,<code>j</code>,<code>k</code>,<code>l</code>键可以移动游标。</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>h</code></td>
<td>左</td>
</tr>
<tr>
<td><code>l</code></td>
<td>右（小写L）</td>
</tr>
<tr>
<td><code>j</code></td>
<td>下</td>
</tr>
<tr>
<td><code>k</code></td>
<td>上</td>
</tr>
<tr>
<td><code>w</code></td>
<td>移动到下一个单词</td>
</tr>
</tbody></table>
<h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h3><p>在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>i</code></td>
<td>在当前光标处进行编辑</td>
</tr>
<tr>
<td><code>I</code></td>
<td>在行首插入</td>
</tr>
<tr>
<td><code>A</code></td>
<td>在行末插入</td>
</tr>
<tr>
<td><code>a</code></td>
<td>在光标后插入编辑</td>
</tr>
<tr>
<td><code>o</code></td>
<td>在当前行后插入一个新行</td>
</tr>
<tr>
<td><code>O</code></td>
<td>在当前行前插入一个新行</td>
</tr>
<tr>
<td><code>cw</code></td>
<td>替换从光标所在位置后到一个单词结尾的字符</td>
</tr>
</tbody></table>
<h3 id="保存文档"><a href="#保存文档" class="headerlink" title="保存文档"></a>保存文档</h3><p><strong>命令行模式下保存文档</strong></p>
<p>从普通模式输入<code>:</code>进入命令行模式，输入<code>w</code>回车，保存文档。输入<code>:w 文件名</code>可以将文档另存为其他文件名或存到其它路径下</p>
<h3 id="退出vim"><a href="#退出vim" class="headerlink" title="退出vim"></a>退出vim</h3><p><strong>命令行模式下退出vim</strong></p>
<p>从普通模式输入<code>:</code>进入命令行模式，输入<code>wq</code>回车，保存并退出编辑</p>
<p>以下为其它几种退出方式：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:q!</code></td>
<td>强制退出，不保存</td>
</tr>
<tr>
<td><code>:q</code></td>
<td>退出</td>
</tr>
<tr>
<td><code>:wq!</code></td>
<td>强制保存并退出</td>
</tr>
<tr>
<td><code>:w &lt;文件路径&gt;</code></td>
<td>另存为</td>
</tr>
<tr>
<td><code>:saveas 文件路径</code></td>
<td>另存为</td>
</tr>
<tr>
<td><code>:x</code></td>
<td>保存并退出</td>
</tr>
<tr>
<td><code>:wq</code></td>
<td>保存并退出</td>
</tr>
</tbody></table>
<p><strong>普通模式下退出vim</strong></p>
<p>普通模式下输入<code>Shift+zz</code>即可保存退出vim</p>
<h3 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h3><p><strong>普通模式下删除vim文本信息</strong></p>
<p>进入普通模式，使用下列命令可以进行文本快速删除：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>x</code></td>
<td>删除游标所在的字符</td>
</tr>
<tr>
<td><code>X</code></td>
<td>删除游标所在前一个字符</td>
</tr>
<tr>
<td><code>Delete</code></td>
<td>同<code>x</code></td>
</tr>
<tr>
<td><code>dd</code></td>
<td>删除整行</td>
</tr>
<tr>
<td><code>dw</code></td>
<td>删除一个单词（不适用中文）</td>
</tr>
<tr>
<td><code>d$</code>或<code>D</code></td>
<td>删除至行尾</td>
</tr>
<tr>
<td><code>d^</code></td>
<td>删除至行首</td>
</tr>
<tr>
<td><code>dG</code></td>
<td>删除到文档结尾处</td>
</tr>
<tr>
<td><code>d1G</code></td>
<td>删至文档首部</td>
</tr>
</tbody></table>
<p>除此之外，你还可以在命令之前加上数字，表示一次删除多行，如：</p>
<p><code>2dd</code>表示一次删除2行</p>
<h2 id="Vim-文档编辑"><a href="#Vim-文档编辑" class="headerlink" title="Vim 文档编辑"></a>Vim 文档编辑</h2><h3 id="Vim重复命令"><a href="#Vim重复命令" class="headerlink" title="Vim重复命令"></a>Vim重复命令</h3><p><strong>重复执行上次命令</strong></p>
<p>在普通模式下<code>.</code>(小数点)表示重复上一次的命令操作</p>
<p>比如：普通模式下输入<code>x</code>，删除第一个字符，输入<code>.</code>(小数点)会再次删除一个字符，除此之外也可以重复<code>dd</code>的删除操作</p>
<p><strong>执行指令次数相同的命令</strong></p>
<p>进入普通模式输入<code>N</code>，N 表示重复后面的次数，下面来练习：</p>
<p>比如：</p>
<ul>
<li>输入<code>10x</code>，删除10个连续字符</li>
<li>输入<code>3dd</code>，将会删除3行文本</li>
</ul>
<p>在普通模式下，你还可以使用<code>dw</code>或者<code>daw</code>(delete a word)删除一个单词，所以你可以很容易的联想到<code>dnw</code>(<strong>n替换为相应数字</strong>) 表示删除n个单词</p>
<h3 id="游标快速跳转"><a href="#游标快速跳转" class="headerlink" title="游标快速跳转"></a>游标快速跳转</h3><p>普通模式下，下列命令可以让光标快速调转到指定位置，我们分别讨论快速实现<strong>行间</strong>跳转和<strong>行内</strong>跳转</p>
<p><strong>行间跳转</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>nG</code>(n Shift+g)</td>
<td>游标移动到第 n 行<strong>(如果默认没有显示行号，请先进入命令模式，输入<code>:set nu</code>以显示行号)</strong></td>
</tr>
<tr>
<td><code>gg</code></td>
<td>游标移动到到第一行</td>
</tr>
<tr>
<td><code>G</code>(Shift+g)</td>
<td>到最后一行</td>
</tr>
</tbody></table>
<p><strong>小技巧：你在完成依次跳转后，可以使用 <code>Ctrl+o</code> 快速回到上一次(跳转前)光标所在位置</strong>,这个技巧很实用，比如当你在写代码时，忽然想起有个 bug，需要修改，这时候你跳过去改好了，只需要按下 <code>Ctrl+o</code> 就可以回到你之前的位置。vim 中会用很多类似的小技巧就等着你去发掘。</p>
<p><strong>行内跳转</strong></p>
<p>普通模式下使用下列命令在行内按照单词为单位进行跳转</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>w</code></td>
<td>到下一个单词的开头</td>
</tr>
<tr>
<td><code>e</code></td>
<td>到当前单词的结尾</td>
</tr>
<tr>
<td><code>b</code></td>
<td>到前一个单词的开头</td>
</tr>
<tr>
<td><code>ge</code></td>
<td>到前一个单词的结尾</td>
</tr>
<tr>
<td><code>0</code>或<code>^</code></td>
<td>到行头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>到行尾</td>
</tr>
<tr>
<td><code>f&lt;字母&gt;</code></td>
<td>向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用)</td>
</tr>
<tr>
<td><code>F&lt;字母&gt;</code></td>
<td>向前搜索&lt;字母&gt;并跳转到第一个匹配的位置</td>
</tr>
<tr>
<td><code>t&lt;字母&gt;</code></td>
<td>向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用)</td>
</tr>
<tr>
<td><code>T&lt;字母&gt;</code></td>
<td>向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用)</td>
</tr>
</tbody></table>
<p>操作练习：</p>
<ul>
<li>在普通模式下，任意跳转到一行，使用 <code>w</code> 跳转到一个单词的开头，然后使用 <code>dw</code> 删除这个单词</li>
<li>在普通模式下，使用 <code>e</code> 跳转到一个单词的结尾，并使用 <code>~</code> 将游标所在字母变成大写或小写</li>
</ul>
<h3 id="复制粘贴和剪切"><a href="#复制粘贴和剪切" class="headerlink" title="复制粘贴和剪切"></a>复制粘贴和剪切</h3><p><strong>复制及粘贴文本</strong></p>
<ul>
<li>普通模式中使用<code>y</code>复制<ul>
<li>普通模式中，<code>yy</code>复制游标所在的整行（<code>3yy</code>表示复制3行）</li>
<li>普通模式中，<code>y^</code> 复制至行首，或<code>y0</code>。不含光标所在处字符。</li>
<li>普通模式中，<code>y$</code> 复制至行尾。含光标所在处字符。</li>
<li>普通模式中，<code>yw</code> 复制一个单词。</li>
<li>普通模式中，<code>y2w</code> 复制两个单词。</li>
<li>普通模式中，<code>yG</code> 复制至文本末。</li>
<li>普通模式中，<code>y1G</code> 复制至文本开头。</li>
</ul>
</li>
<li>普通模式中使用 <code>p</code> 粘贴<ul>
<li>普通模式中，<code>p</code>(小写)代表粘贴至光标后（下）</li>
<li>普通模式中，<code>P</code>(大写)代表粘贴至光标前（上）</li>
</ul>
</li>
</ul>
<p><strong>剪切及粘贴</strong></p>
<p>其实前面讲得 <code>dd</code> 删除命令就是剪切，你每次 <code>dd</code> 删除文档内容后，便可以使用 <code>p</code> 来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行：</p>
<p><code>ddp</code> ,就这么简单，即实现了快速交换光标所在行与它下面的行</p>
<h2 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h2><h3 id="字符的替换及撤销-Undo操作"><a href="#字符的替换及撤销-Undo操作" class="headerlink" title="字符的替换及撤销(Undo操作)"></a>字符的替换及撤销(Undo操作)</h3><p><strong>替换和撤销(Undo)命令</strong></p>
<p>替换和Undo命令都是针对普通模式下的操作</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>r</code>+&lt;待替换字母&gt;</td>
<td>将游标所在字母替换为指定字母</td>
</tr>
<tr>
<td><code>R</code></td>
<td>连续替换，直到按下<code>Esc</code></td>
</tr>
<tr>
<td><code>cc</code></td>
<td>替换整行，即删除游标所在行，并进入插入模式</td>
</tr>
<tr>
<td><code>cw</code></td>
<td>替换一个单词，即删除一个单词，并进入插入模式</td>
</tr>
<tr>
<td><code>C</code>(大写)</td>
<td>替换游标以后至行末</td>
</tr>
<tr>
<td><code>~</code></td>
<td>反转游标所在字母大小写</td>
</tr>
<tr>
<td><code>u</code>{n}</td>
<td>撤销一次或n次操作</td>
</tr>
<tr>
<td><code>U</code>(大写)</td>
<td>撤销当前行的所有修改</td>
</tr>
<tr>
<td><code>Ctrl+r</code></td>
<td>redo，即撤销undo的操作</td>
</tr>
</tbody></table>
<h3 id="快速缩进"><a href="#快速缩进" class="headerlink" title="快速缩进"></a>快速缩进</h3><p><strong>使用命令进行快速调整缩进操作</strong></p>
<p>缩进操作均在普通模式下有效</p>
<p>打开文件进行编辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim protocols</span><br></pre></td></tr></table></figure>

<ul>
<li>普通模式下输入<code>15G</code>，跳转到15行</li>
<li>普通模式下输入<code>&gt;&gt;</code> 整行将向右缩进（使用，用于格式化代码超爽）</li>
<li>普通模式下输入<code>&lt;&lt;</code> 整行向左回退</li>
<li>普通模式下输入<code>:</code>进入命令行模式下对<code>shiftwidth</code>值进行设置可以控制缩进和回退的字符数</li>
</ul>
<p><strong>shiftwidth命令</strong></p>
<p><code>shiftwidth</code>命令是指上一节<code>&gt;&gt;</code>命令产生的缩进（可以简写成<code>sw</code>） 普通模式下输入<code>:</code>进入命令行模式下对<code>shiftwidth</code>值进行设置可以控制缩进和回退的字符数 获取目前的设定值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set shiftwidth?</span><br></pre></td></tr></table></figure>

<p>设置缩进为10个字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set shiftwidth=10</span><br></pre></td></tr></table></figure>

<p>输入 <code>ESC</code> 回到普通模式，再次尝试 <code>&gt;&gt;</code> 看缩进量是否变化</p>
<p><strong>调整文本位置</strong></p>
<p>命令行模式下输入<code>:ce</code>(center)命令使本行内容居中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:ce</span><br></pre></td></tr></table></figure>

<p>命令行模式下输入<code>:ri</code>(right)命令使本行文本靠右</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:ri</span><br></pre></td></tr></table></figure>

<p>命令行模式下输入:<code>le</code>(left)命令使本行内容靠左</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:le</span><br></pre></td></tr></table></figure>

<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>快速查找</strong></p>
<p>普通模式下输入 <code>/</code> 然后键入需要查找的字符串 按回车后就会进行查找。 <code>？</code> 与<code>/</code> 功能相同，只不过 <code>？</code> 是向上而 <code>/</code> 是向下查找。 进入查找之后，输入<code>n</code> 和 <code>N</code> 可以继续查找。 <code>n</code>是查找下一个内容,<code>N</code>查找上一个内容。</p>
<p><strong>快速查找练习</strong></p>
<p>使用 vim 打开文件进行编辑（搜索高亮需要在配置文件 <code>.vimrc</code> 中设置 <code>set hls</code> ，实验环境中已经设置好了）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim protocols</span><br></pre></td></tr></table></figure>

<ul>
<li>普通模式下输入<code>/icmp</code>然后回车即可查找字符串 <code>icmp</code></li>
<li>普通模式下输入<code>n</code>查找下一个 <code>icmp</code></li>
<li>普通模式下输入<code>？tcp</code>向上查找字符串 <code>tcp</code></li>
<li>普通模式下输入<code>N</code>查找上一个出现的 <code>tcp</code></li>
<li>命令行模式下输入 <code>noh</code> 然后回车即可取消搜索</li>
</ul>
<p><strong>高级查找</strong></p>
<ul>
<li>普通模式下输入<code>\*</code>寻找游标所在处的单词</li>
<li>普通模式下输入<code>\#</code>同上，但 <code>\#</code> 是向前（上）找，<code>\*</code>则是向后（下）找</li>
<li>普通模式下输入<code>g\*</code>同<code>\*</code> ，但部分符合该单词即可</li>
<li>普通模式下输入<code>g\#</code>同<code>\#</code> ，但部分符合该单词即可</li>
</ul>
<p>以上查找<code>n</code>,<code>N</code> 的继续查找命令依然可以用</p>
<h2 id="高级功能入门"><a href="#高级功能入门" class="headerlink" title="高级功能入门"></a>高级功能入门</h2><h3 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h3><p><strong>使用vim编辑多个文件</strong></p>
<p>编辑多个文件有两种形式，一种是在进入vim前使用的参数就是多个文件。另一种就是进入vim后再编辑其他的文件。 同时创建两个新文件并编辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim 1.txt 2.txt</span><br></pre></td></tr></table></figure>

<p>默认进入<code>1.txt</code>文件的编辑界面</p>
<ul>
<li>命令行模式下输入 <code>:n</code> 编辑 2.txt 文件，可以加 <code>!</code> 即 <code>:n!</code> 强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件</li>
<li>命令行模式下输入 <code>:N</code> 编辑 1.txt 文件，可以加 <code>!</code> 即 <code>:N!</code> 强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件</li>
</ul>
<p><strong>进入vim后打开新文件</strong></p>
<ul>
<li>命令行模式下输入<code>:e 3.txt</code> 打开新文件3.txt</li>
<li>命令行模式下输入<code>:e#</code> 回到前一个文件</li>
<li>命令行模式下输入<code>:ls</code>可以列出以前编辑过的文档</li>
<li>命令行模式下输入<code>:b 2.txt</code>（或者编号）可以直接进入文件2.txt编辑</li>
<li>命令行模式下输入<code>:bd 2.txt</code>（或者编号）可以删除以前编辑过的列表中的文件项目</li>
<li>命令行模式下输入<code>:e! 4.txt</code>，新打开文件4.txt，放弃正在编辑的文件</li>
<li>命令行模式下输入<code>:f</code> 显示正在编辑的文件名</li>
<li>命令行模式下输入<code>:f new.txt</code>，改变正在编辑的文件名字为new.txt</li>
</ul>
<p><strong>恢复文件</strong></p>
<p>如果因为断电等原因造成文档没有保存，可以采用恢复方式，<code>vim -r</code>进入文档后，输入<code>:ewcover 1.txt</code>来恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim -r 1.txt</span><br></pre></td></tr></table></figure>

<h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p><strong>可视模式命令简介</strong></p>
<ul>
<li>在普通模式下输入 <code>v</code>（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v后就会取消选取。</li>
<li>在普通模式下输入 <code>Shift+v</code>（小写），进入行选择模式，按下V之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次 <code>Shift+v</code> 就可以取消选取。</li>
<li>在普通模式下输入 <code>Ctrl+v</code>（小写），这是区域选择模式，可以进行矩形区域选择，再按一次 <code>Ctrl+v</code> 取消选取。</li>
<li>在可视模式下输入 <code>d</code> 删除选取区域内容</li>
<li>在可视模式下输入<code>y</code>复制选取区域内容</li>
</ul>
<p><strong>可视模式命令练习</strong></p>
<p>拷贝练习文件到当前目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp /etc/protocols .</span><br></pre></td></tr></table></figure>

<p>打开练习文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim protocols</span><br></pre></td></tr></table></figure>

<ul>
<li>在普通模式下<code>9G</code>跳转到第9行,输入<code>Shift+v</code>（小写V），进入可视模式进行行选择，选中5行，按下<code>&gt;&gt;</code>缩进，将5行整体缩进一个<code>shiftwidth</code></li>
<li>在普通模式下输入 <code>Ctrl+v</code>（小写V），进入可视模式进行矩形区域选择，选中第一列字符然后<code>x</code>删除整列</li>
</ul>
<h3 id="视窗操作"><a href="#视窗操作" class="headerlink" title="视窗操作"></a>视窗操作</h3><p><strong>视窗操作简介</strong></p>
<p>vim 可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为 vim 的视窗。 打开方法有很多种，例如：可以使用在命令行模式下输入 <code>:new</code> 打开一个新的 vim 视窗，并进入视窗编辑一个新文件（普通模式下输入 <code>Ctrl+w</code>也可以），除了 <code>:new</code> 命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗：</p>
<p><strong>注意：快捷键可能会与浏览器的快捷键冲突，可换为 IE 浏览器进行实验或者在浏览器设置里禁用浏览器快捷键。</strong></p>
<ul>
<li>命令行模式下输入<code>:sp 1.txt</code> 打开新的水平分屏视窗来编辑1.txt</li>
<li>命令行模式下输入<code>:vsp 2.txt</code> 打开新的垂直分屏视窗来编辑2.txt</li>
<li>普通模式下<code>Ctrl+w s</code> 将当前窗口分割成两个水平的窗口</li>
<li>普通模式下<code>Ctrl+w v</code> 将当前窗口分割成两个垂直的窗口</li>
<li>普通模式下<code>Ctrl+w q</code> 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!</li>
<li>普通模式下<code>Ctrl+w o</code> 打开一个视窗并且隐藏之前的所有视窗</li>
<li>普通模式下<code>Ctrl+w j</code> 移至下面视窗</li>
<li>普通模式下<code>Ctrl+w k</code> 移至上面视窗</li>
<li>普通模式下<code>Ctrl+w h</code> 移至左边视窗</li>
<li>普通模式下<code>Ctrl+w l</code> 移至右边视窗</li>
<li>普通模式下<code>Ctrl+w J</code> 将当前视窗移至下面</li>
<li>普通模式下<code>Ctrl+w K</code> 将当前视窗移至上面</li>
<li>普通模式下<code>Ctrl+w H</code> 将当前视窗移至左边</li>
<li>普通模式下<code>Ctrl+w L</code> 将当前视窗移至右边</li>
<li>普通模式下<code>Ctrl+w -</code> 减小视窗的高度</li>
<li>普通模式下<code>Ctrl+w +</code> 增加视窗的高度</li>
</ul>
<p><strong>视窗操作练习</strong></p>
<p>打开练习文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim 1.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>命令行模式下输入<code>:new</code> 打开一个新的vim视窗</li>
<li>命令行模式下输入<code>:vsp 2.txt</code> 打开新的横向视窗来编辑2.txt</li>
<li>命令行模式下输入<code>:vsp 3.txt</code> 打开新的横向视窗来编辑3.txt</li>
<li>如果使用非chrome浏览器可以使用<code>Ctrl+w</code>进行视窗间的跳转</li>
<li>分别在不同视窗的命令行模式下输入<code>:q!</code>退出多视窗编辑</li>
</ul>
<h3 id="文档加密"><a href="#文档加密" class="headerlink" title="文档加密"></a>文档加密</h3><p><strong>创建加密文档</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim -x file1</span><br></pre></td></tr></table></figure>

<p>输入您的密码 确认密码 这样在下一次打开时，vim就会要求你输入密码</p>
<h3 id="在vim执行外部命令"><a href="#在vim执行外部命令" class="headerlink" title="在vim执行外部命令"></a>在vim执行外部命令</h3><p>在命令行模式中输入<code>!</code>可以执行外部的shell命令</p>
<ul>
<li><code>:!ls</code> 用于显示当前目录的内容</li>
<li><code>:!rm FILENAME</code>用于删除名为 FILENAME 的文件</li>
<li><code>:w FILENAME</code>可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件</li>
</ul>
<h3 id="帮助系统"><a href="#帮助系统" class="headerlink" title="帮助系统"></a>帮助系统</h3><p> <strong>vim中的查看帮助</strong></p>
<ul>
<li>普通模式下按<code>F1</code>打开<code>vim</code>自己预设的帮助文档</li>
<li>命令行模式下输入<code>:h shiftwidth</code> 打开名为<code>shiftwidth</code>的帮助文件</li>
<li>命令行模式下输入<code>:ver</code> 显示版本及参数</li>
</ul>
<h3 id="功能设定"><a href="#功能设定" class="headerlink" title="功能设定"></a>功能设定</h3><p><strong>vim的功能设定</strong></p>
<p>可以在编辑文件的时候进行功能设定，如命令行模式下输入<code>:set nu</code>（显示行数），设定值退出vim后不会保存。要永久保存配置需要修改vim配置文件。 vim的配置文件<code>~/.vimrc</code>(实验楼环境中配置文件在/etc/vim/vimrc)，可以打开文件进行修改，不过务必小心不要影响vim正常使用</p>
<p><strong>获取目前的设定</strong></p>
<ul>
<li>命令行模式下输入<code>:set</code>或者<code>:se</code>显示所有修改过的配置</li>
<li>命令行模式下输入<code>:set all</code> 显示所有的设定值</li>
<li>命令行模式下输入<code>:set option?</code> 显示option的设定值</li>
<li>命令行模式下输入<code>:set nooption</code> 取消当前设定值</li>
</ul>
<p><strong>set功能的说明</strong></p>
<ul>
<li>命令行模式下输入<code>:set autoindent(ai)</code> 设置自动缩进</li>
<li>命令行模式下输入<code>:set autowrite(aw)</code> 设置自动存档，默认未打开</li>
<li>命令行模式下输入<code>:set background=dark</code>或<code>light</code>，设置背景风格</li>
<li>命令行模式下输入<code>:set backup(bk)</code> 设置自动备份，默认未打开</li>
<li>命令行模式下输入<code>: set cindent(cin)</code> 设置C语言风格缩进</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/25/jQuery/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SampsonKY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SampsonKY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/25/jQuery/" itemprop="url">锋利的jQuery笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-25T21:15:18+08:00">
                2019-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端学习/" itemprop="url" rel="index">
                    <span itemprop="name">前端学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="锋利的jQuery"><a href="#锋利的jQuery" class="headerlink" title="锋利的jQuery"></a>锋利的jQuery</h1><h2 id="第一章-认识jQuery"><a href="#第一章-认识jQuery" class="headerlink" title="第一章 认识jQuery"></a>第一章 认识jQuery</h2><ul>
<li><p><strong>jQuery简介优势，JavaScript的缺点</strong></p>
</li>
<li><p><strong>程序中的<code>$</code>符号是<code>jQuery</code>的一个简写</strong></p>
</li>
<li><p><strong><code>window.onload</code>与<code>$(document).ready()</code>的区别</strong></p>
</li>
<li><p><strong>jQuery代码风格</strong></p>
</li>
<li><p><strong>jQuery对象和DOM对象的介绍</strong></p>
<p>1.jQuery转换为DOM对象</p>
<p>（1）jQuery是一个类数组对象，可以通过[index]的方法得到对应的DOM对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $cr = $(<span class="string">"#cr"</span>);</span><br><span class="line"><span class="keyword">var</span> cr = $cr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>（2）这种方法是jQuery本身提供的，通过get(index)方法得到对应的DOM对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &amp;cr = $(<span class="string">"#cr"</span>);</span><br><span class="line"><span class="keyword">var</span> cr = $cr.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>2.DOM对象转成jQuery对象</p>
<p>对于一个DOM对象，只需要用$()把DOM对象包装起来，就可以获得一个jQuery对象了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cr = <span class="built_in">document</span>.getElementById(<span class="string">"cr"</span>);</span><br><span class="line"><span class="keyword">var</span> $sr = $(cr);</span><br></pre></td></tr></table></figure>

<p>【注意】：DOM对象才能使用都DOM中的方法，jQuery对象不可以使用DOM中的方法。</p>
</li>
<li><p><strong>解决jQuery和其它库的冲突</strong></p>
<ul>
<li><code>jQuery.noConflict()</code>方法</li>
<li>jQuery库在其它库之前导入</li>
<li>jQuery库在其它库之后导入</li>
</ul>
</li>
</ul>
<h2 id="第二章-jQuery选择器"><a href="#第二章-jQuery选择器" class="headerlink" title="第二章 jQuery选择器"></a>第二章 jQuery选择器</h2><ul>
<li><p>CSS的选择器</p>
</li>
<li><p>CSS选择器找到元素后是添加样式，而jQuery选择器找到元素后是添加行为；jQuery的行为准则都必须在获取到元素之后才能生效。</p>
</li>
<li><p>jQuery选择器的优势（简洁的写法、支持CSS1到CSS3的选择器、完善的处理机制）</p>
</li>
<li><p>jQuery选择器分为基本选择器、层次选择器、过滤选择器和表单选择器</p>
</li>
<li><p>基本选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>#id</td>
<td>根据给定的id匹配一个元素</td>
<td>单个元素</td>
</tr>
<tr>
<td>.class</td>
<td>根据给定的类名匹配元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>element</td>
<td>根据匹配的元素名匹配元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>*</td>
<td>匹配所有元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>selector1, selector2,…</td>
<td>将每一个选择器匹配到的元素合并后一起返回</td>
<td>集合元素</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>层次选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>$(“ancestor descendant”)</td>
<td>选取ancestor元素里的所有后代元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>$(“parent&gt;child”)</td>
<td>选取parent元素下的子元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>$(“prev+next”)</td>
<td>选取紧接在perv元素后的next元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>$(“prev~siblings”)</td>
<td>选取prev元素之后的所有siblings元素</td>
<td>集合元素</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>过滤选择器包括：基本过滤选择器，内容过滤选择器、可见性过滤选择器、属性过滤选择器、子元素过滤选择器、表单对象属性过滤选择器</p>
</li>
<li><p>基本过滤选</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>:first</td>
<td>选取第一个元素</td>
<td>单个元素</td>
</tr>
<tr>
<td>:last</td>
<td>选取最后一个元素</td>
<td>单个元素</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>去除所有与给定选择器匹配的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:even</td>
<td>选取索引是偶数的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:odd</td>
<td>选取索引是奇数的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:eq(index)</td>
<td>选取索引等于index的元素</td>
<td>单个元素</td>
</tr>
<tr>
<td>:gt(index)</td>
<td>选取索引大于index的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:lt(index)</td>
<td>选取索引小于index的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:header</td>
<td>选取所有的标题元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:animated</td>
<td>选取当前正在执行动画的所有元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:focus</td>
<td>选取当前获得焦点的元素</td>
<td>集合元素</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>内容过滤选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>:contains(text)</td>
<td>选取含有文本内容为“text”的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:empty</td>
<td>选取不包含子元素或者文本的空元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:has(selector)</td>
<td>选取含有选择器所匹配的元素的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:parent</td>
<td>选取含有子元素或者文本的元素</td>
<td>集合元素</td>
</tr>
</tbody></table>
</li>
<li><p>可见性过滤选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>:hidden</td>
<td>选取所有不可见的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:visible</td>
<td>选取所有可见的元素</td>
<td>集合元素</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>属性过滤选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>[attribute]</td>
<td>选取拥有此属性的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td>选取属性值为value的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>[attribute!=value]</td>
<td>选取属性值不等于value的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td>选取属性值以value开头的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td>value结尾</td>
<td>集合元素</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td>含有value</td>
<td>集合元素</td>
</tr>
<tr>
<td>[attribute|=value]</td>
<td>选取属性等于给定字符串或以该字符串为前缀</td>
<td>集合元素</td>
</tr>
<tr>
<td>[attribute~=value]</td>
<td>选取属性用空格分隔的值中包含一个给定值的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>[attribute1][attribute2][attributeN]</code></td>
<td>用属性选择器合并一个复合属性选择器，满足多个条件。每选择一次，缩小一次范围</td>
<td>集合元素</td>
</tr>
</tbody></table>
</li>
<li><p>子元素过滤选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>:nth-child(index/even/odd/equation)</td>
<td>选取每个父元素下的第index个子元素或者奇偶元素（下标从1开始）</td>
<td>集合元素</td>
</tr>
<tr>
<td>:first-child</td>
<td>选取每个父元素第一个子元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:last-child</td>
<td>选取每个服元素最后一个子元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:only-child</td>
<td>唯一元素</td>
<td>集合元素</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>表单对象属性过滤选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>:enabled</td>
<td>选取所有可用的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:disabled</td>
<td>选取所有不可用的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td>:checked</td>
<td>选取所有被选中的元素（单选复选框）</td>
<td>集合元素</td>
</tr>
<tr>
<td>:selected</td>
<td>选取所有被选中的选项元素（下拉元素）</td>
<td>集合元素</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>表单选择器</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>描述</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td>:input</td>
<td>选择所有的<input>、<textarea>、</textarea><select>和</select><button>元素</button></td>
<td>集合元素</td>
</tr>
<tr>
<td>:text</td>
<td>选取所有的单行文本框</td>
<td>集合元素</td>
</tr>
<tr>
<td>:passward</td>
<td>密码框</td>
<td>集合元素</td>
</tr>
<tr>
<td>:radio</td>
<td>单选框</td>
<td>集合元素</td>
</tr>
<tr>
<td>:checkbox</td>
<td>多选框</td>
<td>集合元素</td>
</tr>
<tr>
<td>:submit</td>
<td>提交按钮</td>
<td>集合元素</td>
</tr>
<tr>
<td>:image</td>
<td>图像按钮</td>
<td>集合元素</td>
</tr>
<tr>
<td>:reset</td>
<td>重置按钮</td>
<td>集合元素</td>
</tr>
<tr>
<td>:button</td>
<td>所有的按钮</td>
<td>集合元素</td>
</tr>
<tr>
<td>:file</td>
<td>所有的上传域</td>
<td>集合元素</td>
</tr>
<tr>
<td>:hidden</td>
<td>所有不可见元素</td>
<td>集合元素</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p>选择器中的一些注意事项</p>
<ul>
<li>选择器中含有“.”、“#”、“(”、或“[”等特殊字符</li>
<li>选择器的@符号问题</li>
<li>选择器中含有空格的注意事项</li>
</ul>
</li>
<li><p>其它选择器</p>
</li>
</ul>
<h2 id="第三章-jQuery中的DOM操作"><a href="#第三章-jQuery中的DOM操作" class="headerlink" title="第三章 jQuery中的DOM操作"></a>第三章 jQuery中的DOM操作</h2><ul>
<li><p><strong>DOM的分类</strong>（DOM Core、HTML-DOM、CSS-DOM)</p>
</li>
<li><p><strong>查找节点</strong></p>
<p>查找元素节点（通过选择器来完成）、查找属性节点（<strong><code>attr()</code></strong>方法来获取它的各种属性的值)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $li = $(<span class="string">"ul :eq(1)); //获取&lt;ul&gt;里面的第二个&lt;li&gt;标签</span></span><br><span class="line"><span class="string">var text = $("</span>para<span class="string">").attr("</span>title<span class="string">"); //获取属性title</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建节点</strong></p>
<p>创建元素节点（<strong>工厂模式$()</strong>）、创建文本节点、创建属性节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $li_1 = $(<span class="string">"&lt;li&gt;&lt;/li&gt;"</span>) <span class="comment">//创建了一个&lt;li&gt;元素</span></span><br><span class="line"><span class="keyword">var</span> $li_2 = $(<span class="string">"&lt;li&gt;香蕉&lt;li&gt;"</span>);  <span class="comment">//创造了一个文本节点</span></span><br><span class="line"><span class="keyword">var</span> $li_3 = $(<span class="string">"&lt;li title="</span>香蕉<span class="string">"&gt;香蕉&lt;/li&gt;"</span>)<span class="comment">//创建了一个属性节点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>插入、移动节点</strong></p>
<p><code>append()</code>,<code>appendTo()</code> ,<code>prepend()</code>,<code>prependTo()</code>,<code>after()</code>,<code>insertAfter()</code> ,<code>before()</code> ,<code>insertBefore()</code> </p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>append()</td>
<td>向每个匹配元素<strong>内部</strong>追加内容</td>
</tr>
<tr>
<td>appendTo()</td>
<td>颠倒了append()方法</td>
</tr>
<tr>
<td>prepend()</td>
<td>向每个匹配元素内部前置内容</td>
</tr>
<tr>
<td>prependTo()</td>
<td>颠倒了prepend()</td>
</tr>
<tr>
<td>after()</td>
<td>在每个匹配元素之后插入内容</td>
</tr>
<tr>
<td>insertAfter()</td>
<td>颠倒了after()</td>
</tr>
<tr>
<td>before()</td>
<td>在每个元素之前插入内容</td>
</tr>
<tr>
<td>insertBefore()</td>
<td>颠倒before()</td>
</tr>
</tbody></table>
</li>
<li><p><strong>删除节点</strong></p>
<p><code>remove()</code>方法、<code>detach()</code>方法、<code>empty()</code>方法</p>
<p>remove()方法：当某个节点用remove()方法删除后，该节点包含的所有后代节点将同时被删除。这个方法的返回值是一个指向已被删除的节点的引用，因此可以在以后再使用这些元素。</p>
<p>detach()方法：这个方法和remove()一样，也是从DOM中去除所有匹配元素，但这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素，与remove()方法不同的是，所有绑定的事件、附加的数据等都会保留下来。</p>
<p>empty()方法：严格来说empty()方法并不是删除节点，而是清空节点，它能清空元素中的所有后代节点。</p>
</li>
<li><p><strong>复制节点</strong></p>
<p><code>clone()</code>方法（注意深复制和浅复制）</p>
<p>clone(): 复制节点后，被复制的新元素并不具有任何行为。</p>
<p>clone(true): 复制元素的同时复制元素中所绑定的事件。</p>
</li>
<li><p><strong>替换节点</strong></p>
<p><code>replaceWith()</code>方法和<code>replaceAll()</code>方法</p>
<p>replaceWith()方法的作用是将所匹配的元素都替换成指定的HTML或者DOM元素。</p>
<p>replaceAll()是replaceWith()的颠倒方法。</p>
<p>如果在替换之前，已经为元素绑定事件，替换后原先绑定的事件将会与被替换的元素一起消失，需要在新元素上重新绑定新的事件。</p>
</li>
<li><p><strong>包裹节点</strong></p>
<p><code>wrap()</code>方法、<code>wrapAll()</code>方法、<code>wrapInner()</code>方法</p>
<p>将某个节点用其它标记包裹起来。</p>
<ol>
<li>wrap()</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"strong"</span>).wrap(<span class="string">"&lt;b&gt;&lt;/b&gt;"</span>); <span class="comment">//用&lt;b&gt;标签把&lt;strong&gt;元素包裹起来</span></span><br><span class="line"><span class="comment">//结果：&lt;b&gt;&lt;strong&gt;你好&lt;/strong&gt;&lt;/b&gt;</span></span><br></pre></td></tr></table></figure>

<p>   2.wrapAll()。该方法会将所有匹配的元素用一个元素包裹起来，不同于wrap()方法，wrap()方法是把所有的元素进行单独的包裹。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">html代码：</span></span><br><span class="line"><span class="comment">&lt;strong&gt;haha&lt;/strong&gt;</span></span><br><span class="line"><span class="comment">&lt;strong&gt;xixi&lt;/strong&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$(<span class="string">"strong"</span>).wrap(<span class="string">"&lt;b&gt;&lt;/b&gt;"</span>);</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//&lt;b&gt;&lt;strong&gt;haha&lt;/strong&gt;&lt;/b&gt;</span></span><br><span class="line"><span class="comment">//&lt;b&gt;&lt;strong&gt;xixi&lt;/strong&gt;&lt;/b&gt;</span></span><br><span class="line">$(<span class="string">"strong"</span>).wrapAll(<span class="string">"&lt;b&gt;&lt;/b&gt;"</span>);</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//&lt;b&gt;</span></span><br><span class="line"><span class="comment">//&lt;strong&gt;haha&lt;/strong&gt;</span></span><br><span class="line"><span class="comment">//&lt;strong&gt;xixi&lt;/strong&gt;</span></span><br><span class="line"><span class="comment">//&lt;/b&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果被包裹的多个元素间有其他元素，其他元素会被放到包裹元素之后</span></span><br></pre></td></tr></table></figure>

<p>  3.wrapInner()方法，该方法将每一个匹配的元素的子内容（包括文本节点）用其他结构化的标记包裹起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"strong"</span>).wrapInner(<span class="string">"&lt;b&gt;&lt;/b&gt;"</span>);</span><br><span class="line"><span class="comment">//&lt;strong&gt;&lt;b&gt;哈哈&lt;/b&gt;&lt;/storng&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>属性操作</strong></p>
<p>获取和设置属性（<strong><code>attr()</code>方法</strong>）、删除属性（<code>removeAttr()</code>方法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"P"</span>).attr(<span class="string">"title"</span>, <span class="string">"haha"</span>);</span><br><span class="line">$(<span class="string">"P"</span>).atrr(<span class="string">"title"</span>:<span class="string">"jaja"</span>, <span class="string">"name"</span>:<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">&amp;(<span class="string">"P"</span>).removeAttr(<span class="string">"title"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>样式操作</strong></p>
<p>获取和设置样式（<code>attr()</code>方法）、追加样式（<code>addClass()</code>方法）【注意<code>attr()</code>和<code>addClass()</code>的区别】、移除样式（<code>removeClass()</code>方法）、切换样式（<code>toggle()</code>方法和<code>toggleClass()</code>方法）、判断是否含有某个样式（<code>hasClass()</code>方法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).addClass(<span class="string">"another"</span>); <span class="comment">//给&lt;p&gt;元素追加“another”类</span></span><br><span class="line">$(<span class="string">"p"</span>).removeClass(<span class="string">"another"</span>); <span class="comment">//移除类；若不今添加参数，则将class的值全部清除</span></span><br><span class="line">$(<span class="string">"p"</span>).hasClass(<span class="string">"another"</span>);<span class="comment">//判断元素中是否含有某个类，如果有则返回true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$toggleBtn.toggle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//显示元素    代码③</span></span><br><span class="line">   &#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//隐藏元素  代码④</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*toggle()方法在此处的作用是交替执行代码③和代码④两个函数，如果元素原来是显示的，则隐藏它；反之，显示*/</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">"p"</span>).toggleClass(<span class="string">"another"</span>); <span class="comment">//重复切换类名“another"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置和获取HTML、文本和值</strong></p>
<p><code>html()</code>方法、<code>text()</code>方法、<code>val()</code>方法</p>
<p>html()：类似于JavaScript中的innerHTML属性，可以用来读取或者设置某个元素中的HTML内容。</p>
<p>text()：类似于JavaScript中的innerText属性，可以用来读取或者设置某个元素中的文本内容。</p>
<p>val()：类似于JavaScript中的value属性，可以用来设置和获取元素的值。无论是文本框、下拉列表还是单选框，它都可以返回元素的值。如果元素为多选，则返回一个包含所有选择的值的数组。</p>
</li>
<li><p><strong>遍历节点</strong></p>
<p><code>children()</code>方法、<code>next()</code>方法，<code>prev()</code>方法，<code>siblings()</code>方法、<code>closest()</code>方法、<code>parent(),parents(),closest()</code>的区别</p>
<p>children()：取得匹配元素的所有子元素集合。（只考虑子元素而不考虑其他后代元素）</p>
<p>next()：取得匹配元素后面紧邻的同辈元素。</p>
<p>prev()：取得匹配元素前面紧邻的同辈元素。</p>
<p>siblings()：取得所匹配元素前后所有的同辈元素。</p>
<p>closest()：取得最近的匹配元素，首先检查当前元素是否匹配，如果匹配则直接返回元素本身。如果不匹配则向上查找父元素，逐级向上直到找到匹配选择器的元素如果什么都没找到，则返回一个空的jQuery对象。</p>
<p>parent()：获得集合中每个元素的父级元素。</p>
<p>parents()：获得集合中每个元素的祖先元素。</p>
</li>
<li><p><strong>CSS-DOM操作</strong></p>
<p><code>css()</code>方法、<code>height()</code>方法、<code>width()</code>方法、<code>offset()</code>方法、<code>position()</code>方法、<code>scrollTop()</code>方法和<code>scrollLeft()</code>方法</p>
<p>css() : 可以直接利用css()方法设置某个元素的单个样式，也可以同时设置多个样式属性。</p>
<p>offset()：获取在当前视窗的相对偏移，其中返回的对象包含两个属性，即top和left。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> offset = $(<span class="string">"p"</span>).offset();</span><br><span class="line"><span class="keyword">var</span> left = offset.left;</span><br><span class="line"><span class="keyword">var</span> top = offset.top;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>  position()：获取元素相对于最近的一个position样式属性设置为relative或者absolute的祖父节点的相对偏移，包含两个属性，即top和left。</p>
<p>  scrollTop()和scrollLeft()方法：获取元素的滚动条距顶端的距离和距左端的距离。也可以为这两个方法指定一个参数，控制元素的滚动条滚动到指定位置。</p>
<h2 id="第四章-jQuery的事件和动画"><a href="#第四章-jQuery的事件和动画" class="headerlink" title="第四章 jQuery的事件和动画"></a>第四章 jQuery的事件和动画</h2><h3 id="jQuery中的事件"><a href="#jQuery中的事件" class="headerlink" title="jQuery中的事件"></a>jQuery中的事件</h3><ul>
<li><p><strong><code>$(document).ready()</code>方法和<code>window.onload</code>方法的异同点</strong></p>
<ul>
<li>执行时机</li>
<li>多次使用</li>
<li>间歇方式</li>
</ul>
</li>
<li><p><strong>load()方法</strong>（<code>$(window).load(function(){  })</code>）</p>
</li>
<li><p><strong>事件绑定</strong></p>
<ul>
<li>在文档装载完成后，如果打算为元素绑定事件来完成某些操作，可以使用<strong><code>bind()</code></strong>方法来对匹配元素进行特定事件的绑定。</li>
<li><code>bind()</code>方法的使用</li>
<li>与<code>ready()</code>方法一样，<code>bind()</code>方法也可以多次调用。</li>
<li>is()方法</li>
<li>简写绑定事件</li>
</ul>
</li>
<li><p><strong>合成事件</strong></p>
<ul>
<li><code>hover()</code>方法（jQuery自定义的方法，用于模拟光标悬停事件）的使用和注意事项。</li>
<li><code>toggle()</code>方法（用于模拟鼠标连续单击事件）的作用和使用。</li>
</ul>
</li>
<li><p><strong>事件冒泡</strong></p>
<ul>
<li>什么是事件冒泡以及事件冒泡引发的问题</li>
<li>事件对象（①jQuery进行了必要的扩展和封装，从而使得在任何浏览器中都能很轻松的获得事件对象以及事件对象的一些属性 ②在程序中使用事件对象只需要为函数添加一个参数③这个事件对象只有事件处理函数才能访问到。事件处理函数执行完毕后，事件对象就被销毁）</li>
<li><code>stopPropagation()</code>方法—阻止事件冒泡</li>
<li><code>preventDefault()</code>方法—阻止元素的默认行为</li>
<li>如果想同时对事件对象停止冒泡和默认行为，可以在事件处理函数中返回false。这是对在事件对象上同时调用<code>stopPropagation()</code>方法和<code>preventDefault()</code>方法的一种简写方式。</li>
<li>jQuery不支持事件捕获。</li>
</ul>
</li>
<li><p><strong>事件对象的属性</strong></p>
<ul>
<li><code>event.type</code> — 获取到事件的类型</li>
<li><code>event.stopPropagation()</code>方法 — 阻止事件冒泡</li>
<li><code>event.preventDefault()</code>方法 — 阻止默认行为</li>
<li><code>event.target</code> — 获取到触发事件的元素</li>
<li><code>event.relatedTarget</code> </li>
<li><code>event.pageX</code> 和 <code>event.pageY</code> — 获取到光标相对于页面x坐标和y坐标 </li>
<li><code>event.which</code> — 在鼠标单击事件中获取到鼠标的左、中、右键；在键盘事件中获取键盘的按键</li>
<li><code>event.metaKey</code> — 在键盘事件中获取<code>&lt;ctrl&gt;</code>键</li>
</ul>
</li>
<li><p><strong>移除事件</strong></p>
<ul>
<li>不仅可以为同一个元素绑定多个事件，也可以为多个元素绑定同一个事件。</li>
<li><code>unbind()</code>方法的使用与说明</li>
<li><code>one()</code>方法 — one()方法可以为元素绑定处理函数，当处理函数触发一次后，立即被删除。即在每个对象上，事件处理函数只会被执行一次。</li>
</ul>
</li>
<li><p><strong>模拟事件</strong></p>
<ul>
<li><p><code>trigger()</code>方法</p>
<p>①可以完成模拟操作（常用模拟）</p>
<p>②不仅能触发浏览器支持的具有相同名称的事件，也可以触发自定义的事件（触发自定义事件）</p>
<p>③该方法有两个参数，第一个参数是要触发的时间类型，第二个参数是要传递给事件处理函数的附加数据，以数组形式传递。（传递数据）</p>
<p>④<code>trigger()</code>方法触发后，会执行浏览器默认操作。（执行默认操作）</p>
<p>⑤如果只想触发事件而不想执行浏览器的默认操作，可以使用<code>triggerHandler()</code>方法。</p>
</li>
</ul>
</li>
<li><p><strong>其它用法</strong></p>
<p>前面已经介绍，<code>bind()</code>方法不仅能为元素绑定浏览器支持的具有相同名称的事件，也可以绑定自定义事件。</p>
<ul>
<li>绑定多个事件类型</li>
<li>添加事件命名空间，便于管理</li>
<li>相同事件名称，不同命名空间执行方法</li>
</ul>
</li>
</ul>
<h3 id="jQuery中的动画"><a href="#jQuery中的动画" class="headerlink" title="jQuery中的动画"></a>jQuery中的动画</h3><ul>
<li><p><code>show()</code>方法和<code>hide()</code>方法</p>
<ul>
<li>在不带参数的情况下，相当于<code>css(&quot;display&quot;, &quot;none/block/inline&quot;)</code></li>
<li>【注意】：<code>hide()</code>方法在将“内容”的display属性值设为<code>“none”</code>之前，会记住原先的display属性值。当调用<code>show()</code>方法时，就会根据<code>hide()</code>方法记住的display属性值来显示元素。</li>
<li>可以为<code>hide()</code>和<code>show()</code>方法指定一个参数，比如<code>“slow”，“normal”，“fast”</code>或数值。这样就会产生动画效果。</li>
<li><code>hide(600)</code>方法会同时减少“内容”的高度、宽度和不透明度，直至这三个属性的值都为0，最后设置该元素的CSS规则为<code>“display：none&quot;</code>；<code>show(500)</code>方法则会从上打下增加“内容”的高度，从左到右增加“内容”的宽度，同时增加“内容”的不透明度，直至内容完全显示。</li>
</ul>
</li>
<li><p><code>fadeIn()</code>方法和<code>fadeOut()</code>方法</p>
<ul>
<li>与<code>show()</code>方法不同,<code>fadeIn()</code>方法和<code>fadeOut()</code>方法只改变元素的不透明度。</li>
<li><code>fadeOut()</code>方法会在指定的一段时间内降低元素的不透明度，直到元素完全消失（”<code>display:none</code>“)。<code>fadeIn()</code>方法与之相反。</li>
</ul>
</li>
<li><p><code>slideUp()</code>方法和<code>slideDown()</code>方法</p>
<ul>
<li>这两个方法会改变元素的高度</li>
<li>如果一个元素的<code>display</code>属性值为“<code>none</code>”，当调用<code>slideDown()</code>方法时，这个元素将由上到下延伸显示。<code>slideUp()</code>与之想反。</li>
</ul>
</li>
<li><p>自定义动画方法<code>animate()</code></p>
<ul>
<li><code>animate()</code>的语法</li>
<li>自定义简单动画，累加、累减动画，多重动画（同时执行多个动画、按顺序执行多个动画），综合动画</li>
<li><code>animate()</code>方法可以用来代替其他所有的动画方法</li>
</ul>
</li>
<li><p><strong>动画回调函数</strong></p>
<ul>
<li>如果想在最后一步切换元素的样式，可以使用回调函数</li>
<li><code>css()</code>方法并不会加入到动画队列中，而是立即执行，可以使用回调函数（callback）对非动画方法实现排队。只要把<code>css()</code>方法写在最后一个动画的回调函数里即可</li>
</ul>
</li>
<li><p><strong>停止动画和判断是否处于动画状态</strong></p>
<ul>
<li><p>停止元素的动画（<code>stop()</code>方法）</p>
<p>①语法：<code>stop([clearQueue],[gotoEnd])</code>; 参数都可选，均为布尔值。<code>clearQueue</code>代表是否清空未执行完的动画队列；<code>gotoEnd</code>代表是否直接将正在执行的动画跳转到末状态。</p>
<p>②直接使用<code>stop()</code>方法，则会立即停止当前正在进行的动画，如果接下来还有动画等待继续进行，则以当前状态开始接下来的动画。</p>
</li>
<li><p>判断元素是否处于动画状态</p>
<p>在使用<code>animate()</code>方法的时候，要避免动画积累而导致的动画与用户的行为不一致。当用户快速在某个元素上执行<code>animate()</code>动画时，就会出现动画积累。解决方法是判断元素是否正处于动画状态，如果元素不处于动画状态，才为元素添加新的动画，否则不添加。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!$(element).is(<span class="string">":animated"</span>))&#123; <span class="comment">//判断元素是否处于动画状态</span></span><br><span class="line">    <span class="comment">//如果当前没有进行动画，则添加新动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>延迟动画</p>
<p>如果想对动画进行延迟操作，可以使用<code>delay()</code>方法</p>
</li>
</ul>
<ul>
<li><p><strong>其它动画方法</strong></p>
<ul>
<li><code>toggle()</code>方法 — 可以切换元素的可见状态。</li>
<li><code>slideTaggle()</code>方法 — 通过高度变化来切换匹配元素的可见性。</li>
<li><code>fadeTo()</code>方法 — 可以把元素的不透明度以渐进的方式调整到指定的值。</li>
<li><code>fadeToggle()</code>方法 — 通过不透明度变化来匹配元素的可见性。</li>
</ul>
</li>
<li><p><strong>动画队列</strong></p>
<ul>
<li>一组元素上的动画效果<ul>
<li>当在一个<code>animate()</code>方法中应用多个属性时，动画是同时发生的</li>
<li>当以链式的写法应用动画方法时，动画是按照顺序发生的（除非<code>queue</code>选项值为<code>false</code>）</li>
</ul>
</li>
<li>多组元素上的动画效果<ul>
<li>默认情况下，动画都是同时发生的</li>
<li>当以回调的形式应用动画方式的时（包括动画的回调函数和<code>queue()</code>方法的回调函数），动画是按照回调的顺序发生的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第五章-jQuery对表单、表格的操作及更多应用"><a href="#第五章-jQuery对表单、表格的操作及更多应用" class="headerlink" title="第五章 jQuery对表单、表格的操作及更多应用"></a>第五章 jQuery对表单、表格的操作及更多应用</h2><ul>
<li><p>表单应用</p>
<ul>
<li>表单的组成部分（表单标签、表单域、表单按钮）</li>
<li>单行文本框的应用</li>
<li>多行文本框的应用（高度变化、滚动条高度变化）</li>
<li>复选框应用</li>
<li>下拉框应用</li>
<li>表单验证</li>
</ul>
</li>
<li><p>表格应用</p>
<ul>
<li>表格变色（普通的隔行变色、单选框控制表格行高亮、复选框控制表格行高亮）</li>
<li>表格展开关闭</li>
<li>表格内容筛选</li>
</ul>
</li>
<li><p>其他应用</p>
<ul>
<li>网页字体大小</li>
<li>网页选项卡</li>
<li>网页换肤</li>
</ul>
</li>
</ul>
<h2 id="第六章-jQuery与Ajax的应用"><a href="#第六章-jQuery与Ajax的应用" class="headerlink" title="第六章 jQuery与Ajax的应用"></a>第六章 jQuery与Ajax的应用</h2><h3 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h3><ul>
<li>Ajax的优势和不足</li>
<li>Ajax的XMLHttpRequest对象</li>
<li>==<strong>原生JavaScript操作Ajax的步骤</strong>==</li>
</ul>
<h3 id="part-2-jQuery中的Ajax"><a href="#part-2-jQuery中的Ajax" class="headerlink" title="part 2 jQuery中的Ajax"></a><strong>part 2</strong> jQuery中的Ajax</h3><p>jQuery对Ajax操作进行了封装，在jQuery中<code>$.ajax()</code>方法属于最底层的方法，第2层是load()、<code>$.get()</code>、<code>$.post</code>方法，第3层是<code>$.getScript()</code>和<code>$.getJSON()</code>方法。</p>
<ol>
<li><p>load()方法</p>
<ul>
<li><p>载入HTML文档</p>
<p>load()方法能载入远程HTML代码并插入DOM中。</p>
<p>结构：<code>load(url [,data] [, callback])</code></p>
<p>url – 请求HTML页面的URL地址</p>
<p>data（可选） — 发送至服务器的key/value数据</p>
<p>callback（可选） — 请求完成时的回调函数，无论请求成功或失败</p>
</li>
<li><p>筛选载入的HTML文档</p>
<p>通过为URL参数指定选择符，load()方法的URL参数语法结构是“url selector”</p>
</li>
<li><p>传递方式</p>
<p>load()方法的传递方式根据参数data来自动指定。如果没有参数传递，则采用GET方式传递；反之，则会自动转换为POST方式。</p>
</li>
<li><p>回调函数</p>
<p>对于必须在加载完成后才能继续的操作，load()方法提供了回调函数（callback），该函数有3个参数，分别代表请求返回的内容、请求状态和XMLHttpRequest对象</p>
</li>
</ul>
</li>
<li><p><code>$.get()</code>方法和<code>$.post()</code>方法</p>
<p>load()方法通常用来从web服务器上获取静态的数据文件，然而这并不能体现Ajax的全部价值。在项目中，如果需要传递一些参数给服务器中的页面，那么可以使用<code>$.get()</code>或者<code>$.post()</code>方法.</p>
<p>【注意】：<code>$.get()</code>方法和<code>$.post()</code>方法是jQuery中的全局函数，而在此之前讲的jQuery方法都是对jQuery对象进行操作的。</p>
<ul>
<li><p><strong><code>$.get()</code>方法</strong></p>
<p>该方法使用GET方式来进行异步请求</p>
<p>结构：<code>$.get(url [, data] [, callback] [, type])</code></p>
<p><code>url</code> — 请求的HTML页的URL</p>
<p><code>data</code>（可选）— 发送至服务器的<code>key/value</code>数据会作为    QueryString附加到请求URL中</p>
<p><code>callback</code>（可选）— 载入成功时回调函数（只有当Response的返回状态是success才调用该方法）自动将请求结果和状态传递给该方法</p>
<p>type（可选）— 服务器返回内容的格式，包括<strong>xml, html, script, json, text</strong> 和 <strong>_default</strong></p>
<p>该方法的回调函数只有两个参数。</p>
</li>
<li><p><code>$.post()</code>方法</p>
<p><code>$.post()</code>和<code>$.get()</code>方法的结构和使用方式都相同，不过它们之间仍有一下区别：</p>
<p>①GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器。当然，在Ajax请求中，这种区别对用户是不可见的。</p>
<p>②GET方式对传输的数据有大小限制（通常不能大于2KB），而使用POST方式传递的数据量要比GET方式大得多（理论上不受限制）</p>
<p>③GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号密码等。在某种情况下，GET方式会带来严重的安全性问题，而POST方式相对来说就可以避免这些问题。</p>
<p>④GET方式和POST方式传递的数据在服务端的获取也不相同。在PHP中，GET方式可以用<code>$_GET[]</code>获取，而POST方式可以用<code>$_POST[]</code>获取。两种方式都可以通过<code>$_REQUEST[]</code>来获取</p>
</li>
</ul>
</li>
<li><p><code>$.getScript()</code>方法和<code>$.getJson()</code>方法</p>
<ul>
<li>$.getScript()`</li>
</ul>
<p>jQuery提供了<code>$.getScript()</code>方法来直接加载.js文件，与加载一个HTML片段一样简单方便，并且不需要对JavaScript文件进行处理，JavaScript文件会自动执行。    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"#send"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $.getScript(<span class="string">"test.js"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>   与其他Ajax方法一样，<code>$.getScript()</code>方法也有回调函数，他会在    JavaScript文件成功载入后运行</p>
<ul>
<li><p>$.getJSON()`</p>
<p>​         <code>$.getJSON()</code>方法用于加载JSON文件，与<code>$.getScript()</code>方法的使用方法相同。</p>
<pre><code>jQuery提供了回调函数，在回调函数里处理返回的数</code></pre></li>
<li><p>$.each()`方法</p>
<p>   <code>$.each()</code>方法不同于jQuery对象的each()方法，它是一个全局函数，不操作jQuery对象，而是以一个数组或对象作为第一个参数，以一个回调函数作为第二个参数。回调函数拥有两个参数，第一个为对象的成员或数组的索引，第二个为对应变量或内容。</p>
</li>
</ul>
<ol start="4">
<li><code>$.ajax()</code>方法</li>
</ol>
<h3 id="part-3-序列化元素"><a href="#part-3-序列化元素" class="headerlink" title="part 3 序列化元素"></a>part 3 序列化元素</h3><ol>
<li>serialize()方法</li>
<li>serializeArray()方法</li>
<li>$.param()方法</li>
</ol>
<h2 id="第九章-jQuery-Mobile"><a href="#第九章-jQuery-Mobile" class="headerlink" title="第九章 jQuery Mobile"></a>第九章 jQuery Mobile</h2><ul>
<li><p>HTML 5的简介</p>
</li>
<li><p>jQuery Mobile简介以及它的主要特性</p>
</li>
<li><p>jQuery的使用</p>
<ul>
<li>下载</li>
<li>建议在页面中使用HTML 5标准的页面声明和标签，因为移动设备浏览器对HTML 5的支持程度要远远优于PC设备</li>
<li>构建HTML模板，引入框架</li>
</ul>
</li>
<li><p><code>data-role</code>属性</p>
</li>
<li><p><code>data-inset</code>属性</p>
</li>
<li><p><code>data-theme</code>属性</p>
</li>
<li><p>其他的框架</p>
</li>
<li><p>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">data-role</span>=<span class="string">"listview"</span> <span class="attr">data-inset</span>=<span class="string">"true"</span> <span class="attr">data-theme</span>=<span class="string">"e"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Acura<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>BMW<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/前端知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SampsonKY">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SampsonKY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/前端知识点/" itemprop="url">前端知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-24T17:27:24+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端学习/" itemprop="url" rel="index">
                    <span itemprop="name">前端学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前端知识点"><a href="#前端知识点" class="headerlink" title="前端知识点"></a>前端知识点</h1><h2 id="HTML-amp-amp-CSS"><a href="#HTML-amp-amp-CSS" class="headerlink" title="HTML&amp;&amp;CSS"></a>HTML&amp;&amp;CSS</h2><ul>
<li>01.html5的SEO优化</li>
<li>02.有趣的空格</li>
<li>03.Html和xhtml的区别</li>
<li>04.盒子模型</li>
<li>[05.css sprite](./HTML/04.CSS Sprite)</li>
<li>06.position属性值absolute和relative的区别</li>
<li>07.css选择器</li>
<li>08.css兼容性问题</li>
<li>09.css响应式布局</li>
<li>10.css3实现圆角</li>
<li>11.css3实现至下而上的弹框</li>
<li>12.px、em、rem的区别</li>
<li>13.css盒子模型、bfc</li>
<li>14.元素的水平垂直居中方法</li>
<li>15.Css 渐变</li>
<li>16.display:none和visibility:hidden</li>
<li>17.css优化</li>
<li>18.link和@import区别</li>
<li>[19.描述z index和层叠上下文](./CSS/24.描述z index和层叠上下文)</li>
<li>20.css动画与js动画比较</li>
<li>21.负margin的使用</li>
<li>[22.有趣的h5api：page visibility api](./HTML/05.有趣的h5api：page visibility api)</li>
<li>23.placeholder的使用及其兼容方法</li>
<li>[24.响应式图片 srcset和 picture 的使用](./HTML/响应式图片 srcset和 picture 的使用)</li>
<li>25.display的值与其用法</li>
<li>[26.em rem px 区别](./CSS/26.px em rem 区别)</li>
<li>[27.flex 布局](./HTML/20.flex 布局)</li>
<li>[28.grid 布局](./HTML/grid 布局)</li>
<li>29.伪类</li>
<li>30.页面适配</li>
<li>31.伪元素</li>
</ul>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul>
<li>03.es5在es3上增加的内容</li>
<li>04.es6中的promise解决异步编程</li>
<li>[06.DOM Ready](./js/06.dom ready)</li>
<li>07.js简单动画</li>
<li>08.js基本数据类型和引用类型</li>
<li>09.js获取元素节点的方法</li>
<li>10.如何判断两个对象相等</li>
<li>11.原生js实现jq的事件绑定</li>
<li>[12.原生js实现jq的on,attr方法](./js/12.原生js实现jquery的on, attr方法)</li>
<li>[13.js实现链表](./js/13. js实现链表)</li>
<li>14.事件委托&amp;&amp;事件流&amp;&amp;事件处理</li>
<li>16.事件模型</li>
<li>17.如何用js实现图片轮播</li>
<li>18.DOM优化</li>
<li>19.js面向对象的三大特征</li>
<li>20.js对象的创建方法</li>
<li>21.如何实现深拷贝</li>
<li>22.js对象</li>
<li>23.js如何实现私有</li>
<li>25.js实现div拖拽</li>
<li>26.js在方法的实例对象上修改方法原型上的属性和方法</li>
<li>28.倒计时实现、计时器延迟问题和效率</li>
<li>[29.in的奇妙应用](./js/29. in 的奇妙应用)</li>
<li>30.匿名函数</li>
<li>31.如何实现千位分隔符</li>
<li>32.理解js的闭包</li>
<li>33.半透明图片移上去不透明及对鼠标快速移入移出的处理</li>
<li>34.执行环境与作用域</li>
<li>35.重载</li>
<li><a href="./js/38.this的指向即特殊情况&call()和apply()的区别">38.this的指向即特殊情况&amp;call()和apply()的区别</a></li>
<li>41.let与var的区别</li>
<li>42.移动端适配</li>
<li>43.注册重复问题</li>
<li>44.海量数据处理问题</li>
<li>[48.异步加载](./js/48. 异步加载)</li>
<li>50.有关变量声明提升的有意思的代码</li>
<li>51.移动端300ms点击延迟</li>
<li>52.箭头函数和普通函数的区别</li>
<li>53.原型链</li>
<li>54.JS垃圾回收机制</li>
<li>56.什么是伪数组和如何将伪数组转化为数组</li>
<li>57.深入理解定时器：setTimeout与setInterval</li>
<li>58.网站性能优化</li>
<li>59.Domcontentloaded和load</li>
<li>60.执行上下文</li>
<li>61.详解HTTPS和HTTP</li>
<li>62.querySelector与getElementBy系列方法区别</li>
<li>63.call与apply的区别</li>
<li>64.Js和jq获取元素位置</li>
<li>[65.ARRAY 常用方法](./js/ARRAY 常用方法)</li>
<li>66.函数防抖</li>
<li>67.函数节流</li>
<li>68.new与create的区别</li>
<li>69.Jsonp原理</li>
<li>[70.cookie 和 session的区别](./js/70.cookie 和 session的区别)</li>
<li>80.模块化</li>
<li>81.匿名函数的使用实例</li>
<li>[82.string常用方法](./js/string 常用方法)</li>
<li>83.预解析</li>
<li>84.null与undefined的区别</li>
<li>85.ES6新增的数组构造器</li>
<li>86.深入理解动态作用域和词法作用域</li>
<li>87.变量提升</li>
<li>88.柯里化</li>
<li>89.浅克隆</li>
<li>90.深克隆</li>
<li>91.js的运行机制</li>
<li>92.工厂模式</li>
<li>93.简述BOM对象</li>
<li>94.ajax</li>
<li>95.void（0）</li>
<li>96.原生实现排序算法</li>
<li>97.HTTP状态码</li>
<li>98.抽象工厂模式</li>
<li>[99.Map、FlatMap 和 Reduce](./js/Map、FlatMap 和 Reduce)</li>
<li>[100.Generator 实现](./js/Generator 实现)</li>
<li>101.0.30000000000000004</li>
<li>102.模拟jq的链模式</li>
<li>103.箭头函数的this</li>
<li>104.类数组对象</li>
<li>105.执行上下文</li>
<li>106.cors</li>
<li>107.如何遍历数组</li>
<li>108.Promise实现</li>
<li>109.Proxy实现</li>
<li>110.GET与POST的区别</li>
<li>111.ES6模块与CommonJS的差异</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="SampsonKY">
            
              <p class="site-author-name" itemprop="name">SampsonKY</p>
              <p class="site-description motion-element" itemprop="description">Dreams are destined to be lonely, and there is no doubt and ridicule on the road, but what about it, even if it is bruised and bruised, it must live beautifully.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/SampsonKY" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:theonekangyong@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SampsonKY</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
