<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SampsonKY&#39;blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-11T07:02:32.090Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SampsonKY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端知识点</title>
    <link href="http://yoursite.com/2020/03/11/vim/"/>
    <id>http://yoursite.com/2020/03/11/vim/</id>
    <published>2020-03-11T07:02:00.379Z</published>
    <updated>2020-03-11T07:02:32.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><h2 id="Vim快速入门"><a href="#Vim快速入门" class="headerlink" title="Vim快速入门"></a>Vim快速入门</h2><h3 id="Vim模式简介"><a href="#Vim模式简介" class="headerlink" title="Vim模式简介"></a>Vim模式简介</h3><blockquote><p>从vi衍生出来的Vim具有多种模式，这种独特的设计容易使初学者产生混淆。几乎所有的编辑器都会有<em>插入</em>和<em>执行</em>命令两种模式，并且大多数的编辑器使用了与Vim截然不同的方式：命令目录（鼠标或者键盘驱动），组合键（通常通过control键（CTRL）和alt键（ALT）组成）或者鼠标输入。Vim和vi一样，仅仅通过键盘来在这些模式之中切换。这就使得Vim可以不用进行菜单或者鼠标操作，并且最小化组合键的操作。对文字录入员或者程序员可以大大增强速度和效率。</p></blockquote><p>Vim具有6种基本模式和5种派生模式，我们这里只简单介绍下6种基本模式：</p><ul><li>普通模式(Normal mode)</li></ul><blockquote><p>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。</p></blockquote><blockquote><p>Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令<code>dd</code>删除当前行，但是第一个”d”的后面可以跟另外的移动命令来代替第二个<code>d</code>，比如用移动到下一行的”j”键就可以删除当前行和下一行。另外还可以指定命令重复次数，<code>2dd</code>（重复<code>dd</code>两次），和<code>dj</code>的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效地进行文本编辑。</p></blockquote><blockquote><p>在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按<code>a</code>（append／追加）键或者<code>i</code>（insert／插入）键。</p></blockquote><ul><li>插入模式(Insert mode)</li></ul><blockquote><p>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。</p></blockquote><blockquote><p>在插入模式中，可以按<code>ESC</code>键回到普通模式。</p></blockquote><ul><li>可视模式(Visual mode)</li></ul><blockquote><p>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的”文本对象”也能和移动命令一样用在这个模式中。</p></blockquote><ul><li>选择模式(Select mode)</li></ul><blockquote><p>这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p></blockquote><ul><li>命令行模式(Command line mode)</li></ul><blockquote><p>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（<code>:</code>键），搜索（<code>/</code>和<code>?</code>键）或者过滤命令（<code>!</code>键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</p></blockquote><ul><li>Ex模式(Ex mode)</li></ul><blockquote><p>这和命令行模式比较相似，在使用<code>:visual</code>命令离开Ex模式前，可以一次执行多条命令。</p></blockquote><blockquote><p>这其中我们常用到就是普通模式、插入模式和命令行模式，本课程也只涉及这三个常用模式的内容</p></blockquote><h3 id="进入vim"><a href="#进入vim" class="headerlink" title="进入vim"></a>进入vim</h3><p><strong>使用vim命令进入vim界面</strong></p><p>vim后面加上你要打开的已存在的文件名或者不存在（则作为新建文件）的文件名。 打开Xfce终端，输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim practice_1.txt</span><br></pre></td></tr></table></figure><p>直接使用vim也可以打开vim编辑器，但是不会打开任何文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim</span><br></pre></td></tr></table></figure><p>进入命令行模式后输入<code>:e 文件路径</code> 同样可以打开相应文件。</p><p><strong>游标移动</strong></p><p>在进入vim后，按下<code>i</code>键进入插入模式。在该模式下您可以输入文本信息.</p><p>按<code>Esc</code>进入普通模式，在该模式下使用方向键或者<code>h</code>,<code>j</code>,<code>k</code>,<code>l</code>键可以移动游标。</p><table><thead><tr><th>按键</th><th>说明</th></tr></thead><tbody><tr><td><code>h</code></td><td>左</td></tr><tr><td><code>l</code></td><td>右（小写L）</td></tr><tr><td><code>j</code></td><td>下</td></tr><tr><td><code>k</code></td><td>上</td></tr><tr><td><code>w</code></td><td>移动到下一个单词</td></tr></tbody></table><h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h3><p>在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>在当前光标处进行编辑</td></tr><tr><td><code>I</code></td><td>在行首插入</td></tr><tr><td><code>A</code></td><td>在行末插入</td></tr><tr><td><code>a</code></td><td>在光标后插入编辑</td></tr><tr><td><code>o</code></td><td>在当前行后插入一个新行</td></tr><tr><td><code>O</code></td><td>在当前行前插入一个新行</td></tr><tr><td><code>cw</code></td><td>替换从光标所在位置后到一个单词结尾的字符</td></tr></tbody></table><h3 id="保存文档"><a href="#保存文档" class="headerlink" title="保存文档"></a>保存文档</h3><p><strong>命令行模式下保存文档</strong></p><p>从普通模式输入<code>:</code>进入命令行模式，输入<code>w</code>回车，保存文档。输入<code>:w 文件名</code>可以将文档另存为其他文件名或存到其它路径下</p><h3 id="退出vim"><a href="#退出vim" class="headerlink" title="退出vim"></a>退出vim</h3><p><strong>命令行模式下退出vim</strong></p><p>从普通模式输入<code>:</code>进入命令行模式，输入<code>wq</code>回车，保存并退出编辑</p><p>以下为其它几种退出方式：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:q!</code></td><td>强制退出，不保存</td></tr><tr><td><code>:q</code></td><td>退出</td></tr><tr><td><code>:wq!</code></td><td>强制保存并退出</td></tr><tr><td><code>:w &lt;文件路径&gt;</code></td><td>另存为</td></tr><tr><td><code>:saveas 文件路径</code></td><td>另存为</td></tr><tr><td><code>:x</code></td><td>保存并退出</td></tr><tr><td><code>:wq</code></td><td>保存并退出</td></tr></tbody></table><p><strong>普通模式下退出vim</strong></p><p>普通模式下输入<code>Shift+zz</code>即可保存退出vim</p><h3 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h3><p><strong>普通模式下删除vim文本信息</strong></p><p>进入普通模式，使用下列命令可以进行文本快速删除：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>x</code></td><td>删除游标所在的字符</td></tr><tr><td><code>X</code></td><td>删除游标所在前一个字符</td></tr><tr><td><code>Delete</code></td><td>同<code>x</code></td></tr><tr><td><code>dd</code></td><td>删除整行</td></tr><tr><td><code>dw</code></td><td>删除一个单词（不适用中文）</td></tr><tr><td><code>d$</code>或<code>D</code></td><td>删除至行尾</td></tr><tr><td><code>d^</code></td><td>删除至行首</td></tr><tr><td><code>dG</code></td><td>删除到文档结尾处</td></tr><tr><td><code>d1G</code></td><td>删至文档首部</td></tr></tbody></table><p>除此之外，你还可以在命令之前加上数字，表示一次删除多行，如：</p><p><code>2dd</code>表示一次删除2行</p><h2 id="Vim-文档编辑"><a href="#Vim-文档编辑" class="headerlink" title="Vim 文档编辑"></a>Vim 文档编辑</h2><h3 id="Vim重复命令"><a href="#Vim重复命令" class="headerlink" title="Vim重复命令"></a>Vim重复命令</h3><p><strong>重复执行上次命令</strong></p><p>在普通模式下<code>.</code>(小数点)表示重复上一次的命令操作</p><p>比如：普通模式下输入<code>x</code>，删除第一个字符，输入<code>.</code>(小数点)会再次删除一个字符，除此之外也可以重复<code>dd</code>的删除操作</p><p><strong>执行指令次数相同的命令</strong></p><p>进入普通模式输入<code>N</code>，N 表示重复后面的次数，下面来练习：</p><p>比如：</p><ul><li>输入<code>10x</code>，删除10个连续字符</li><li>输入<code>3dd</code>，将会删除3行文本</li></ul><p>在普通模式下，你还可以使用<code>dw</code>或者<code>daw</code>(delete a word)删除一个单词，所以你可以很容易的联想到<code>dnw</code>(<strong>n替换为相应数字</strong>) 表示删除n个单词</p><h3 id="游标快速跳转"><a href="#游标快速跳转" class="headerlink" title="游标快速跳转"></a>游标快速跳转</h3><p>普通模式下，下列命令可以让光标快速调转到指定位置，我们分别讨论快速实现<strong>行间</strong>跳转和<strong>行内</strong>跳转</p><p><strong>行间跳转</strong></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>nG</code>(n Shift+g)</td><td>游标移动到第 n 行<strong>(如果默认没有显示行号，请先进入命令模式，输入<code>:set nu</code>以显示行号)</strong></td></tr><tr><td><code>gg</code></td><td>游标移动到到第一行</td></tr><tr><td><code>G</code>(Shift+g)</td><td>到最后一行</td></tr></tbody></table><p><strong>小技巧：你在完成依次跳转后，可以使用 <code>Ctrl+o</code> 快速回到上一次(跳转前)光标所在位置</strong>,这个技巧很实用，比如当你在写代码时，忽然想起有个 bug，需要修改，这时候你跳过去改好了，只需要按下 <code>Ctrl+o</code> 就可以回到你之前的位置。vim 中会用很多类似的小技巧就等着你去发掘。</p><p><strong>行内跳转</strong></p><p>普通模式下使用下列命令在行内按照单词为单位进行跳转</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>w</code></td><td>到下一个单词的开头</td></tr><tr><td><code>e</code></td><td>到当前单词的结尾</td></tr><tr><td><code>b</code></td><td>到前一个单词的开头</td></tr><tr><td><code>ge</code></td><td>到前一个单词的结尾</td></tr><tr><td><code>0</code>或<code>^</code></td><td>到行头</td></tr><tr><td><code>$</code></td><td>到行尾</td></tr><tr><td><code>f&lt;字母&gt;</code></td><td>向后搜索&lt;字母&gt;并跳转到第一个匹配的位置(非常实用)</td></tr><tr><td><code>F&lt;字母&gt;</code></td><td>向前搜索&lt;字母&gt;并跳转到第一个匹配的位置</td></tr><tr><td><code>t&lt;字母&gt;</code></td><td>向后搜索&lt;字母&gt;并跳转到第一个匹配位置之前的一个字母(不常用)</td></tr><tr><td><code>T&lt;字母&gt;</code></td><td>向前搜索&lt;字母&gt;并跳转到第一个匹配位置之后的一个字母(不常用)</td></tr></tbody></table><p>操作练习：</p><ul><li>在普通模式下，任意跳转到一行，使用 <code>w</code> 跳转到一个单词的开头，然后使用 <code>dw</code> 删除这个单词</li><li>在普通模式下，使用 <code>e</code> 跳转到一个单词的结尾，并使用 <code>~</code> 将游标所在字母变成大写或小写</li></ul><h3 id="复制粘贴和剪切"><a href="#复制粘贴和剪切" class="headerlink" title="复制粘贴和剪切"></a>复制粘贴和剪切</h3><p><strong>复制及粘贴文本</strong></p><ul><li>普通模式中使用<code>y</code>复制<ul><li>普通模式中，<code>yy</code>复制游标所在的整行（<code>3yy</code>表示复制3行）</li><li>普通模式中，<code>y^</code> 复制至行首，或<code>y0</code>。不含光标所在处字符。</li><li>普通模式中，<code>y$</code> 复制至行尾。含光标所在处字符。</li><li>普通模式中，<code>yw</code> 复制一个单词。</li><li>普通模式中，<code>y2w</code> 复制两个单词。</li><li>普通模式中，<code>yG</code> 复制至文本末。</li><li>普通模式中，<code>y1G</code> 复制至文本开头。</li></ul></li><li>普通模式中使用 <code>p</code> 粘贴<ul><li>普通模式中，<code>p</code>(小写)代表粘贴至光标后（下）</li><li>普通模式中，<code>P</code>(大写)代表粘贴至光标前（上）</li></ul></li></ul><p><strong>剪切及粘贴</strong></p><p>其实前面讲得 <code>dd</code> 删除命令就是剪切，你每次 <code>dd</code> 删除文档内容后，便可以使用 <code>p</code> 来粘贴，也这一点可以让我们实现一个很爽快的功能——交换上下行：</p><p><code>ddp</code> ,就这么简单，即实现了快速交换光标所在行与它下面的行</p><h2 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h2><h3 id="字符的替换及撤销-Undo操作"><a href="#字符的替换及撤销-Undo操作" class="headerlink" title="字符的替换及撤销(Undo操作)"></a>字符的替换及撤销(Undo操作)</h3><p><strong>替换和撤销(Undo)命令</strong></p><p>替换和Undo命令都是针对普通模式下的操作</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>r</code>+&lt;待替换字母&gt;</td><td>将游标所在字母替换为指定字母</td></tr><tr><td><code>R</code></td><td>连续替换，直到按下<code>Esc</code></td></tr><tr><td><code>cc</code></td><td>替换整行，即删除游标所在行，并进入插入模式</td></tr><tr><td><code>cw</code></td><td>替换一个单词，即删除一个单词，并进入插入模式</td></tr><tr><td><code>C</code>(大写)</td><td>替换游标以后至行末</td></tr><tr><td><code>~</code></td><td>反转游标所在字母大小写</td></tr><tr><td><code>u</code>{n}</td><td>撤销一次或n次操作</td></tr><tr><td><code>U</code>(大写)</td><td>撤销当前行的所有修改</td></tr><tr><td><code>Ctrl+r</code></td><td>redo，即撤销undo的操作</td></tr></tbody></table><h3 id="快速缩进"><a href="#快速缩进" class="headerlink" title="快速缩进"></a>快速缩进</h3><p><strong>使用命令进行快速调整缩进操作</strong></p><p>缩进操作均在普通模式下有效</p><p>打开文件进行编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim protocols</span><br></pre></td></tr></table></figure><ul><li>普通模式下输入<code>15G</code>，跳转到15行</li><li>普通模式下输入<code>&gt;&gt;</code> 整行将向右缩进（使用，用于格式化代码超爽）</li><li>普通模式下输入<code>&lt;&lt;</code> 整行向左回退</li><li>普通模式下输入<code>:</code>进入命令行模式下对<code>shiftwidth</code>值进行设置可以控制缩进和回退的字符数</li></ul><p><strong>shiftwidth命令</strong></p><p><code>shiftwidth</code>命令是指上一节<code>&gt;&gt;</code>命令产生的缩进（可以简写成<code>sw</code>） 普通模式下输入<code>:</code>进入命令行模式下对<code>shiftwidth</code>值进行设置可以控制缩进和回退的字符数 获取目前的设定值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set shiftwidth?</span><br></pre></td></tr></table></figure><p>设置缩进为10个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set shiftwidth=10</span><br></pre></td></tr></table></figure><p>输入 <code>ESC</code> 回到普通模式，再次尝试 <code>&gt;&gt;</code> 看缩进量是否变化</p><p><strong>调整文本位置</strong></p><p>命令行模式下输入<code>:ce</code>(center)命令使本行内容居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:ce</span><br></pre></td></tr></table></figure><p>命令行模式下输入<code>:ri</code>(right)命令使本行文本靠右</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:ri</span><br></pre></td></tr></table></figure><p>命令行模式下输入:<code>le</code>(left)命令使本行内容靠左</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:le</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>快速查找</strong></p><p>普通模式下输入 <code>/</code> 然后键入需要查找的字符串 按回车后就会进行查找。 <code>？</code> 与<code>/</code> 功能相同，只不过 <code>？</code> 是向上而 <code>/</code> 是向下查找。 进入查找之后，输入<code>n</code> 和 <code>N</code> 可以继续查找。 <code>n</code>是查找下一个内容,<code>N</code>查找上一个内容。</p><p><strong>快速查找练习</strong></p><p>使用 vim 打开文件进行编辑（搜索高亮需要在配置文件 <code>.vimrc</code> 中设置 <code>set hls</code> ，实验环境中已经设置好了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim protocols</span><br></pre></td></tr></table></figure><ul><li>普通模式下输入<code>/icmp</code>然后回车即可查找字符串 <code>icmp</code></li><li>普通模式下输入<code>n</code>查找下一个 <code>icmp</code></li><li>普通模式下输入<code>？tcp</code>向上查找字符串 <code>tcp</code></li><li>普通模式下输入<code>N</code>查找上一个出现的 <code>tcp</code></li><li>命令行模式下输入 <code>noh</code> 然后回车即可取消搜索</li></ul><p><strong>高级查找</strong></p><ul><li>普通模式下输入<code>\*</code>寻找游标所在处的单词</li><li>普通模式下输入<code>\#</code>同上，但 <code>\#</code> 是向前（上）找，<code>\*</code>则是向后（下）找</li><li>普通模式下输入<code>g\*</code>同<code>\*</code> ，但部分符合该单词即可</li><li>普通模式下输入<code>g\#</code>同<code>\#</code> ，但部分符合该单词即可</li></ul><p>以上查找<code>n</code>,<code>N</code> 的继续查找命令依然可以用</p><h2 id="高级功能入门"><a href="#高级功能入门" class="headerlink" title="高级功能入门"></a>高级功能入门</h2><h3 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h3><p><strong>使用vim编辑多个文件</strong></p><p>编辑多个文件有两种形式，一种是在进入vim前使用的参数就是多个文件。另一种就是进入vim后再编辑其他的文件。 同时创建两个新文件并编辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim 1.txt 2.txt</span><br></pre></td></tr></table></figure><p>默认进入<code>1.txt</code>文件的编辑界面</p><ul><li>命令行模式下输入 <code>:n</code> 编辑 2.txt 文件，可以加 <code>!</code> 即 <code>:n!</code> 强制切换，之前一个文件的输入没有保存，仅仅切换到另一个文件</li><li>命令行模式下输入 <code>:N</code> 编辑 1.txt 文件，可以加 <code>!</code> 即 <code>:N!</code> 强制切换，之前文件内的输入没有保存，仅仅是切换到另一个文件</li></ul><p><strong>进入vim后打开新文件</strong></p><ul><li>命令行模式下输入<code>:e 3.txt</code> 打开新文件3.txt</li><li>命令行模式下输入<code>:e#</code> 回到前一个文件</li><li>命令行模式下输入<code>:ls</code>可以列出以前编辑过的文档</li><li>命令行模式下输入<code>:b 2.txt</code>（或者编号）可以直接进入文件2.txt编辑</li><li>命令行模式下输入<code>:bd 2.txt</code>（或者编号）可以删除以前编辑过的列表中的文件项目</li><li>命令行模式下输入<code>:e! 4.txt</code>，新打开文件4.txt，放弃正在编辑的文件</li><li>命令行模式下输入<code>:f</code> 显示正在编辑的文件名</li><li>命令行模式下输入<code>:f new.txt</code>，改变正在编辑的文件名字为new.txt</li></ul><p><strong>恢复文件</strong></p><p>如果因为断电等原因造成文档没有保存，可以采用恢复方式，<code>vim -r</code>进入文档后，输入<code>:ewcover 1.txt</code>来恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim -r 1.txt</span><br></pre></td></tr></table></figure><h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p><strong>可视模式命令简介</strong></p><ul><li>在普通模式下输入 <code>v</code>（小写），进入字符选择模式，就可以移动光标，光标走过的地方就会选取。再次按下v后就会取消选取。</li><li>在普通模式下输入 <code>Shift+v</code>（小写），进入行选择模式，按下V之后就会把整行选取，您可以上下移动光标选更多的行，同样，再按一次 <code>Shift+v</code> 就可以取消选取。</li><li>在普通模式下输入 <code>Ctrl+v</code>（小写），这是区域选择模式，可以进行矩形区域选择，再按一次 <code>Ctrl+v</code> 取消选取。</li><li>在可视模式下输入 <code>d</code> 删除选取区域内容</li><li>在可视模式下输入<code>y</code>复制选取区域内容</li></ul><p><strong>可视模式命令练习</strong></p><p>拷贝练习文件到当前目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp /etc/protocols .</span><br></pre></td></tr></table></figure><p>打开练习文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim protocols</span><br></pre></td></tr></table></figure><ul><li>在普通模式下<code>9G</code>跳转到第9行,输入<code>Shift+v</code>（小写V），进入可视模式进行行选择，选中5行，按下<code>&gt;&gt;</code>缩进，将5行整体缩进一个<code>shiftwidth</code></li><li>在普通模式下输入 <code>Ctrl+v</code>（小写V），进入可视模式进行矩形区域选择，选中第一列字符然后<code>x</code>删除整列</li></ul><h3 id="视窗操作"><a href="#视窗操作" class="headerlink" title="视窗操作"></a>视窗操作</h3><p><strong>视窗操作简介</strong></p><p>vim 可以在一个界面里打开多个窗口进行编辑，这些编辑窗口称为 vim 的视窗。 打开方法有很多种，例如：可以使用在命令行模式下输入 <code>:new</code> 打开一个新的 vim 视窗，并进入视窗编辑一个新文件（普通模式下输入 <code>Ctrl+w</code>也可以），除了 <code>:new</code> 命令，下述列举的多种方法也可以在命令模式或普通模式下打开新的视窗：</p><p><strong>注意：快捷键可能会与浏览器的快捷键冲突，可换为 IE 浏览器进行实验或者在浏览器设置里禁用浏览器快捷键。</strong></p><ul><li>命令行模式下输入<code>:sp 1.txt</code> 打开新的水平分屏视窗来编辑1.txt</li><li>命令行模式下输入<code>:vsp 2.txt</code> 打开新的垂直分屏视窗来编辑2.txt</li><li>普通模式下<code>Ctrl+w s</code> 将当前窗口分割成两个水平的窗口</li><li>普通模式下<code>Ctrl+w v</code> 将当前窗口分割成两个垂直的窗口</li><li>普通模式下<code>Ctrl+w q</code> 即 :q 结束分割出来的视窗。如果在新视窗中有输入需要使用强制符！即:q!</li><li>普通模式下<code>Ctrl+w o</code> 打开一个视窗并且隐藏之前的所有视窗</li><li>普通模式下<code>Ctrl+w j</code> 移至下面视窗</li><li>普通模式下<code>Ctrl+w k</code> 移至上面视窗</li><li>普通模式下<code>Ctrl+w h</code> 移至左边视窗</li><li>普通模式下<code>Ctrl+w l</code> 移至右边视窗</li><li>普通模式下<code>Ctrl+w J</code> 将当前视窗移至下面</li><li>普通模式下<code>Ctrl+w K</code> 将当前视窗移至上面</li><li>普通模式下<code>Ctrl+w H</code> 将当前视窗移至左边</li><li>普通模式下<code>Ctrl+w L</code> 将当前视窗移至右边</li><li>普通模式下<code>Ctrl+w -</code> 减小视窗的高度</li><li>普通模式下<code>Ctrl+w +</code> 增加视窗的高度</li></ul><p><strong>视窗操作练习</strong></p><p>打开练习文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim 1.txt</span><br></pre></td></tr></table></figure><ul><li>命令行模式下输入<code>:new</code> 打开一个新的vim视窗</li><li>命令行模式下输入<code>:vsp 2.txt</code> 打开新的横向视窗来编辑2.txt</li><li>命令行模式下输入<code>:vsp 3.txt</code> 打开新的横向视窗来编辑3.txt</li><li>如果使用非chrome浏览器可以使用<code>Ctrl+w</code>进行视窗间的跳转</li><li>分别在不同视窗的命令行模式下输入<code>:q!</code>退出多视窗编辑</li></ul><h3 id="文档加密"><a href="#文档加密" class="headerlink" title="文档加密"></a>文档加密</h3><p><strong>创建加密文档</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim -x file1</span><br></pre></td></tr></table></figure><p>输入您的密码 确认密码 这样在下一次打开时，vim就会要求你输入密码</p><h3 id="在vim执行外部命令"><a href="#在vim执行外部命令" class="headerlink" title="在vim执行外部命令"></a>在vim执行外部命令</h3><p>在命令行模式中输入<code>!</code>可以执行外部的shell命令</p><ul><li><code>:!ls</code> 用于显示当前目录的内容</li><li><code>:!rm FILENAME</code>用于删除名为 FILENAME 的文件</li><li><code>:w FILENAME</code>可将当前 VIM 中正在编辑的文件另存为 FILENAME 文件</li></ul><h3 id="帮助系统"><a href="#帮助系统" class="headerlink" title="帮助系统"></a>帮助系统</h3><p> <strong>vim中的查看帮助</strong></p><ul><li>普通模式下按<code>F1</code>打开<code>vim</code>自己预设的帮助文档</li><li>命令行模式下输入<code>:h shiftwidth</code> 打开名为<code>shiftwidth</code>的帮助文件</li><li>命令行模式下输入<code>:ver</code> 显示版本及参数</li></ul><h3 id="功能设定"><a href="#功能设定" class="headerlink" title="功能设定"></a>功能设定</h3><p><strong>vim的功能设定</strong></p><p>可以在编辑文件的时候进行功能设定，如命令行模式下输入<code>:set nu</code>（显示行数），设定值退出vim后不会保存。要永久保存配置需要修改vim配置文件。 vim的配置文件<code>~/.vimrc</code>(实验楼环境中配置文件在/etc/vim/vimrc)，可以打开文件进行修改，不过务必小心不要影响vim正常使用</p><p><strong>获取目前的设定</strong></p><ul><li>命令行模式下输入<code>:set</code>或者<code>:se</code>显示所有修改过的配置</li><li>命令行模式下输入<code>:set all</code> 显示所有的设定值</li><li>命令行模式下输入<code>:set option?</code> 显示option的设定值</li><li>命令行模式下输入<code>:set nooption</code> 取消当前设定值</li></ul><p><strong>set功能的说明</strong></p><ul><li>命令行模式下输入<code>:set autoindent(ai)</code> 设置自动缩进</li><li>命令行模式下输入<code>:set autowrite(aw)</code> 设置自动存档，默认未打开</li><li>命令行模式下输入<code>:set background=dark</code>或<code>light</code>，设置背景风格</li><li>命令行模式下输入<code>:set backup(bk)</code> 设置自动备份，默认未打开</li><li>命令行模式下输入<code>: set cindent(cin)</code> 设置C语言风格缩进</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VIM&quot;&gt;&lt;a href=&quot;#VIM&quot; class=&quot;headerlink&quot; title=&quot;VIM&quot;&gt;&lt;/a&gt;VIM&lt;/h1&gt;&lt;h2 id=&quot;Vim快速入门&quot;&gt;&lt;a href=&quot;#Vim快速入门&quot; class=&quot;headerlink&quot; title=&quot;Vim快速入门
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>锋利的jQuery笔记</title>
    <link href="http://yoursite.com/2019/07/25/jQuery/"/>
    <id>http://yoursite.com/2019/07/25/jQuery/</id>
    <published>2019-07-25T13:15:18.553Z</published>
    <updated>2019-08-18T01:24:02.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="锋利的jQuery"><a href="#锋利的jQuery" class="headerlink" title="锋利的jQuery"></a>锋利的jQuery</h1><h2 id="第一章-认识jQuery"><a href="#第一章-认识jQuery" class="headerlink" title="第一章 认识jQuery"></a>第一章 认识jQuery</h2><ul><li><p><strong>jQuery简介优势，JavaScript的缺点</strong></p></li><li><p><strong>程序中的<code>$</code>符号是<code>jQuery</code>的一个简写</strong></p></li><li><p><strong><code>window.onload</code>与<code>$(document).ready()</code>的区别</strong></p></li><li><p><strong>jQuery代码风格</strong></p></li><li><p><strong>jQuery对象和DOM对象的介绍</strong></p><p>1.jQuery转换为DOM对象</p><p>（1）jQuery是一个类数组对象，可以通过[index]的方法得到对应的DOM对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $cr = $(<span class="string">"#cr"</span>);</span><br><span class="line"><span class="keyword">var</span> cr = $cr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>（2）这种方法是jQuery本身提供的，通过get(index)方法得到对应的DOM对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &amp;cr = $(<span class="string">"#cr"</span>);</span><br><span class="line"><span class="keyword">var</span> cr = $cr.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>2.DOM对象转成jQuery对象</p><p>对于一个DOM对象，只需要用$()把DOM对象包装起来，就可以获得一个jQuery对象了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cr = <span class="built_in">document</span>.getElementById(<span class="string">"cr"</span>);</span><br><span class="line"><span class="keyword">var</span> $sr = $(cr);</span><br></pre></td></tr></table></figure><p>【注意】：DOM对象才能使用都DOM中的方法，jQuery对象不可以使用DOM中的方法。</p></li><li><p><strong>解决jQuery和其它库的冲突</strong></p><ul><li><code>jQuery.noConflict()</code>方法</li><li>jQuery库在其它库之前导入</li><li>jQuery库在其它库之后导入</li></ul></li></ul><h2 id="第二章-jQuery选择器"><a href="#第二章-jQuery选择器" class="headerlink" title="第二章 jQuery选择器"></a>第二章 jQuery选择器</h2><ul><li><p>CSS的选择器</p></li><li><p>CSS选择器找到元素后是添加样式，而jQuery选择器找到元素后是添加行为；jQuery的行为准则都必须在获取到元素之后才能生效。</p></li><li><p>jQuery选择器的优势（简洁的写法、支持CSS1到CSS3的选择器、完善的处理机制）</p></li><li><p>jQuery选择器分为基本选择器、层次选择器、过滤选择器和表单选择器</p></li><li><p>基本选择器</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>#id</td><td>根据给定的id匹配一个元素</td><td>单个元素</td></tr><tr><td>.class</td><td>根据给定的类名匹配元素</td><td>集合元素</td></tr><tr><td>element</td><td>根据匹配的元素名匹配元素</td><td>集合元素</td></tr><tr><td>*</td><td>匹配所有元素</td><td>集合元素</td></tr><tr><td>selector1, selector2,…</td><td>将每一个选择器匹配到的元素合并后一起返回</td><td>集合元素</td></tr></tbody></table></li></ul><ul><li><p>层次选择器</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>$(“ancestor descendant”)</td><td>选取ancestor元素里的所有后代元素</td><td>集合元素</td></tr><tr><td>$(“parent&gt;child”)</td><td>选取parent元素下的子元素</td><td>集合元素</td></tr><tr><td>$(“prev+next”)</td><td>选取紧接在perv元素后的next元素</td><td>集合元素</td></tr><tr><td>$(“prev~siblings”)</td><td>选取prev元素之后的所有siblings元素</td><td>集合元素</td></tr></tbody></table></li></ul><ul><li><p>过滤选择器包括：基本过滤选择器，内容过滤选择器、可见性过滤选择器、属性过滤选择器、子元素过滤选择器、表单对象属性过滤选择器</p></li><li><p>基本过滤选</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>:first</td><td>选取第一个元素</td><td>单个元素</td></tr><tr><td>:last</td><td>选取最后一个元素</td><td>单个元素</td></tr><tr><td>:not(selector)</td><td>去除所有与给定选择器匹配的元素</td><td>集合元素</td></tr><tr><td>:even</td><td>选取索引是偶数的元素</td><td>集合元素</td></tr><tr><td>:odd</td><td>选取索引是奇数的元素</td><td>集合元素</td></tr><tr><td>:eq(index)</td><td>选取索引等于index的元素</td><td>单个元素</td></tr><tr><td>:gt(index)</td><td>选取索引大于index的元素</td><td>集合元素</td></tr><tr><td>:lt(index)</td><td>选取索引小于index的元素</td><td>集合元素</td></tr><tr><td>:header</td><td>选取所有的标题元素</td><td>集合元素</td></tr><tr><td>:animated</td><td>选取当前正在执行动画的所有元素</td><td>集合元素</td></tr><tr><td>:focus</td><td>选取当前获得焦点的元素</td><td>集合元素</td></tr></tbody></table></li></ul><ul><li><p>内容过滤选择器</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>:contains(text)</td><td>选取含有文本内容为“text”的元素</td><td>集合元素</td></tr><tr><td>:empty</td><td>选取不包含子元素或者文本的空元素</td><td>集合元素</td></tr><tr><td>:has(selector)</td><td>选取含有选择器所匹配的元素的元素</td><td>集合元素</td></tr><tr><td>:parent</td><td>选取含有子元素或者文本的元素</td><td>集合元素</td></tr></tbody></table></li><li><p>可见性过滤选择器</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>:hidden</td><td>选取所有不可见的元素</td><td>集合元素</td></tr><tr><td>:visible</td><td>选取所有可见的元素</td><td>集合元素</td></tr></tbody></table></li></ul><ul><li><p>属性过滤选择器</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>[attribute]</td><td>选取拥有此属性的元素</td><td>集合元素</td></tr><tr><td>[attribute=value]</td><td>选取属性值为value的元素</td><td>集合元素</td></tr><tr><td>[attribute!=value]</td><td>选取属性值不等于value的元素</td><td>集合元素</td></tr><tr><td>[attribute^=value]</td><td>选取属性值以value开头的元素</td><td>集合元素</td></tr><tr><td>[attribute$=value]</td><td>value结尾</td><td>集合元素</td></tr><tr><td>[attribute*=value]</td><td>含有value</td><td>集合元素</td></tr><tr><td>[attribute|=value]</td><td>选取属性等于给定字符串或以该字符串为前缀</td><td>集合元素</td></tr><tr><td>[attribute~=value]</td><td>选取属性用空格分隔的值中包含一个给定值的元素</td><td>集合元素</td></tr><tr><td><code>[attribute1][attribute2][attributeN]</code></td><td>用属性选择器合并一个复合属性选择器，满足多个条件。每选择一次，缩小一次范围</td><td>集合元素</td></tr></tbody></table></li><li><p>子元素过滤选择器</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>:nth-child(index/even/odd/equation)</td><td>选取每个父元素下的第index个子元素或者奇偶元素（下标从1开始）</td><td>集合元素</td></tr><tr><td>:first-child</td><td>选取每个父元素第一个子元素</td><td>集合元素</td></tr><tr><td>:last-child</td><td>选取每个服元素最后一个子元素</td><td>集合元素</td></tr><tr><td>:only-child</td><td>唯一元素</td><td>集合元素</td></tr></tbody></table></li></ul><ul><li><p>表单对象属性过滤选择器</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>:enabled</td><td>选取所有可用的元素</td><td>集合元素</td></tr><tr><td>:disabled</td><td>选取所有不可用的元素</td><td>集合元素</td></tr><tr><td>:checked</td><td>选取所有被选中的元素（单选复选框）</td><td>集合元素</td></tr><tr><td>:selected</td><td>选取所有被选中的选项元素（下拉元素）</td><td>集合元素</td></tr></tbody></table></li></ul><ul><li><p>表单选择器</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>:input</td><td>选择所有的<input>、<textarea>、</textarea><select>和</select><button>元素</button></td><td>集合元素</td></tr><tr><td>:text</td><td>选取所有的单行文本框</td><td>集合元素</td></tr><tr><td>:passward</td><td>密码框</td><td>集合元素</td></tr><tr><td>:radio</td><td>单选框</td><td>集合元素</td></tr><tr><td>:checkbox</td><td>多选框</td><td>集合元素</td></tr><tr><td>:submit</td><td>提交按钮</td><td>集合元素</td></tr><tr><td>:image</td><td>图像按钮</td><td>集合元素</td></tr><tr><td>:reset</td><td>重置按钮</td><td>集合元素</td></tr><tr><td>:button</td><td>所有的按钮</td><td>集合元素</td></tr><tr><td>:file</td><td>所有的上传域</td><td>集合元素</td></tr><tr><td>:hidden</td><td>所有不可见元素</td><td>集合元素</td></tr></tbody></table></li></ul><ul><li><p>选择器中的一些注意事项</p><ul><li>选择器中含有“.”、“#”、“(”、或“[”等特殊字符</li><li>选择器的@符号问题</li><li>选择器中含有空格的注意事项</li></ul></li><li><p>其它选择器</p></li></ul><h2 id="第三章-jQuery中的DOM操作"><a href="#第三章-jQuery中的DOM操作" class="headerlink" title="第三章 jQuery中的DOM操作"></a>第三章 jQuery中的DOM操作</h2><ul><li><p><strong>DOM的分类</strong>（DOM Core、HTML-DOM、CSS-DOM)</p></li><li><p><strong>查找节点</strong></p><p>查找元素节点（通过选择器来完成）、查找属性节点（<strong><code>attr()</code></strong>方法来获取它的各种属性的值)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $li = $(<span class="string">"ul :eq(1)); //获取&lt;ul&gt;里面的第二个&lt;li&gt;标签</span></span><br><span class="line"><span class="string">var text = $("</span>para<span class="string">").attr("</span>title<span class="string">"); //获取属性title</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建节点</strong></p><p>创建元素节点（<strong>工厂模式$()</strong>）、创建文本节点、创建属性节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $li_1 = $(<span class="string">"&lt;li&gt;&lt;/li&gt;"</span>) <span class="comment">//创建了一个&lt;li&gt;元素</span></span><br><span class="line"><span class="keyword">var</span> $li_2 = $(<span class="string">"&lt;li&gt;香蕉&lt;li&gt;"</span>);  <span class="comment">//创造了一个文本节点</span></span><br><span class="line"><span class="keyword">var</span> $li_3 = $(<span class="string">"&lt;li title="</span>香蕉<span class="string">"&gt;香蕉&lt;/li&gt;"</span>)<span class="comment">//创建了一个属性节点</span></span><br></pre></td></tr></table></figure></li><li><p><strong>插入、移动节点</strong></p><p><code>append()</code>,<code>appendTo()</code> ,<code>prepend()</code>,<code>prependTo()</code>,<code>after()</code>,<code>insertAfter()</code> ,<code>before()</code> ,<code>insertBefore()</code> </p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>append()</td><td>向每个匹配元素<strong>内部</strong>追加内容</td></tr><tr><td>appendTo()</td><td>颠倒了append()方法</td></tr><tr><td>prepend()</td><td>向每个匹配元素内部前置内容</td></tr><tr><td>prependTo()</td><td>颠倒了prepend()</td></tr><tr><td>after()</td><td>在每个匹配元素之后插入内容</td></tr><tr><td>insertAfter()</td><td>颠倒了after()</td></tr><tr><td>before()</td><td>在每个元素之前插入内容</td></tr><tr><td>insertBefore()</td><td>颠倒before()</td></tr></tbody></table></li><li><p><strong>删除节点</strong></p><p><code>remove()</code>方法、<code>detach()</code>方法、<code>empty()</code>方法</p><p>remove()方法：当某个节点用remove()方法删除后，该节点包含的所有后代节点将同时被删除。这个方法的返回值是一个指向已被删除的节点的引用，因此可以在以后再使用这些元素。</p><p>detach()方法：这个方法和remove()一样，也是从DOM中去除所有匹配元素，但这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素，与remove()方法不同的是，所有绑定的事件、附加的数据等都会保留下来。</p><p>empty()方法：严格来说empty()方法并不是删除节点，而是清空节点，它能清空元素中的所有后代节点。</p></li><li><p><strong>复制节点</strong></p><p><code>clone()</code>方法（注意深复制和浅复制）</p><p>clone(): 复制节点后，被复制的新元素并不具有任何行为。</p><p>clone(true): 复制元素的同时复制元素中所绑定的事件。</p></li><li><p><strong>替换节点</strong></p><p><code>replaceWith()</code>方法和<code>replaceAll()</code>方法</p><p>replaceWith()方法的作用是将所匹配的元素都替换成指定的HTML或者DOM元素。</p><p>replaceAll()是replaceWith()的颠倒方法。</p><p>如果在替换之前，已经为元素绑定事件，替换后原先绑定的事件将会与被替换的元素一起消失，需要在新元素上重新绑定新的事件。</p></li><li><p><strong>包裹节点</strong></p><p><code>wrap()</code>方法、<code>wrapAll()</code>方法、<code>wrapInner()</code>方法</p><p>将某个节点用其它标记包裹起来。</p><ol><li>wrap()</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"strong"</span>).wrap(<span class="string">"&lt;b&gt;&lt;/b&gt;"</span>); <span class="comment">//用&lt;b&gt;标签把&lt;strong&gt;元素包裹起来</span></span><br><span class="line"><span class="comment">//结果：&lt;b&gt;&lt;strong&gt;你好&lt;/strong&gt;&lt;/b&gt;</span></span><br></pre></td></tr></table></figure><p>   2.wrapAll()。该方法会将所有匹配的元素用一个元素包裹起来，不同于wrap()方法，wrap()方法是把所有的元素进行单独的包裹。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">html代码：</span></span><br><span class="line"><span class="comment">&lt;strong&gt;haha&lt;/strong&gt;</span></span><br><span class="line"><span class="comment">&lt;strong&gt;xixi&lt;/strong&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$(<span class="string">"strong"</span>).wrap(<span class="string">"&lt;b&gt;&lt;/b&gt;"</span>);</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//&lt;b&gt;&lt;strong&gt;haha&lt;/strong&gt;&lt;/b&gt;</span></span><br><span class="line"><span class="comment">//&lt;b&gt;&lt;strong&gt;xixi&lt;/strong&gt;&lt;/b&gt;</span></span><br><span class="line">$(<span class="string">"strong"</span>).wrapAll(<span class="string">"&lt;b&gt;&lt;/b&gt;"</span>);</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//&lt;b&gt;</span></span><br><span class="line"><span class="comment">//&lt;strong&gt;haha&lt;/strong&gt;</span></span><br><span class="line"><span class="comment">//&lt;strong&gt;xixi&lt;/strong&gt;</span></span><br><span class="line"><span class="comment">//&lt;/b&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果被包裹的多个元素间有其他元素，其他元素会被放到包裹元素之后</span></span><br></pre></td></tr></table></figure><p>  3.wrapInner()方法，该方法将每一个匹配的元素的子内容（包括文本节点）用其他结构化的标记包裹起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"strong"</span>).wrapInner(<span class="string">"&lt;b&gt;&lt;/b&gt;"</span>);</span><br><span class="line"><span class="comment">//&lt;strong&gt;&lt;b&gt;哈哈&lt;/b&gt;&lt;/storng&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>属性操作</strong></p><p>获取和设置属性（<strong><code>attr()</code>方法</strong>）、删除属性（<code>removeAttr()</code>方法）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"P"</span>).attr(<span class="string">"title"</span>, <span class="string">"haha"</span>);</span><br><span class="line">$(<span class="string">"P"</span>).atrr(<span class="string">"title"</span>:<span class="string">"jaja"</span>, <span class="string">"name"</span>:<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">&amp;(<span class="string">"P"</span>).removeAttr(<span class="string">"title"</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>样式操作</strong></p><p>获取和设置样式（<code>attr()</code>方法）、追加样式（<code>addClass()</code>方法）【注意<code>attr()</code>和<code>addClass()</code>的区别】、移除样式（<code>removeClass()</code>方法）、切换样式（<code>toggle()</code>方法和<code>toggleClass()</code>方法）、判断是否含有某个样式（<code>hasClass()</code>方法）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).addClass(<span class="string">"another"</span>); <span class="comment">//给&lt;p&gt;元素追加“another”类</span></span><br><span class="line">$(<span class="string">"p"</span>).removeClass(<span class="string">"another"</span>); <span class="comment">//移除类；若不今添加参数，则将class的值全部清除</span></span><br><span class="line">$(<span class="string">"p"</span>).hasClass(<span class="string">"another"</span>);<span class="comment">//判断元素中是否含有某个类，如果有则返回true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$toggleBtn.toggle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="comment">//显示元素    代码③</span></span><br><span class="line">   &#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//隐藏元素  代码④</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*toggle()方法在此处的作用是交替执行代码③和代码④两个函数，如果元素原来是显示的，则隐藏它；反之，显示*/</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">"p"</span>).toggleClass(<span class="string">"another"</span>); <span class="comment">//重复切换类名“another"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>设置和获取HTML、文本和值</strong></p><p><code>html()</code>方法、<code>text()</code>方法、<code>val()</code>方法</p><p>html()：类似于JavaScript中的innerHTML属性，可以用来读取或者设置某个元素中的HTML内容。</p><p>text()：类似于JavaScript中的innerText属性，可以用来读取或者设置某个元素中的文本内容。</p><p>val()：类似于JavaScript中的value属性，可以用来设置和获取元素的值。无论是文本框、下拉列表还是单选框，它都可以返回元素的值。如果元素为多选，则返回一个包含所有选择的值的数组。</p></li><li><p><strong>遍历节点</strong></p><p><code>children()</code>方法、<code>next()</code>方法，<code>prev()</code>方法，<code>siblings()</code>方法、<code>closest()</code>方法、<code>parent(),parents(),closest()</code>的区别</p><p>children()：取得匹配元素的所有子元素集合。（只考虑子元素而不考虑其他后代元素）</p><p>next()：取得匹配元素后面紧邻的同辈元素。</p><p>prev()：取得匹配元素前面紧邻的同辈元素。</p><p>siblings()：取得所匹配元素前后所有的同辈元素。</p><p>closest()：取得最近的匹配元素，首先检查当前元素是否匹配，如果匹配则直接返回元素本身。如果不匹配则向上查找父元素，逐级向上直到找到匹配选择器的元素如果什么都没找到，则返回一个空的jQuery对象。</p><p>parent()：获得集合中每个元素的父级元素。</p><p>parents()：获得集合中每个元素的祖先元素。</p></li><li><p><strong>CSS-DOM操作</strong></p><p><code>css()</code>方法、<code>height()</code>方法、<code>width()</code>方法、<code>offset()</code>方法、<code>position()</code>方法、<code>scrollTop()</code>方法和<code>scrollLeft()</code>方法</p><p>css() : 可以直接利用css()方法设置某个元素的单个样式，也可以同时设置多个样式属性。</p><p>offset()：获取在当前视窗的相对偏移，其中返回的对象包含两个属性，即top和left。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> offset = $(<span class="string">"p"</span>).offset();</span><br><span class="line"><span class="keyword">var</span> left = offset.left;</span><br><span class="line"><span class="keyword">var</span> top = offset.top;</span><br></pre></td></tr></table></figure></li></ul><p>  position()：获取元素相对于最近的一个position样式属性设置为relative或者absolute的祖父节点的相对偏移，包含两个属性，即top和left。</p><p>  scrollTop()和scrollLeft()方法：获取元素的滚动条距顶端的距离和距左端的距离。也可以为这两个方法指定一个参数，控制元素的滚动条滚动到指定位置。</p><h2 id="第四章-jQuery的事件和动画"><a href="#第四章-jQuery的事件和动画" class="headerlink" title="第四章 jQuery的事件和动画"></a>第四章 jQuery的事件和动画</h2><h3 id="jQuery中的事件"><a href="#jQuery中的事件" class="headerlink" title="jQuery中的事件"></a>jQuery中的事件</h3><ul><li><p><strong><code>$(document).ready()</code>方法和<code>window.onload</code>方法的异同点</strong></p><ul><li>执行时机</li><li>多次使用</li><li>间歇方式</li></ul></li><li><p><strong>load()方法</strong>（<code>$(window).load(function(){  })</code>）</p></li><li><p><strong>事件绑定</strong></p><ul><li>在文档装载完成后，如果打算为元素绑定事件来完成某些操作，可以使用<strong><code>bind()</code></strong>方法来对匹配元素进行特定事件的绑定。</li><li><code>bind()</code>方法的使用</li><li>与<code>ready()</code>方法一样，<code>bind()</code>方法也可以多次调用。</li><li>is()方法</li><li>简写绑定事件</li></ul></li><li><p><strong>合成事件</strong></p><ul><li><code>hover()</code>方法（jQuery自定义的方法，用于模拟光标悬停事件）的使用和注意事项。</li><li><code>toggle()</code>方法（用于模拟鼠标连续单击事件）的作用和使用。</li></ul></li><li><p><strong>事件冒泡</strong></p><ul><li>什么是事件冒泡以及事件冒泡引发的问题</li><li>事件对象（①jQuery进行了必要的扩展和封装，从而使得在任何浏览器中都能很轻松的获得事件对象以及事件对象的一些属性 ②在程序中使用事件对象只需要为函数添加一个参数③这个事件对象只有事件处理函数才能访问到。事件处理函数执行完毕后，事件对象就被销毁）</li><li><code>stopPropagation()</code>方法—阻止事件冒泡</li><li><code>preventDefault()</code>方法—阻止元素的默认行为</li><li>如果想同时对事件对象停止冒泡和默认行为，可以在事件处理函数中返回false。这是对在事件对象上同时调用<code>stopPropagation()</code>方法和<code>preventDefault()</code>方法的一种简写方式。</li><li>jQuery不支持事件捕获。</li></ul></li><li><p><strong>事件对象的属性</strong></p><ul><li><code>event.type</code> — 获取到事件的类型</li><li><code>event.stopPropagation()</code>方法 — 阻止事件冒泡</li><li><code>event.preventDefault()</code>方法 — 阻止默认行为</li><li><code>event.target</code> — 获取到触发事件的元素</li><li><code>event.relatedTarget</code> </li><li><code>event.pageX</code> 和 <code>event.pageY</code> — 获取到光标相对于页面x坐标和y坐标 </li><li><code>event.which</code> — 在鼠标单击事件中获取到鼠标的左、中、右键；在键盘事件中获取键盘的按键</li><li><code>event.metaKey</code> — 在键盘事件中获取<code>&lt;ctrl&gt;</code>键</li></ul></li><li><p><strong>移除事件</strong></p><ul><li>不仅可以为同一个元素绑定多个事件，也可以为多个元素绑定同一个事件。</li><li><code>unbind()</code>方法的使用与说明</li><li><code>one()</code>方法 — one()方法可以为元素绑定处理函数，当处理函数触发一次后，立即被删除。即在每个对象上，事件处理函数只会被执行一次。</li></ul></li><li><p><strong>模拟事件</strong></p><ul><li><p><code>trigger()</code>方法</p><p>①可以完成模拟操作（常用模拟）</p><p>②不仅能触发浏览器支持的具有相同名称的事件，也可以触发自定义的事件（触发自定义事件）</p><p>③该方法有两个参数，第一个参数是要触发的时间类型，第二个参数是要传递给事件处理函数的附加数据，以数组形式传递。（传递数据）</p><p>④<code>trigger()</code>方法触发后，会执行浏览器默认操作。（执行默认操作）</p><p>⑤如果只想触发事件而不想执行浏览器的默认操作，可以使用<code>triggerHandler()</code>方法。</p></li></ul></li><li><p><strong>其它用法</strong></p><p>前面已经介绍，<code>bind()</code>方法不仅能为元素绑定浏览器支持的具有相同名称的事件，也可以绑定自定义事件。</p><ul><li>绑定多个事件类型</li><li>添加事件命名空间，便于管理</li><li>相同事件名称，不同命名空间执行方法</li></ul></li></ul><h3 id="jQuery中的动画"><a href="#jQuery中的动画" class="headerlink" title="jQuery中的动画"></a>jQuery中的动画</h3><ul><li><p><code>show()</code>方法和<code>hide()</code>方法</p><ul><li>在不带参数的情况下，相当于<code>css(&quot;display&quot;, &quot;none/block/inline&quot;)</code></li><li>【注意】：<code>hide()</code>方法在将“内容”的display属性值设为<code>“none”</code>之前，会记住原先的display属性值。当调用<code>show()</code>方法时，就会根据<code>hide()</code>方法记住的display属性值来显示元素。</li><li>可以为<code>hide()</code>和<code>show()</code>方法指定一个参数，比如<code>“slow”，“normal”，“fast”</code>或数值。这样就会产生动画效果。</li><li><code>hide(600)</code>方法会同时减少“内容”的高度、宽度和不透明度，直至这三个属性的值都为0，最后设置该元素的CSS规则为<code>“display：none&quot;</code>；<code>show(500)</code>方法则会从上打下增加“内容”的高度，从左到右增加“内容”的宽度，同时增加“内容”的不透明度，直至内容完全显示。</li></ul></li><li><p><code>fadeIn()</code>方法和<code>fadeOut()</code>方法</p><ul><li>与<code>show()</code>方法不同,<code>fadeIn()</code>方法和<code>fadeOut()</code>方法只改变元素的不透明度。</li><li><code>fadeOut()</code>方法会在指定的一段时间内降低元素的不透明度，直到元素完全消失（”<code>display:none</code>“)。<code>fadeIn()</code>方法与之相反。</li></ul></li><li><p><code>slideUp()</code>方法和<code>slideDown()</code>方法</p><ul><li>这两个方法会改变元素的高度</li><li>如果一个元素的<code>display</code>属性值为“<code>none</code>”，当调用<code>slideDown()</code>方法时，这个元素将由上到下延伸显示。<code>slideUp()</code>与之想反。</li></ul></li><li><p>自定义动画方法<code>animate()</code></p><ul><li><code>animate()</code>的语法</li><li>自定义简单动画，累加、累减动画，多重动画（同时执行多个动画、按顺序执行多个动画），综合动画</li><li><code>animate()</code>方法可以用来代替其他所有的动画方法</li></ul></li><li><p><strong>动画回调函数</strong></p><ul><li>如果想在最后一步切换元素的样式，可以使用回调函数</li><li><code>css()</code>方法并不会加入到动画队列中，而是立即执行，可以使用回调函数（callback）对非动画方法实现排队。只要把<code>css()</code>方法写在最后一个动画的回调函数里即可</li></ul></li><li><p><strong>停止动画和判断是否处于动画状态</strong></p><ul><li><p>停止元素的动画（<code>stop()</code>方法）</p><p>①语法：<code>stop([clearQueue],[gotoEnd])</code>; 参数都可选，均为布尔值。<code>clearQueue</code>代表是否清空未执行完的动画队列；<code>gotoEnd</code>代表是否直接将正在执行的动画跳转到末状态。</p><p>②直接使用<code>stop()</code>方法，则会立即停止当前正在进行的动画，如果接下来还有动画等待继续进行，则以当前状态开始接下来的动画。</p></li><li><p>判断元素是否处于动画状态</p><p>在使用<code>animate()</code>方法的时候，要避免动画积累而导致的动画与用户的行为不一致。当用户快速在某个元素上执行<code>animate()</code>动画时，就会出现动画积累。解决方法是判断元素是否正处于动画状态，如果元素不处于动画状态，才为元素添加新的动画，否则不添加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!$(element).is(<span class="string">":animated"</span>))&#123; <span class="comment">//判断元素是否处于动画状态</span></span><br><span class="line">    <span class="comment">//如果当前没有进行动画，则添加新动画</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>延迟动画</p><p>如果想对动画进行延迟操作，可以使用<code>delay()</code>方法</p></li></ul><ul><li><p><strong>其它动画方法</strong></p><ul><li><code>toggle()</code>方法 — 可以切换元素的可见状态。</li><li><code>slideTaggle()</code>方法 — 通过高度变化来切换匹配元素的可见性。</li><li><code>fadeTo()</code>方法 — 可以把元素的不透明度以渐进的方式调整到指定的值。</li><li><code>fadeToggle()</code>方法 — 通过不透明度变化来匹配元素的可见性。</li></ul></li><li><p><strong>动画队列</strong></p><ul><li>一组元素上的动画效果<ul><li>当在一个<code>animate()</code>方法中应用多个属性时，动画是同时发生的</li><li>当以链式的写法应用动画方法时，动画是按照顺序发生的（除非<code>queue</code>选项值为<code>false</code>）</li></ul></li><li>多组元素上的动画效果<ul><li>默认情况下，动画都是同时发生的</li><li>当以回调的形式应用动画方式的时（包括动画的回调函数和<code>queue()</code>方法的回调函数），动画是按照回调的顺序发生的。</li></ul></li></ul></li></ul><h2 id="第五章-jQuery对表单、表格的操作及更多应用"><a href="#第五章-jQuery对表单、表格的操作及更多应用" class="headerlink" title="第五章 jQuery对表单、表格的操作及更多应用"></a>第五章 jQuery对表单、表格的操作及更多应用</h2><ul><li><p>表单应用</p><ul><li>表单的组成部分（表单标签、表单域、表单按钮）</li><li>单行文本框的应用</li><li>多行文本框的应用（高度变化、滚动条高度变化）</li><li>复选框应用</li><li>下拉框应用</li><li>表单验证</li></ul></li><li><p>表格应用</p><ul><li>表格变色（普通的隔行变色、单选框控制表格行高亮、复选框控制表格行高亮）</li><li>表格展开关闭</li><li>表格内容筛选</li></ul></li><li><p>其他应用</p><ul><li>网页字体大小</li><li>网页选项卡</li><li>网页换肤</li></ul></li></ul><h2 id="第六章-jQuery与Ajax的应用"><a href="#第六章-jQuery与Ajax的应用" class="headerlink" title="第六章 jQuery与Ajax的应用"></a>第六章 jQuery与Ajax的应用</h2><h3 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h3><ul><li>Ajax的优势和不足</li><li>Ajax的XMLHttpRequest对象</li><li>==<strong>原生JavaScript操作Ajax的步骤</strong>==</li></ul><h3 id="part-2-jQuery中的Ajax"><a href="#part-2-jQuery中的Ajax" class="headerlink" title="part 2 jQuery中的Ajax"></a><strong>part 2</strong> jQuery中的Ajax</h3><p>jQuery对Ajax操作进行了封装，在jQuery中<code>$.ajax()</code>方法属于最底层的方法，第2层是load()、<code>$.get()</code>、<code>$.post</code>方法，第3层是<code>$.getScript()</code>和<code>$.getJSON()</code>方法。</p><ol><li><p>load()方法</p><ul><li><p>载入HTML文档</p><p>load()方法能载入远程HTML代码并插入DOM中。</p><p>结构：<code>load(url [,data] [, callback])</code></p><p>url – 请求HTML页面的URL地址</p><p>data（可选） — 发送至服务器的key/value数据</p><p>callback（可选） — 请求完成时的回调函数，无论请求成功或失败</p></li><li><p>筛选载入的HTML文档</p><p>通过为URL参数指定选择符，load()方法的URL参数语法结构是“url selector”</p></li><li><p>传递方式</p><p>load()方法的传递方式根据参数data来自动指定。如果没有参数传递，则采用GET方式传递；反之，则会自动转换为POST方式。</p></li><li><p>回调函数</p><p>对于必须在加载完成后才能继续的操作，load()方法提供了回调函数（callback），该函数有3个参数，分别代表请求返回的内容、请求状态和XMLHttpRequest对象</p></li></ul></li><li><p><code>$.get()</code>方法和<code>$.post()</code>方法</p><p>load()方法通常用来从web服务器上获取静态的数据文件，然而这并不能体现Ajax的全部价值。在项目中，如果需要传递一些参数给服务器中的页面，那么可以使用<code>$.get()</code>或者<code>$.post()</code>方法.</p><p>【注意】：<code>$.get()</code>方法和<code>$.post()</code>方法是jQuery中的全局函数，而在此之前讲的jQuery方法都是对jQuery对象进行操作的。</p><ul><li><p><strong><code>$.get()</code>方法</strong></p><p>该方法使用GET方式来进行异步请求</p><p>结构：<code>$.get(url [, data] [, callback] [, type])</code></p><p><code>url</code> — 请求的HTML页的URL</p><p><code>data</code>（可选）— 发送至服务器的<code>key/value</code>数据会作为    QueryString附加到请求URL中</p><p><code>callback</code>（可选）— 载入成功时回调函数（只有当Response的返回状态是success才调用该方法）自动将请求结果和状态传递给该方法</p><p>type（可选）— 服务器返回内容的格式，包括<strong>xml, html, script, json, text</strong> 和 <strong>_default</strong></p><p>该方法的回调函数只有两个参数。</p></li><li><p><code>$.post()</code>方法</p><p><code>$.post()</code>和<code>$.get()</code>方法的结构和使用方式都相同，不过它们之间仍有一下区别：</p><p>①GET请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器。当然，在Ajax请求中，这种区别对用户是不可见的。</p><p>②GET方式对传输的数据有大小限制（通常不能大于2KB），而使用POST方式传递的数据量要比GET方式大得多（理论上不受限制）</p><p>③GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号密码等。在某种情况下，GET方式会带来严重的安全性问题，而POST方式相对来说就可以避免这些问题。</p><p>④GET方式和POST方式传递的数据在服务端的获取也不相同。在PHP中，GET方式可以用<code>$_GET[]</code>获取，而POST方式可以用<code>$_POST[]</code>获取。两种方式都可以通过<code>$_REQUEST[]</code>来获取</p></li></ul></li><li><p><code>$.getScript()</code>方法和<code>$.getJson()</code>方法</p><ul><li>$.getScript()`</li></ul><p>jQuery提供了<code>$.getScript()</code>方法来直接加载.js文件，与加载一个HTML片段一样简单方便，并且不需要对JavaScript文件进行处理，JavaScript文件会自动执行。    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"#send"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $.getScript(<span class="string">"test.js"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li></ol><p>   与其他Ajax方法一样，<code>$.getScript()</code>方法也有回调函数，他会在    JavaScript文件成功载入后运行</p><ul><li><p>$.getJSON()`</p><p>​         <code>$.getJSON()</code>方法用于加载JSON文件，与<code>$.getScript()</code>方法的使用方法相同。</p><pre><code>jQuery提供了回调函数，在回调函数里处理返回的数</code></pre></li><li><p>$.each()`方法</p><p>   <code>$.each()</code>方法不同于jQuery对象的each()方法，它是一个全局函数，不操作jQuery对象，而是以一个数组或对象作为第一个参数，以一个回调函数作为第二个参数。回调函数拥有两个参数，第一个为对象的成员或数组的索引，第二个为对应变量或内容。</p></li></ul><ol start="4"><li><code>$.ajax()</code>方法</li></ol><h3 id="part-3-序列化元素"><a href="#part-3-序列化元素" class="headerlink" title="part 3 序列化元素"></a>part 3 序列化元素</h3><ol><li>serialize()方法</li><li>serializeArray()方法</li><li>$.param()方法</li></ol><h2 id="第九章-jQuery-Mobile"><a href="#第九章-jQuery-Mobile" class="headerlink" title="第九章 jQuery Mobile"></a>第九章 jQuery Mobile</h2><ul><li><p>HTML 5的简介</p></li><li><p>jQuery Mobile简介以及它的主要特性</p></li><li><p>jQuery的使用</p><ul><li>下载</li><li>建议在页面中使用HTML 5标准的页面声明和标签，因为移动设备浏览器对HTML 5的支持程度要远远优于PC设备</li><li>构建HTML模板，引入框架</li></ul></li><li><p><code>data-role</code>属性</p></li><li><p><code>data-inset</code>属性</p></li><li><p><code>data-theme</code>属性</p></li><li><p>其他的框架</p></li><li><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">data-role</span>=<span class="string">"listview"</span> <span class="attr">data-inset</span>=<span class="string">"true"</span> <span class="attr">data-theme</span>=<span class="string">"e"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Acura<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>BMW<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;锋利的jQuery&quot;&gt;&lt;a href=&quot;#锋利的jQuery&quot; class=&quot;headerlink&quot; title=&quot;锋利的jQuery&quot;&gt;&lt;/a&gt;锋利的jQuery&lt;/h1&gt;&lt;h2 id=&quot;第一章-认识jQuery&quot;&gt;&lt;a href=&quot;#第一章-认识jQuery&quot;
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点</title>
    <link href="http://yoursite.com/2019/07/24/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2019/07/24/前端知识点/</id>
    <published>2019-07-24T09:27:24.689Z</published>
    <updated>2019-07-24T10:57:53.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端知识点"><a href="#前端知识点" class="headerlink" title="前端知识点"></a>前端知识点</h1><h2 id="HTML-amp-amp-CSS"><a href="#HTML-amp-amp-CSS" class="headerlink" title="HTML&amp;&amp;CSS"></a>HTML&amp;&amp;CSS</h2><ul><li>01.html5的SEO优化</li><li>02.有趣的空格</li><li>03.Html和xhtml的区别</li><li>04.盒子模型</li><li>[05.css sprite](./HTML/04.CSS Sprite)</li><li>06.position属性值absolute和relative的区别</li><li>07.css选择器</li><li>08.css兼容性问题</li><li>09.css响应式布局</li><li>10.css3实现圆角</li><li>11.css3实现至下而上的弹框</li><li>12.px、em、rem的区别</li><li>13.css盒子模型、bfc</li><li>14.元素的水平垂直居中方法</li><li>15.Css 渐变</li><li>16.display:none和visibility:hidden</li><li>17.css优化</li><li>18.link和@import区别</li><li>[19.描述z index和层叠上下文](./CSS/24.描述z index和层叠上下文)</li><li>20.css动画与js动画比较</li><li>21.负margin的使用</li><li>[22.有趣的h5api：page visibility api](./HTML/05.有趣的h5api：page visibility api)</li><li>23.placeholder的使用及其兼容方法</li><li>[24.响应式图片 srcset和 picture 的使用](./HTML/响应式图片 srcset和 picture 的使用)</li><li>25.display的值与其用法</li><li>[26.em rem px 区别](./CSS/26.px em rem 区别)</li><li>[27.flex 布局](./HTML/20.flex 布局)</li><li>[28.grid 布局](./HTML/grid 布局)</li><li>29.伪类</li><li>30.页面适配</li><li>31.伪元素</li></ul><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul><li>03.es5在es3上增加的内容</li><li>04.es6中的promise解决异步编程</li><li>[06.DOM Ready](./js/06.dom ready)</li><li>07.js简单动画</li><li>08.js基本数据类型和引用类型</li><li>09.js获取元素节点的方法</li><li>10.如何判断两个对象相等</li><li>11.原生js实现jq的事件绑定</li><li>[12.原生js实现jq的on,attr方法](./js/12.原生js实现jquery的on, attr方法)</li><li>[13.js实现链表](./js/13. js实现链表)</li><li>14.事件委托&amp;&amp;事件流&amp;&amp;事件处理</li><li>16.事件模型</li><li>17.如何用js实现图片轮播</li><li>18.DOM优化</li><li>19.js面向对象的三大特征</li><li>20.js对象的创建方法</li><li>21.如何实现深拷贝</li><li>22.js对象</li><li>23.js如何实现私有</li><li>25.js实现div拖拽</li><li>26.js在方法的实例对象上修改方法原型上的属性和方法</li><li>28.倒计时实现、计时器延迟问题和效率</li><li>[29.in的奇妙应用](./js/29. in 的奇妙应用)</li><li>30.匿名函数</li><li>31.如何实现千位分隔符</li><li>32.理解js的闭包</li><li>33.半透明图片移上去不透明及对鼠标快速移入移出的处理</li><li>34.执行环境与作用域</li><li>35.重载</li><li><a href="./js/38.this的指向即特殊情况&call()和apply()的区别">38.this的指向即特殊情况&amp;call()和apply()的区别</a></li><li>41.let与var的区别</li><li>42.移动端适配</li><li>43.注册重复问题</li><li>44.海量数据处理问题</li><li>[48.异步加载](./js/48. 异步加载)</li><li>50.有关变量声明提升的有意思的代码</li><li>51.移动端300ms点击延迟</li><li>52.箭头函数和普通函数的区别</li><li>53.原型链</li><li>54.JS垃圾回收机制</li><li>56.什么是伪数组和如何将伪数组转化为数组</li><li>57.深入理解定时器：setTimeout与setInterval</li><li>58.网站性能优化</li><li>59.Domcontentloaded和load</li><li>60.执行上下文</li><li>61.详解HTTPS和HTTP</li><li>62.querySelector与getElementBy系列方法区别</li><li>63.call与apply的区别</li><li>64.Js和jq获取元素位置</li><li>[65.ARRAY 常用方法](./js/ARRAY 常用方法)</li><li>66.函数防抖</li><li>67.函数节流</li><li>68.new与create的区别</li><li>69.Jsonp原理</li><li>[70.cookie 和 session的区别](./js/70.cookie 和 session的区别)</li><li>80.模块化</li><li>81.匿名函数的使用实例</li><li>[82.string常用方法](./js/string 常用方法)</li><li>83.预解析</li><li>84.null与undefined的区别</li><li>85.ES6新增的数组构造器</li><li>86.深入理解动态作用域和词法作用域</li><li>87.变量提升</li><li>88.柯里化</li><li>89.浅克隆</li><li>90.深克隆</li><li>91.js的运行机制</li><li>92.工厂模式</li><li>93.简述BOM对象</li><li>94.ajax</li><li>95.void（0）</li><li>96.原生实现排序算法</li><li>97.HTTP状态码</li><li>98.抽象工厂模式</li><li>[99.Map、FlatMap 和 Reduce](./js/Map、FlatMap 和 Reduce)</li><li>[100.Generator 实现](./js/Generator 实现)</li><li>101.0.30000000000000004</li><li>102.模拟jq的链模式</li><li>103.箭头函数的this</li><li>104.类数组对象</li><li>105.执行上下文</li><li>106.cors</li><li>107.如何遍历数组</li><li>108.Promise实现</li><li>109.Proxy实现</li><li>110.GET与POST的区别</li><li>111.ES6模块与CommonJS的差异</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端知识点&quot;&gt;&lt;a href=&quot;#前端知识点&quot; class=&quot;headerlink&quot; title=&quot;前端知识点&quot;&gt;&lt;/a&gt;前端知识点&lt;/h1&gt;&lt;h2 id=&quot;HTML-amp-amp-CSS&quot;&gt;&lt;a href=&quot;#HTML-amp-amp-CSS&quot; class=&quot;
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Js 事件</title>
    <link href="http://yoursite.com/2019/07/24/JavaScript%E4%BA%8B%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/07/24/JavaScript事件/</id>
    <published>2019-07-24T09:27:09.442Z</published>
    <updated>2019-07-24T10:53:55.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS事件"><a href="#JS事件" class="headerlink" title="JS事件"></a>JS事件</h1><h2 id="一、-事件与事件流"><a href="#一、-事件与事件流" class="headerlink" title="一、 事件与事件流"></a>一、 事件与事件流</h2><p>先来看它们的定义：</p><blockquote><p><strong>事件</strong>，就是通过文档或浏览器窗口中发生的一些特定的交互瞬间。</p><p><strong>事件</strong>是您在编程时系统内发生的动作或者发生的事情— 系统会在事件出现的时候触发某种信号并且会提供一个自动加载某种动作（例如：运行一些代码）的机制。</p><p><strong>事件流</strong>描述的是从页面中接收事件的顺序。</p><p>事件流包括<strong>事件冒泡</strong>和<strong>事件捕获</strong>，两者分别由微软和网景公司提出。两个概念都是为了解决页面中事件发生顺序的问题。</p><p><strong>事件冒泡</strong>的思想是：从最具体的元素（文档中嵌套层次最深的那个节点）开始接收，然后逐级向上传播到最不具体的节点（文档）。</p><p><strong>事件捕获</strong>的思想是：不太具体的节点应该更早接受到事件，而最具体的节点应该最后接收到事件。</p><p><strong>DOM事件流</strong>：在<strong>DOM2级事件</strong>中规定，事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会；然后是实际的目标接收到事件；最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。</p></blockquote><p>比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>事件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>aaaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果单击了<code>&lt;div&gt;</code>标签，在事件冒泡的概念下，<code>click</code>事件传播顺序：<code>div -&gt; body -&gt; html -&gt; document</code>;在事件捕获的概念下,<code>click</code>事件传播的顺序：<code>document -&gt; html -&gt; body -&gt; div</code>.</p><p>在DOM事件流中，实际的目标（<code>&lt;div&gt;</code>元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从<code>document</code>到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>就停止了。下一个阶段是“处于目标阶段”，于是事件在<code>&lt;div&gt;</code>上发生，并在事件处理中看成冒泡阶段的一部分。然后冒泡阶段发生，事件又传播回文档。</p><p>【注意】：对于事件代理而言，在事件捕获或事件冒泡阶段处理并没有明显的优劣之分，但由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容角度来说，建议使用事件冒泡模型。最好只在需要在事件到达目标之前截获它的时候将将事件处理程序添加到捕获阶段。</p><p>几个题目，看你是否懂了：</p><ol><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"s1"</span>&gt;</span>s1</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"s2"</span>&gt;</span>s2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    s1.addEventListener("click", function (e) &#123;</span><br><span class="line">        console.log("s1 捕获事件");</span><br><span class="line">    &#125;, true);</span><br><span class="line">    s2.addEventListener("click", function (e) &#123;</span><br><span class="line">        console.log("s2 捕获事件");</span><br><span class="line">    &#125;, true);</span><br><span class="line">    //点击s1，结果为：s1捕获事件</span><br><span class="line">    //点击s2, 结果为：s1捕获事件，s2捕获事件</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"s1"</span>&gt;</span>s1</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"s2"</span>&gt;</span>s2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">s1.addEventListener("click", function (e) &#123;</span><br><span class="line">console.log("s1 冒泡事件");</span><br><span class="line">&#125;, false);</span><br><span class="line">s2.addEventListener("click", function (e) &#123;</span><br><span class="line">console.log("s2 冒泡事件");</span><br><span class="line">&#125;, false);</span><br><span class="line">//点击s1：s1冒泡事件</span><br><span class="line">//点击s2: s2冒泡事件，s1冒泡事件</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"s1"</span>&gt;</span>s1</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"s2"</span>&gt;</span>s2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">s1.addEventListener("click", function (e) &#123;</span><br><span class="line">console.log("s1 冒泡事件");</span><br><span class="line">&#125;, false);</span><br><span class="line">s2.addEventListener("click", function (e) &#123;</span><br><span class="line">console.log("s2 冒泡事件");</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">s1.addEventListener("click", function (e) &#123;</span><br><span class="line">console.log("s1 捕获事件");</span><br><span class="line">&#125;, true);</span><br><span class="line"></span><br><span class="line">s2.addEventListener("click", function (e) &#123;</span><br><span class="line">console.log("s2 捕获事件");</span><br><span class="line">&#125;, true);</span><br><span class="line">//点击s1: s1冒泡，s1捕获</span><br><span class="line">//点击s2: s1捕获事件 s2冒泡事件 s2捕获事件 s1冒泡事件</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当事件捕获和事件冒泡一起存在的情况:</p><p>先记被点击的DOM节点为target节点</p><ol><li>document 往 target节点，捕获前进，遇到注册的捕获事件立即触发执行</li><li>到达target节点，触发事件（对于target节点上，是先捕获还是先冒泡则捕获事件和冒泡事件的注册顺序，先注册先执行）</li><li>target节点 往 document 方向，冒泡前进，遇到注册的冒泡事件立即触发</li></ol><p>总结：</p><ul><li>对于非target节点则先执行捕获在执行冒泡</li><li>对于target节点则是先执行先注册的事件，无论冒泡还是捕获</li></ul></li></ol><h2 id="二、事件处理程序"><a href="#二、事件处理程序" class="headerlink" title="二、事件处理程序"></a>二、事件处理程序</h2><blockquote><p>事件是用户或浏览器自生执行的某种动作。<strong>而响应某个事件的函数就叫做事件处理程序（或事件侦听器）</strong>。</p></blockquote><h3 id="HTML中的事件处理程序"><a href="#HTML中的事件处理程序" class="headerlink" title="HTML中的事件处理程序"></a>HTML中的事件处理程序</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">onclick</span>=<span class="string">"alert('Clicked')"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>某个元素支持的每种事件都可以使用一个与相应事件处理程序同名的HTML特性来制定。这个特性的值应该是能够执行的JavaScript代码。</li><li>在HTML中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面中其他地方定义的脚本。</li></ul><p><strong>独到之处</strong>：</p><ol><li>会创建一个封装着元素属性值的函数。这个函数有一个局部变量<code>event</code>，也就是<strong>事件对象</strong>。通过<code>event</code>变量，可以直接访问事件对象，不用自己定义，也不用从函数的参数列表中读取。</li><li>在这个函数内部，<code>this</code>的值等于事件的<strong>目标元素</strong>。</li><li>拓展作用域的方式</li></ol><p><strong>缺点</strong>：</p><ol><li>存在一个时差问题，因为用户可能会在HTML元素一出现在页面上就触发相应的事件，但当时的事件处理程序有可能尚不具备执行条件。<strong>为此，很多HTML事件处理程序都会被封装在一个<code>try-catch</code>块中，以便错误不会浮出水面。</strong></li><li>这样拓展事件处理程序的作用域链在不同浏览器中会导致不同结果。</li><li><strong>HTML与JavaScript代码紧密耦合。</strong></li></ol><h3 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Clicked"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>将一个函数赋值给一个事件处理程序属性这种传统方法依然被所有现代浏览器所支持的原因是：简单、跨浏览器优势。</li><li>我们首先要做的就是必须取得一个要操作的对象的引用。</li><li>每个元素（包括window和document）都有自己的事件处理程序属性，将这种属性的值设为一个函数，就可以指定事件处理程序。</li></ul><p><strong>【注意】</strong>：</p><ol><li>使用DOM0级事件方法指定的事件处理程序被认为是<strong>元素的方法</strong>。因此，这时候的事件处理程序是在<strong>元素的作用域</strong>中运行，即<strong>程序中的<code>this</code>引用当前元素。</strong></li><li>可以在事件程序中通过<code>this</code>访问元素的任何属性和方法。</li><li>以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。</li><li>可以通过将事件处理程序设置为<code>null</code>来删除DOM0级方法指定的事件处理程序</li></ol><h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">btn.removeEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"this.id"</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li>DOM2级事件定义了两个方法，用于指定和删除事件处理程序的操作：<code>addEventListener()</code>和<code>removeEventListener()</code>。所有DOM节点都包含这两个方法，并且它们都接受3个参数：<strong>要处理的事件名</strong>、<strong>作为事件处理程序的函数</strong>和<strong>一个布尔值</strong>。如果这个布尔值参数为<code>true</code>，表示在捕获阶段调用事件处理程序；为<code>false</code>表示在冒泡阶段调用事件处理程序。</li><li>与DOM0级方法一样，这里添加的事件处理程序也是<strong>在其依附的元素的作用域中运行</strong>。</li><li>使用这种方法的<strong>主要好处</strong>是可以添加多个事件处理程序，并且事件处理程序会按照添加它们的顺序触发。</li><li>通过传入<code>addEventListener()</code>添加的事件处理程序只能用<code>removeEventListener()</code>来移除；移除时传入的参数与添加处理程序时使用的参数相同。也意味着通过<code>addEventListener()</code>添加的匿名函数无法移除。比如上面的例子。</li></ul><h3 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;);</span><br><span class="line">btn.detachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"this.id"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>IE实现了和DOM中类似的两个方法: <code>attachEvent()</code>和<code>detachEvent()</code>。这两个方法接收两个参数：<strong>事件处理程序的名称</strong>和<strong>事件处理程序函数</strong>。通过<code>attachEvent()</code>添加的事件处理程序都会被添加到冒泡阶段。</li><li>在IE中使用<code>attachEvent()</code>与使用DOM0级方法的主要区别在于事件处理程序中的<strong>作用域</strong>。在使用DOM0级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用<code>attachEvent()</code>方法的情况下，事件处理程序会在全局作用域中运行，因此<code>this</code>等于<code>window</code>。</li><li><code>attachEvent()</code>也可以用来为一个元素添加多个事件处理程序。但以相反的顺序被触发。</li><li>使用 <code>attachEvent()</code>添加的事件可以通过<code>detachEvent()</code>来移除。条件是必须提供相同的参数。这意味着添加的匿名函数无法移除。</li></ul><h3 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(<span class="string">"on"</span>+type,handler);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">"on"</span>+type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler:<span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.removeEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( element.detachEvent)&#123;</span><br><span class="line">            element.detachEvent(<span class="string">"on"</span>+type,handler);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">"on"</span>+type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventUtil.addHandler(btn,<span class="string">"click"</span>,handler);</span><br></pre></td></tr></table></figure><h2 id="三、事件对象"><a href="#三、事件对象" class="headerlink" title="三、事件对象"></a>三、事件对象</h2><p>在触发DOM上某个事件时，会产生一个事件对象<code>event</code>，这个对象中包含所有与事件有关的信息。包括导致事件的元素，事件的类型以及其他与特定事件相关的信息。</p><h3 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h3><p>1.兼容DOM的浏览器会将一个<code>event</code>对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0级或DOM2级），都会传入<code>event</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(event.type); <span class="comment">//"click"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.在通过HTML特性指定事件处理程序时，变量<code>event</code>中保存着<code>event</code>对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click me"</span> <span class="attr">onclick</span>=<span class="string">"alert(event.type)"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以这种方式提供<code>event</code>对象，可以让HTML特性事件处理程序与JavaScript函数执行相同的操作。</p><p><code>event</code>对象中包含着与创建它的特定事件有关的属性和方法。</p><ul><li>在事件处理程序内部对象<code>this</code>始终等于<code>currentTarget</code>的值，而<code>target</code>则只包含事件的<strong>实际目标</strong>。</li><li>要阻止特定事件的默认行为，可以使用<code>preventDefault()</code>方法。</li><li>只有<code>cancelable</code>为<code>true</code>的事件，才可以使用<code>preventDefault()</code>方法</li><li><code>stopPropagation()</code>方法用于立即停止事件在DOM层次中的传播，即进一步取消事件的捕获或冒泡。</li><li>事件对象的<code>eventPhase</code>属性可以用来确定事件当前正位于事件流的哪个阶段。</li></ul><p><strong>只有在事件处理程序执行期间，<code>event</code>对象才会存在；一旦事件处理程序执行完成，<code>event</code>对象就会被销毁。</strong></p><h3 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h3><p><strong>情况1</strong>.DOM0级方法添加事件处理程序时，<code>event</code>对象作为<code>window</code>对象的一个属性存在。</p><p><strong>情况2.</strong>如果事件处理程序是使用<code>attachEvent()</code>添加的，那么就会有一个<code>event</code>对象作为参数传入事件处理程序函数中。</p><p><strong>情况3</strong>.如果通过HTML特性制定的事件处理程序，那么可以通过一个名叫event的变量来访问event对象。</p><p>IE的event对象也包含与创建它的事件相关的属性和方法：</p><ul><li><code>cancelBubble</code>属性  —–  取消冒泡</li><li><code>returnValue</code>属性  —– 取消事件的默认行为</li><li><code>srcElement</code>属性 —- 事件的目标</li><li><code>type</code>属性 — 事件的类型</li></ul><p><strong>因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。故而，最好还是使用<code>event.srcElement</code>比较保险。</strong></p><h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">...</span>)</span>&#123;...&#125;,</span><br><span class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event? event:<span class="built_in">window</span>.event;</span><br><span class="line">    &#125;,</span><br><span class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event.target||event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">     preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(event.preventDefault)&#123;</span><br><span class="line">             event.perventDefalut();</span><br><span class="line">         &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">             event.returnValue = <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     removeHandler:....</span><br><span class="line">     </span><br><span class="line">     stopPropagation:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(event.stopPropagation)&#123;</span><br><span class="line">             event.stopPropagation();</span><br><span class="line">         &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">             event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四、内存和性能"><a href="#四、内存和性能" class="headerlink" title="四、内存和性能"></a>四、内存和性能</h2><p>在JavaScript中，添加到页面上的事件处理程序数量直接关系到页面的整体运行性能。导致这一问题的原因有很多，首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的DOM访问次数，会延迟整个页面的交互就绪时间。</p><p><strong>事件委托</strong>就是解决方案，时间委托利用了事件冒泡，只指定一个事件处理程序就可以管理某一类的所有事件。<strong>使用事件委托，只需要在DOM树中尽量最高的层次上添加一个事件处理程序。</strong></p><p>内存中存有那些“过时不用”的“空事件处理程序”，也是造成web应用程序内存与性能问题的主要原因。在不需要的时候<strong>移除事件处理程序</strong>也是一种解决方案。</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><ul><li><a href="https://segmentfault.com/a/1190000005654451" target="_blank" rel="noopener">JS中事件冒泡与捕获</a></li><li>JavaScript高级程序设计</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JS事件&quot;&gt;&lt;a href=&quot;#JS事件&quot; class=&quot;headerlink&quot; title=&quot;JS事件&quot;&gt;&lt;/a&gt;JS事件&lt;/h1&gt;&lt;h2 id=&quot;一、-事件与事件流&quot;&gt;&lt;a href=&quot;#一、-事件与事件流&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Js 定时器</title>
    <link href="http://yoursite.com/2019/07/21/js%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2019/07/21/js定时器/</id>
    <published>2019-07-21T13:24:29.535Z</published>
    <updated>2019-07-21T13:24:11.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript定时器"><a href="#JavaScript定时器" class="headerlink" title="JavaScript定时器"></a>JavaScript定时器</h1><h2 id="一、什么是定时器"><a href="#一、什么是定时器" class="headerlink" title="一、什么是定时器"></a>一、什么是定时器</h2><p>JavaScript提供了一些原生的方法来实现延时去执行某一段代码，下面简单介绍一下：</p><p><code>setTimeout</code>:设置一个定时器，在定时器到期后执行一次函数或代码段，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeoutId = <span class="built_in">window</span>.setTimeout(func|code, delay);</span><br></pre></td></tr></table></figure><blockquote><ul><li>timeoutId: 定时器ID</li><li>func: 延迟后执行的函数</li><li>code: 延迟后执行的代码字符串，不推荐使用原理类似eval()</li><li>delay: 延迟的时间（单位：毫秒），默认值为0</li></ul></blockquote><p><code>setInterval</code>: 以固定的时间间隔重复调用一个函数或者代码段<a href="http://caibaojian.com/javascript-timer.html" target="_blank" rel="noopener">·</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var intervalId = window.setInterval(func|code, delay);</span><br></pre></td></tr></table></figure><blockquote><ul><li>intervalId: 重复操作的ID</li><li>func: 延迟调用的函数</li><li>code: 代码段</li><li>delay: 延迟时间，没有默认值</li></ul></blockquote><p>另外，还有两种不常见的定时器：<code>setImmediate</code>, <code>requestAnimationFrame</code>。</p><h2 id="二、定时器的工作原理以及不定时的原理"><a href="#二、定时器的工作原理以及不定时的原理" class="headerlink" title="二、定时器的工作原理以及不定时的原理"></a>二、定时器的工作原理以及不定时的原理</h2><blockquote><p>JavaScript是一个<strong>单线程的解释器</strong>，因此一定时间内只能执行一段代码。为了要控制执行的代码，就有一个JavaScript任务队列。这些任务会按照它们添加到队列的顺序执行。<code>setTimeout()</code>的第二个参数告诉JavaScript再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</p></blockquote><p><strong>【注意】</strong>：</p><ol><li>首先，<strong>JavaScript是以单线程的方式运行的</strong>。JavaScript的主要用途是与用户互动，以及操作DOM。若以多线程的方式，则可能出现冲突。假设有两个线程同时操作一个DOM元素，线程1要求浏览器删除DOM，而线程2却要求修改DOM样式，这时浏览器就无法决定采用哪个线程的操作。（但是JavaScript有个基于“Event Loop”并发的模型。&lt;此处不讨论。。&gt;）</li><li>js既然是单线程的，也就意味着所有任务需要排队。所有任务可以分成两种，一种是<strong>同步任务</strong>（synchronous），另一种是<strong>异步任务</strong>（asynchronous）<ul><li>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，形成了一个执行栈</li><li>异步任务指的是，不进入主线程，而进入”任务队列”（task queue）的任务。”任务队列”是一个事件的队列（可以当作消息的队列来理解）。IO设备完成一项任务or异步任务有了运行结果，就在”任务队列”中添加一个事件，表示相关的操作可以进入”执行栈”，就等着执行栈调用了。</li></ul></li><li><strong>因为<code>setTimeout</code>, <code>setInterval</code>是异步任务，调用之后不会直接进入执行栈，而是进入任务队列，所以只有等到当前执行栈没有其他操作，它们才会进入执行栈中执行，</strong> 以上就是为什么定时器<strong>不总是定时</strong>的原因了。</li><li>如果<code>delay</code>时间周期设为0，相当于一个插队操作</li></ol><h2 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h2><p>例1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a = <span class="literal">false</span>;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(a)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p><code>console.log(a)</code>永远不会执行,因为JavaScript是单线程的，且定时器的回调将在等待当前正在执行的任务完成后才执行，而<code>while(a){}</code>直接进入了死循环，一直占用线程，不会给回调函数执行机会。</p><p>例2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码会输出<code>5 5 5 5 5</code>。当<code>i = 0</code>时，生成一个定时器，将回调函数插入到事件队列中，等待当前队列中无任务执行时立即执行，而此时<code>for</code>循环正在执行，所以回调被搁置。当for循环执行完之后，队列中存在5个回调函数，它们都将执行<code>console.log(i)</code>的操作，因为当前JS代码中并没有使用块级作用域，所以<code>i</code>的值在<code>for</code>循环结束后一直为5.</p><p>例3：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    msg: <span class="string">'obj'</span>,</span><br><span class="line">    shout: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.msg);</span><br><span class="line">    &#125;,</span><br><span class="line">    waitAndShout: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.shout();</span><br><span class="line">        &#125;, <span class="number">0</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.waitAndShout();</span><br></pre></td></tr></table></figure><p>这个问题涉及到了<code>this</code>的指向问题，由<code>setTimeout()</code>调用的代码运行在与与所在函数完全分离的执行环境上。这会导致这些代码中包含的<code>this</code>关键字会指向<code>window</code>（或全局）对象，<code>window</code>对象中并不存在<code>shout</code>方法，所以就会报错。</p><p>可以这样修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    msg: <span class="string">'obj'</span>,</span><br><span class="line">    shout: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.msg);</span><br><span class="line">    &#125;,</span><br><span class="line">    waitAndShout: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">//这里将this赋给一个变量</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            self.shout();</span><br><span class="line">        &#125;, <span class="number">0</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.waitAndShout();</span><br></pre></td></tr></table></figure><h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><ol><li>我们可以使用<code>clearTimeout()</code>和<code>clearInterval()</code>方法来取消定时器</li><li>对于<code>setTimeout(f, 0)</code>指定时间为0，并不是说回调函数<code>f</code>会马上执行，而是会在下一轮事件循环一开始就执行。</li><li>在使用超时调用时，没必要跟踪超时调用ID，因为每次执行代码之后，如果不再设置另一次超时调用，调用就会自行停止。</li><li>最好不要使用间歇调用</li></ol><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><ul><li><p>《JavaScript高级程序设计》第三版</p></li><li><p>MDN</p></li><li><p><a href="http://caibaojian.com/javascript-timer.html" target="_blank" rel="noopener">JS 定时器的四种写法及简介</a></p></li><li><p><a href="https://javascript.ruanyifeng.com/advanced/timer.html#toc5" target="_blank" rel="noopener">定时器</a></p></li><li><p><a href="https://juejin.im/post/5acd8006f265da239236b172" target="_blank" rel="noopener">js定时器，你所要了解的那点事</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript定时器&quot;&gt;&lt;a href=&quot;#JavaScript定时器&quot; class=&quot;headerlink&quot; title=&quot;JavaScript定时器&quot;&gt;&lt;/a&gt;JavaScript定时器&lt;/h1&gt;&lt;h2 id=&quot;一、什么是定时器&quot;&gt;&lt;a href=&quot;#一
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计总结</title>
    <link href="http://yoursite.com/2019/07/19/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/07/19/JavaScript高级程序设计总结/</id>
    <published>2019-07-19T12:27:30.419Z</published>
    <updated>2019-07-19T12:24:27.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-JavaScript简介"><a href="#第1章-JavaScript简介" class="headerlink" title="第1章 JavaScript简介"></a>第1章 JavaScript简介</h1><h2 id="part-1-JavaScript基本概念"><a href="#part-1-JavaScript基本概念" class="headerlink" title="part 1 JavaScript基本概念"></a>part 1 JavaScript基本概念</h2><p>包括<strong>定义，组成部分，基本特点，日常用途，历史，特性，编程，版本，与其他语言的比较</strong>（<a href="https://baike.baidu.com/item/javascript" target="_blank" rel="noopener">参考</a>).</p><h2 id="part-2-组成部分"><a href="#part-2-组成部分" class="headerlink" title="part 2 组成部分"></a>part 2 组成部分</h2><ul><li>ECMAScript，由ECMA-262定义，提供JavaScript核心功能。</li><li>DOM(<strong>DOM级别</strong>)，提供访问和操作网页内容的方法和接口。</li><li>BOM（5个对象）（JS高程第八章），提供与浏览器交互的方法和接口。</li></ul><h1 id="第二章-在HTML中使用JavaScript"><a href="#第二章-在HTML中使用JavaScript" class="headerlink" title="第二章 在HTML中使用JavaScript"></a>第二章 在HTML中使用JavaScript</h1><p>主要注意点：</p><ul><li><code>&lt;script&gt;</code>的六个属性是什么以及各自的用途？</li><li>延迟脚本&amp;异步脚本各自的特点？</li><li>标签可以放在哪些位置？</li><li>当嵌入代码和外部文件同时存在于一个<code>&lt;script&gt;</code>标签里，会发生什么？</li><li>多个<code>&lt;script&gt;</code>存在于页面中时，它们的解析顺序？（注意延迟脚本和异步脚本的存在）</li><li>外部文件相对于嵌入代码有什么好处？</li><li>文档模式&amp;doctype？（混杂模式，标准模式，准标准模式，严格模式……）</li><li><code>&lt;noscript&gt;</code>标签解决了怎样的问题？</li></ul><h1 id="第三章-基本概念"><a href="#第三章-基本概念" class="headerlink" title="第三章 基本概念"></a>第三章 基本概念</h1><h2 id="part-1-基本语法"><a href="#part-1-基本语法" class="headerlink" title="part 1 基本语法"></a>part 1 基本语法</h2><ul><li>区分大小写</li><li>标识符是什么？标识符命名规则？</li><li>严格模式用在哪？怎么启用？有哪些特点？</li><li>关键字和保留字的区别？关键字和保留字分别有哪些？</li></ul><h2 id="part2-变量"><a href="#part2-变量" class="headerlink" title="part2 变量"></a>part2 变量</h2><ul><li>变量仅仅是一个用于保存值的占位符，变量可以用来保存任何值，未经初始化的变量的值为undefined</li><li>var、let、const的区别？</li></ul><h2 id="part-3-数据类型"><a href="#part-3-数据类型" class="headerlink" title="part 3 数据类型"></a>part 3 数据类型</h2><ul><li><p>基本数据类型有哪些，它们各自有哪些特点？</p></li><li><p><code>typeof</code>操作符有什么作用，它有哪些特点？</p></li><li><p>检测变量数据类型有哪些方法？</p></li><li><p>包含<code>undefined</code>值的变量和尚未定义的变量的区别？</p></li><li><p><code>undefined</code>与<code>null</code>的区别？</p></li><li><p>关于<code>Boolean()</code>函数转化（哪些转换为<code>true</code>，哪些转换为<code>false</code>）</p></li><li><p>JavaScript是如何储存数值的？为什么会出现 <code>0.1+0.2 != 0.3</code> 的情况? <a href="https://blog.csdn.net/u013347241/article/details/79210840" target="_blank" rel="noopener">参考</a></p></li><li><p>数值范围以及<code>isFinite()</code>函数</p></li><li><p><code>NaN</code>是什么，<code>isNaN()</code>函数</p></li><li><p>数值转换函数<code>Number()</code>,<code>parseInt()</code>,<code>parseFloat()</code>各自特点以及它们之间的区别？</p></li><li><p>转义序列是用来干嘛的？有哪些？</p></li><li><p>字符串又什么特点？（ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另外一个包含新值的字符串填充该变量）</p></li><li><p>转换为字符串方法<code>toString()</code>,<code>String()</code>的区别</p></li><li><p>Object类型所具有的的任何属性和方法同样存在于更具体的对象中。Object的每个实例都有这些属性和方法（<code>constructor</code>、<code>hasOwnProperty(propertyName)</code>、<code>isPrototypeOf(object)</code>、<code>propertyIsEnumerable(propertyName)</code>、<code>toLocaleString()</code>、<code>toString()</code>、<code>valueOf()</code>）</p></li><li><p><code>toLocaleString()</code>、<code>toString()</code>、<code>valueOf()</code>各自的功能以及它们的区别？</p></li></ul><h2 id="part-4-操作符"><a href="#part-4-操作符" class="headerlink" title="part 4 操作符"></a>part 4 操作符</h2><ul><li>++、–、+、- 对非数值应用时，会像Number()转型函数一样对这个值执行转换。</li><li>位操作（&amp;   |    ~   ^  &lt;&lt;  &gt;&gt;)的基本概念</li><li>左移位不会影响操作数的符号位；有符号右移，空位由符号位填充；无符号右移，空位由0填充。</li><li>布尔操作符（&amp;&amp;  ||  !）基本操作。</li><li>逻辑非会先把它的操作数强转为一个布尔值，然后再求反。逻辑与，逻辑或在有一个操作数不是布尔值的情况下，不一定返回布尔值，它们的规则是？(p45、p46)</li><li>关系操作符（&gt;, &lt; ,&lt;=, &gt;=…)的操作数使用了非数值时，要进行数据转换或完成某些操作，规则是怎样的？(p50)</li><li>相等和不相等——先转换再比较；全等和不全等——仅比较而不转换。相等和不相等操作符对操作数进行强制转型的规则是什么？（p51)</li></ul><h2 id="part-5-语句"><a href="#part-5-语句" class="headerlink" title="part 5 语句"></a>part 5 语句</h2><ul><li><p>if语句、do-while语句、while语句、for语句、<strong>for-in语句</strong>、<strong>label语句</strong>、break和continue语句、<strong>with语句</strong>、switch语句</p></li><li><p>for-in语句是一种精准的迭代语句，可以用来枚举对像的属性。语法：<code>for (property in expression) statement</code>。ECMAScript对象的属性没有顺序，因此，通过for-in循环输出的属性名的顺序是不可预测的。但是，如果表示要迭代的对象的变量值为null或undefined，for-in语句会抛出错误。</p></li><li><p>label语句可以在代码中添加标签，以便将来使用。语法：<code>label: statement</code>。</p></li><li><p>break和continue语句都可以和label语句联合使用，从而返回代码中特定的位置。例</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span> &amp;&amp; j==<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span> outermost;<span class="comment">//①添加这个标签的结果导致break语句不仅会退出内部的for语句，而且与会退出外部的for语句。</span></span><br><span class="line">            <span class="comment">//continue outermost; //退出内部循环，执行外部循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">conslole.log(num); <span class="comment">//①55 ②95</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="part-6-函数"><a href="#part-6-函数" class="headerlink" title="part 6 函数"></a>part 6 函数</h2><ul><li>return 语句可以不带有任何返回值。在这种情况下，函数停止执行后将返回undefined值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。</li><li>ECMAScript中的参数在内部都是用一个数组来表示的。函数接收到的始终是这个数组，而不关心数组中包含哪些参数。函数体内的argument对象可以访问这个参数数组，从而获取传递给函数的每一个参数。</li><li>命名的参数只提供便利，但不是必需的。ECMAScript中也没有函数签名的概念，因为其函数参数是一个包含0个或多个值的数组的形式传递的。</li><li>argument对象可以与命名参数一起使用。argument对象的值永远与对应命名参数的值保持同步。虽然值保持同步，但它们的内存空间是独立的。</li><li>没有传递值的命名参数自动被赋予undefined值。</li><li>由于不存在函数签名的特性，ECMAScript函数不能重载。</li></ul><h1 id="第四章-变量、作用域、内存问题"><a href="#第四章-变量、作用域、内存问题" class="headerlink" title="第四章 变量、作用域、内存问题"></a>第四章 变量、作用域、内存问题</h1><h2 id="part-1-引用类型和基本类型的值"><a href="#part-1-引用类型和基本类型的值" class="headerlink" title="part 1 引用类型和基本类型的值"></a>part 1 引用类型和基本类型的值</h2><ul><li>引用类型、基本类型是什么？它们有哪些异同？</li><li>定义基本类型和引用类型的值的方式是类似的：创建一个变量并为该变量赋值。但对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。</li><li>复制：①基本类型：两者是完全独立的，相当于创建了一个副本。②引用类型：副本实际是一个指针，指针指向存储在堆中的一个对象。复制结束后，两者实际引用同一个对象。</li><li>传递参数：所有函数的参数都是按值传递的！</li></ul><h2 id="part-2-执行环境和作用域"><a href="#part-2-执行环境和作用域" class="headerlink" title="part 2 执行环境和作用域"></a>part 2 执行环境和作用域</h2><ul><li>执行环境、作用域、作用域链这些是什么？</li><li>怎么延长作用域链？</li><li>关于没有块级作用域怎么理解？</li><li>作用域的类型有哪些？</li></ul><h2 id="part-3-垃圾收集"><a href="#part-3-垃圾收集" class="headerlink" title="part 3 垃圾收集"></a>part 3 垃圾收集</h2><ul><li>为什么需要进行垃圾收集？</li><li>垃圾收集的方式有哪些以及它们的原理？（标记清除&amp;引用计数）</li><li>当代码中存在循环引用现象时，“引用计数”算法就会导致问题，问题是什么？如何解决？</li><li>解除引用是什么？它有哪些好处？</li></ul><h1 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h1><ul><li>引用类型是什么？引用类型的值（对象）是什么？</li></ul><h2 id="part-1-Array类型"><a href="#part-1-Array类型" class="headerlink" title="part 1 Array类型"></a>part 1 Array类型</h2><p>数组的每一项都可以保存任何类型的数据。数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数组。</p><ul><li><p>创建数组的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Array()构造函数</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"black"</span>);</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Array</span>(<span class="number">3</span>);<span class="comment">//在使用Array构造函数时也可以省略new操作符</span></span><br><span class="line"><span class="comment">//使用字面量表示法【与对象一样，在使用数组字面量表示法时，也不会调用Array构造函数。</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"black"</span>];</span><br></pre></td></tr></table></figure></li><li><p>检测数组的方法有哪些？</p></li><li><p>数组有哪些方法？（转换方法、栈方法、队列方法、重排序方法、操作方法&lt;创建、切片、删除、插入、替换&gt;、位置方法、迭代方法、归并方法）</p></li><li><p>sort()方法需要注意的问题。sort()方法接受的比较函数是怎样的？实现的原理是什么？</p></li><li><p>splice()方法如何实现删除、插入、替换操作？</p></li><li><p>every()、some()、map()、filter()、forEach()的区别？</p></li><li><p>归并数组方法reduce()和reduceRight()是怎么操作的？</p></li></ul><h2 id="part-2-Date类型"><a href="#part-2-Date类型" class="headerlink" title="part 2 Date类型"></a>part 2 Date类型</h2><p>Date类型使用UTC(国际协调时间)1970年1月1日零时开始经过的毫秒数来保存日期。</p><ul><li><p>创建日期对象<code>var now = new Date(); //自动获取当前时间和日期</code></p></li><li><p>如果想根据特定时间和日期创建日起对象。必须穿入该日期的毫秒数，<code>Date.parse()</code>, <code>Date.UTC()</code>可简化这个过程。两个方法接收的参数有一定的规则。</p></li><li><p>例：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someDay = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"May 25, 2004"</span>));</span><br><span class="line"><span class="keyword">var</span> someDay = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"May 25, 2004"</span>);<span class="comment">//后台自动调用Date.parse()方法</span></span><br><span class="line"><span class="keyword">var</span> someDay = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">55</span>,<span class="number">55</span>));</span><br></pre></td></tr></table></figure><ul><li><p>Date.now()方法，返回表示调用这个方法的日期和时间的毫秒数。使用+操作符也可获取Date对象的时间戳。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="comment">//var start = +new Date();</span></span><br><span class="line">doSomething();</span><br><span class="line"><span class="keyword">var</span> stop = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="comment">//var stop = +new Date();</span></span><br><span class="line">result = stop-start;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Date类型继承的toString()、toLocaleStirng、valueOf()方法的区别？</p></li><li><p>日期格式化有哪些方法？</p></li><li><p>日期/时间组件的方法有哪些？</p><h2 id="part-3-RegExp类型"><a href="#part-3-RegExp类型" class="headerlink" title="part 3 RegExp类型"></a>part 3 RegExp类型</h2><h2 id="part-4-Function类型"><a href="#part-4-Function类型" class="headerlink" title="part 4 Function类型"></a>part 4 Function类型</h2></li></ul><p>函数实际上是对象，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上是一个指向函数对象的指针。使用不带圆括号的函数名是访问函数指针，而非调用函数！</p><p>函数名本身就是变量，所以函数也可以通过作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。</p><ul><li>理解函数为什么没有重载？</li><li>函数提升是什么？</li><li>函数内部的两个特殊对象：argument和this分别是什么？</li><li>argument对象的callee属性有什么用？（callee属性是一个指针，指向拥有这个argument对象的函数。）</li><li>函数的另一个对象属性caller是什么？它有什么用？（caller属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null）。</li><li>函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。length属性标识函数希望接收的命名参数的个数。</li><li>对于EMCAScript引用类型而言，prototype是保存它们所有实例和方法的真正所在。换句话说，诸如toString(),valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。prototype属性是不可枚举的，因此使用for-in无法发现。</li><li>每个函数都包含两个非继承而来的方法：apply()和call()。它们的用途是什么？它们两个的区别是什么？它们的适用情况？</li><li>bind()方法是什么？</li></ul><h2 id="part-5-基本包装类型"><a href="#part-5-基本包装类型" class="headerlink" title="part 5 基本包装类型"></a>part 5 基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean,Number和String。这些类型和其他引用类型相似，但同时也有各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象。</p><p>引用类型和基本包装类型的主要区别就是<strong>对象的生存期</strong>。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。</p><p>Object构造函数会根据传入值的类型返回相应基本包装类型的实例。把字符串传给Object构造函数，就会创建String的实例；传入数值参数会得到Number的实例；传入布尔值参数就会得到Boolean的实例。</p><p>注意：使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Number</span>(a);<span class="comment">//转型函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b);<span class="comment">//"number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Number</span>(a);<span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c);<span class="comment">//"object"</span></span><br></pre></td></tr></table></figure><h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><ul><li>创建Boolean对象：<code>var a = new Boolean(ture)</code></li><li>Boolean类型改写了toString()、valueOf()方法</li><li>布尔表达式中所有对象都会被转换为true</li></ul><h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><ul><li>重写后的valueOf方法返回对象表示的基本类型的数值</li><li>创建：<code>var a = new Nubmer(10);</code></li><li>toString() toFixed() toExponential() toPrecision()方法</li></ul><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><ul><li>创建：<code>var s = new String(&quot;Hello world&quot;);</code></li><li>方法: 字符方法、字符串操作方法、字符串位置方法、trim()方法、字符串大小写转换方法、字符串模式匹配方法、localeCompare()方法、fromCharCode()方法</li></ul><h2 id="part-6-单体内置对象"><a href="#part-6-单体内置对象" class="headerlink" title="part 6 单体内置对象"></a>part 6 单体内置对象</h2><p>内置对象的定义：由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。</p><h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><p>不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。</p><ul><li>URI编码方法</li><li>eval()方法</li><li>Global对象的属性</li><li>window对象</li></ul><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><ul><li>Math对象的属性有哪些？</li><li>min()和max()方法</li><li>舍入方法</li><li>random()方法</li><li>其他方法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第1章-JavaScript简介&quot;&gt;&lt;a href=&quot;#第1章-JavaScript简介&quot; class=&quot;headerlink&quot; title=&quot;第1章 JavaScript简介&quot;&gt;&lt;/a&gt;第1章 JavaScript简介&lt;/h1&gt;&lt;h2 id=&quot;part-1-Ja
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>作用域</title>
    <link href="http://yoursite.com/2019/07/19/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/07/19/作用域/</id>
    <published>2019-07-19T11:45:44.680Z</published>
    <updated>2019-07-19T12:22:07.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h2><p>作用域是代码在运行时，某些特定部分中的变量，函数，和对象的可访问性。作用域负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。换句话说，作用域决定了变量和函数的可访问范围，即<strong>作用域控制着变量和函数的可见性和生命周期</strong>。</p><h2 id="JavaScript中的作用域"><a href="#JavaScript中的作用域" class="headerlink" title="JavaScript中的作用域"></a>JavaScript中的作用域</h2><ul><li>全局作用域</li><li>局部作用域</li></ul><p>如果一个变量在函数外或者大括号<code>{}</code>外声明的，那么就定义了一个<strong>全局作用域</strong>；在ES6之前局部作用域只包含了函数作用域，ES6为我们提供了<strong>块级作用域</strong>，也属于<strong>局部作用域。</strong></p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p><strong>拥有全局作用域的对象可以在代码的任何地方访问到。</strong></p><p>以下情形拥有全局作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;           <span class="comment">//①最外层变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;     <span class="comment">//②最外层函数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a = <span class="number">3</span>;   <span class="comment">//③未经定义直接赋值的变量（由于变量提升使之成为全局变量）</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.a = <span class="number">5</span>;  <span class="comment">//④通过window来添加一个全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p><strong>局部作用域一般只能在固定代码片段中可以访问到。最常见的为函数作用域</strong></p><h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><blockquote><p>定义在函数中的变量就在函数作用域中。并且函数在每次调用时都有一个不同的作用域。这意味着<strong>同名变量可以用在不同的函数中</strong>。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。</p></blockquote><p>函数作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">5</span>;    <span class="comment">//局部变量，【注意】：不能省略var，否则会因为变量提升成为全局变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//函数内可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//函数外不可访问</span></span><br></pre></td></tr></table></figure><p>块级作用域测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">   <span class="keyword">var</span> num+=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//3 ---此处for语句块内部与外面是同一个作用域</span></span><br></pre></td></tr></table></figure><h4 id="关于变量提升"><a href="#关于变量提升" class="headerlink" title="关于变量提升"></a>关于变量提升</h4><blockquote><p> 在Javascript中，函数及变量的声明都将被提升到函数的最顶部，也就是说我们可以先使用后声明,但函数表达式和变量表达式只是将函数或者变量的声明提升到函数顶部，函数表达式和变量的初始化将不被提升</p></blockquote><p>变量提升的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp);<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp=<span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【注意】这里申明提升了，定义的内容并不会提升</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        tmp=<span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在重复声明的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//3</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">4</span>;  <span class="comment">//此处声明会被忽略！！！仅用于赋值！</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//4</span></span><br><span class="line"><span class="comment">//【注意】在同一作用域用var声明变量多次，后面的var声明会被忽略</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//3</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    a = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>变量和函数同时提升：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//[Function: a]</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//函数声明形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="comment">//函数表达式形式</span></span><br></pre></td></tr></table></figure><p>情况二就相当于重复声明的例子，容易理解。对于情况一，其等价形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>函数声明被提升到最顶上；</li><li>申明只进行一次，因此后面<code>var a = 1</code>的申明会被忽略。</li><li><strong>函数申明的优先级优于变量申明，且函数声明会连带定义一起被提升</strong>（这里与变量不同）</li></ul><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><blockquote><p>ES6新增了<code>let</code>和<code>const</code>命令，可以用来创建<strong>块级作用域变量</strong>，使用<code>let</code>命令声明的变量只在<code>let</code>命令所在<strong>代码块</strong>内有效。</p></blockquote><p>使用<code>let</code>声明变量，会将变量的作用域限制在当前代码块中。特点：</p><ul><li>变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量</li><li>不允许反复声明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//error</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;<span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><h3 id="关于编译原理"><a href="#关于编译原理" class="headerlink" title="关于编译原理"></a>关于编译原理</h3><p><img src="/.com//%E4%BD%9C%E7%94%A8%E5%9F%9F%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.PNG" alt="编译原理"></p><p>传统编译语言流程：</p><ol><li>分词/词法解析：这个过程会由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元（token）。例如：<code>var a = 2;</code>通常被分解为：var、a、=、2、; 。</li><li>解析/语法分析：这个过程将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个数被抽象为“抽象语法树”（AST)。</li><li>代码生成。将AST转换为可执行的过程被称为代码生成。</li></ol><p>JavaScript编译过程不同之处：</p><ul><li><code>JavaScript</code> 大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内</li><li><code>JavaScript</code> 引擎用尽了各种办法(比如 <code>JIT</code>，可以延 迟编译甚至实施重编译)来保证性能最佳</li></ul><h3 id="JavaScript是如何执行的"><a href="#JavaScript是如何执行的" class="headerlink" title="JavaScript是如何执行的"></a>JavaScript是如何执行的</h3><p>! <a href="作用域\JavaScript编译过程.PNG">JavaScript编译过程</a></p><ul><li>核心重点：变量和函数在内的所有声明都会在任何代码被执行前首先被处理。</li><li>函数运行的瞬间，创建一个<strong>AO</strong> (Active Object 活动对象)运行载体。</li></ul><h3 id="作用域链是什么？"><a href="#作用域链是什么？" class="headerlink" title="作用域链是什么？"></a>作用域链是什么？</h3><p><strong>JavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到window（全局作用域）。而这一条形成的“AO链” 就是JavaScript中的作用域链。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>《你不知道的JavaScript》上卷</li><li><a href="https://segmentfault.com/a/1190000019783405" target="_blank" rel="noopener">深入理解JavaScript</a></li><li><a href="https://www.jianshu.com/p/0c69c777e0a4" target="_blank" rel="noopener">javascript作用域</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h1&gt;&lt;h2 id=&quot;什么是作用域？&quot;&gt;&lt;a href=&quot;#什么是作用域？&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域？
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>js的new操作符</title>
    <link href="http://yoursite.com/2019/07/17/js%E7%9A%84new%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/07/17/js的new操作符/</id>
    <published>2019-07-17T07:08:13.473Z</published>
    <updated>2019-07-17T08:46:06.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js的new操作符"><a href="#js的new操作符" class="headerlink" title="js的new操作符"></a>js的new操作符</h1><p>我们先来了解一下<code>new</code>运算符的基本概念：</p><p><code>new</code><strong>运算符</strong>创建一个用户自定义的对象类型的实例或具有构造函数的内置对象的实例。<code>new</code>关键字会进行如下操作：</p><ol><li>先创建一个新的空的简单JavaScript对象（即<code>{}</code>）</li><li>然后让这个空对象的<code>_proto_</code>指向函数的原型<code>prototype</code></li><li>将步骤1创建的对象作为<code>this</code>的上下文（将对象作为函数的this传进去）</li><li>如果该函数没有返回对象，则返回<code>this</code></li></ol><p>再来看一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>);</span><br><span class="line"><span class="keyword">var</span> person1 = Person(<span class="string">"Tom"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">//Person &#123; name: 'Tom' &#125;（返回的是构造函数实例化后的对象）</span></span><br><span class="line"><span class="built_in">console</span>.log(person1);<span class="comment">//Tom</span></span><br></pre></td></tr></table></figure><p>可以看到，有<code>new</code>和没<code>new</code>的区别所在，现在分析一下<code>new</code>做了什么</p><p>当代码<code>new Person(...)</code>执行时，会发生以下事情：</p><ol><li>一个继承自<code>Person.prototype</code>的新对象被创建</li><li>使用参数<code>Tom</code>调用构造函数<code>Person</code>，并将<code>this</code>绑定到新创建的对象。</li><li>由构造函数<code>Person</code>返回的对象就是 <code>new</code> 表达式的结果（即构造函数实例化后的对象）。</li></ol><p>那要是构造函数返回的是一个对象呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">name</span> : <span class="string">"Gates"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>); <span class="comment">//Person&#123; name: 'Gates'&#125;</span></span><br><span class="line"><span class="keyword">var</span> person1 = Person(<span class="string">"Tom"</span>);<span class="comment">//Person&#123; name: 'Gates'&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，当函数返回的是对象时，则返回的即为该对象。</p><p>可是，当构造函数返回null，undefined等非对象时，情况又是什么样的？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>); <span class="comment">//Person&#123; name: 'Tom'&#125;</span></span><br><span class="line"><span class="keyword">var</span> person1 = Person(<span class="string">"Tom"</span>);<span class="comment">//null</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>return null</code>时（当使用<code>new</code>操作符）返回的也是构造函数实例后的对象。这是因为<code>null、undefined</code>为非对象，所以<code>return</code>的其实为<code>this</code></p><p>那，要是没有<code>return</code>语句呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>); <span class="comment">//Person&#123; name: 'Tom'&#125;</span></span><br><span class="line"><span class="keyword">var</span> person1 = Person(<span class="string">"Tom"</span>); <span class="comment">//Undefined</span></span><br></pre></td></tr></table></figure><p>其实，如果在JavaScript没有<code>return</code>语句，那么函数就会默认<code>return this</code></p><p>所以，我们可以得出结论：当我们使用了<code>new</code>操作符时，<strong>①构造函数如果没有返回对象，那么这个返回值毫无意义；②构造函数如果返回值为对象，那么这个返回值会被正常使用</strong></p><p>接下来，我们再看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//Tom</span></span><br><span class="line">person.sayName();  <span class="comment">//Tom</span></span><br></pre></td></tr></table></figure><p>从这里，我们可以看出<code>new</code>操作符的一些作用：</p><ul><li><strong><code>new</code> 通过构造函数<code>Person</code> 创建出来的实例可以访问到构造函数中的属性</strong></li><li><strong><code>new</code> 通过构造函数<code>Person</code> 创建出来的实例可以访问到构造函数原型链中的属性，也就是说通过 new 操作符，实例与构造函数通过原型链连接了起来</strong></li></ul><p>最后，我们可以自己尝试模拟实现<code>new</code>运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123; <span class="comment">//(Con, ...args)函数接收不定量的参数，第一个参数为构造函数，接下来的参数被构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; <span class="comment">//内部创建一个空对象obj</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj._proto_ = Con.prototype;</span><br><span class="line">    <span class="comment">//将新对象的内部属性__proto__指向构造函数的原型，这样新对象就可以访问原型中的属性和方法。等同于Object.setPrototypeOf(obj, Con.prototype);</span></span><br><span class="line"><span class="keyword">var</span> result = Con.apply(obj, <span class="built_in">arguments</span>);<span class="comment">//使用apply，将构造函数中的this指向新对象，这样新对象就可以访问构造函数中的属性和方法；将obj对象绑定到构造函数上，并且传入剩余参数</span></span><br><span class="line"><span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj;<span class="comment">//判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 obj，这样就实现了忽略构造函数返回的原始值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = objectFactory(Person, <span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><p>参考资料：</p><ul><li><p>MDN文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new</a></p></li><li><p>通过例子深入了解new：<a href="https://www.cnblogs.com/shuaihan/p/7392771.html" target="_blank" rel="noopener">https://www.cnblogs.com/shuaihan/p/7392771.html</a></p></li><li><p>一道面试题引发的思考：<a href="https://juejin.im/post/5c1bbc16e51d4552e01a0114" target="_blank" rel="noopener">https://juejin.im/post/5c1bbc16e51d4552e01a0114</a></p></li><li><p>聊聊new操作符：<a href="https://juejin.im/post/5c7b963ae51d453eb173896e" target="_blank" rel="noopener">https://juejin.im/post/5c7b963ae51d453eb173896e</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;js的new操作符&quot;&gt;&lt;a href=&quot;#js的new操作符&quot; class=&quot;headerlink&quot; title=&quot;js的new操作符&quot;&gt;&lt;/a&gt;js的new操作符&lt;/h1&gt;&lt;p&gt;我们先来了解一下&lt;code&gt;new&lt;/code&gt;运算符的基本概念：&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>HTML、CSS面试</title>
    <link href="http://yoursite.com/2019/07/15/HTML%E3%80%81CSS%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/07/15/HTML、CSS面试/</id>
    <published>2019-07-15T03:09:04.945Z</published>
    <updated>2019-07-17T08:52:34.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-了解什么是Web"><a href="#1-了解什么是Web" class="headerlink" title="1.了解什么是Web"></a>1.了解什么是Web</h2><p>   web即全球广域网，也称万维网。它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。它有三种表现形式：超文本、超媒体、超文本协议。</p><h2 id="2-HTML是什么，HTML5是什么"><a href="#2-HTML是什么，HTML5是什么" class="headerlink" title="2.HTML是什么，HTML5是什么"></a>2.HTML是什么，HTML5是什么</h2><p>   HTML  不是一门编程语言，而是一种用来告知浏览器如何组织页面的标记语言。它用来构造一个网页的基本骨架，由一系列的元素组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。 </p><p>   html5是html的最新标准。</p><h2 id="3-HTML元素标签、属性都是什么概念？"><a href="#3-HTML元素标签、属性都是什么概念？" class="headerlink" title="3.HTML元素标签、属性都是什么概念？"></a>3.HTML元素标签、属性都是什么概念？</h2><h3 id="一：标签"><a href="#一：标签" class="headerlink" title="一：标签"></a>一：标签</h3><p>   标签用来标记内容块，也用来标明元素内容的意义，标签使用尖括号包围，如<html>和</html>，这两个标签表示一个HTML文档。<br>   标签有两种形式：成对出现的标签和单独出现的标签<br>   1、成对出现的标签<br>   成对出现的标签包括开始标签和结束标签，&lt;开始标签&gt;内容&lt;/结束标签&gt;<br>   所谓开始标签，及标志一段内容的开始，例如：<br>   <code>&lt;html&gt;</code>表示HTML文档开始了；到<code>&lt;/html&gt;</code>结束，从而形成一个HTML文档。<br>   <code>&lt;head&gt;</code>和<code>&lt;/head&gt;</code>标签描述HTML文档的相关信息，之间的内容不会在浏览器窗口上显示出来<br>   <code>&lt;body&gt;</code>和<code>&lt;/body&gt;</code>标签包含所有要在浏览器窗口上显示的内容，也就是HTML文件的主体部分。<br>   所谓结束标签，是指和开始标签相对的标签。结束标签比开始标签多一个斜杠”/“。<br>   2、单独出现的标签<br>   虽然并不是所有的开始标签都必须有结束标签对应<code>&lt;br&gt;&lt;hr&gt;&lt;img&gt;&lt;input&gt;&lt;link&gt;&lt;meta&gt;</code>等<br>   3、标签的嵌套<br>   标签可以放在另外一个标签所能影响的片段中，以实现对某一段文档的多重标签效果，但是要注意必须要正确嵌套。</p><h3 id="二：元素"><a href="#二：元素" class="headerlink" title="二：元素"></a>二：元素</h3><p>   标签是为一个元素的开始和结束做标记，网页内容是由元素组成的，一个元素通常由一个开始标签、内容、其他元素及一个结束标签组成。</p><p>   如<code>&lt;head&gt;和&lt;/head&gt;</code>是标签，但是下面的就是一个head元素：</p><p>   <code>&lt;head&gt;&lt;title&gt;HTML中的几个基本概念------标签、元素、属性&lt;/title&gt;&lt;/head&gt;</code></p><p>   其中<code>&lt;title&gt;&lt;/title&gt;</code>是标签，但</p><p> <code>&lt;title&gt;HTML中的几个基本概念------标签、元素、属性&lt;/title&gt;</code></p><p>   又是一个title元素，同时这个title元素又是嵌套在head元素中的另一个元素。</p><h3 id="三：属性"><a href="#三：属性" class="headerlink" title="三：属性"></a>三：属性</h3><p>与元素相关的特性叫做属性，可以为属性赋值，属性包含元素的额外信息，这些信息不会出现在实际的内容中<br>  ①：不定义属性值<br>  HTML规定属性也可以没有值<br>   浏览器会使用compact属性的默认值，但有的属性没有默认值，因此不能省略属性值。</p><h2 id="4-文档类型doctype是什么概念，起什么作用？"><a href="#4-文档类型doctype是什么概念，起什么作用？" class="headerlink" title="4.文档类型doctype是什么概念，起什么作用？"></a>4.文档类型doctype是什么概念，起什么作用？</h2><p>   !DOCTYPE ,是用来声明并帮助浏览器正确识别网页的最短有效声明。因为HTML发展至今有许多的不同版本，所以声明不同的文档类型可以让浏览器完全正确地显示出 HTML 页面。 </p><p>   DOCTYPE是docunment type（文档定义）的简写，用来说明web设计中所用的html或xhtml的类型，指出浏览器或者其他阅读程序按照什么样的规则集去解释文档中的标记.</p><h2 id="5-meta标签都用来做什么的？"><a href="#5-meta标签都用来做什么的？" class="headerlink" title="5.meta标签都用来做什么的？"></a>5.meta标签都用来做什么的？</h2><p>   meta标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。<br>   典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。<br>   meta标签始终位于 head 元素中。<br>   元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p><h2 id="6-Web语义化是什么，是为了解决什么问题"><a href="#6-Web语义化是什么，是为了解决什么问题" class="headerlink" title="6.Web语义化是什么，是为了解决什么问题"></a>6.Web语义化是什么，是为了解决什么问题</h2><p>   简单说来就是让机器可以读懂内容。由编写者对网页内容进行语义化主要可以让不同的人和机器对这段内容的作用和所属有清晰的认识，从而查看或者找到自己需要的内容</p><p>   Web语义化是指使用语义恰当的标签，使页面有良好的结构，页面元素有含义，能够让人和搜索引擎都容易理解。如果可以在合适的位置使用恰当的标签，那么写出来的页面语义明确，结构清晰，搜索引擎也可以认出哪些是页面重要内容，予以较高的权值。</p><p>   web语义化的好处</p><ol><li><p>去掉或者丢失样式的时候能够让页面呈现出清晰的结构</p></li><li><p>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</p></li><li><p>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</p></li><li><p>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p></li></ol><h2 id="7-链接是什么概念，对应什么标签？"><a href="#7-链接是什么概念，对应什么标签？" class="headerlink" title="7.链接是什么概念，对应什么标签？"></a>7.链接是什么概念，对应什么标签？</h2><p>   HTML 使用超级链接与网络上的另一个文档相连。对应a标签。</p><p>   超链接使互联网成为互联的网络。超链接使我们能够将我们的文档链接到任何其他文档（或其他资源），也可以链接到文档的指定部分，我们可以在一个简单的网址上提供应用程序（与必须先安装的本地应用程序或其他东西相比）。几乎任何网络内容都可以转换为链接，点击（或激活）超链接将使网络浏览器转到另一个网址（<a href="https://developer.mozilla.org/en-US/docs/Glossary/URL" target="_blank" rel="noopener">URL</a>）</p><h2 id="8-常用标签都有哪些，都适合用在什么场景"><a href="#8-常用标签都有哪些，都适合用在什么场景" class="headerlink" title="8.常用标签都有哪些，都适合用在什么场景"></a>8.常用标签都有哪些，都适合用在什么场景</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span> 用于超链接。<span class="tag">&lt; <span class="attr">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>some text<span class="tag">&lt;/ <span class="attr">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span> 用于一篇文章。<span class="tag">&lt; <span class="attr">article</span>&gt;</span>a self-contained article<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span> 用于页面的侧边栏。<span class="tag">&lt;<span class="name">aside</span>&gt;</span>some content<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span> 用于大段的引用内容。<span class="tag">&lt; <span class="attr">blockquote</span>&gt;</span>some big texts<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> 页面上显示的所有内容都被包含在<span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>里</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span> 用于显示一个按钮</span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span> 用于一包裹一段代码内容</span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span> 用于一个dl列表的某个dt名词的描述</span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span> 用于删除一些不需要的文字</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 用于包裹住一些其他的标签，制造一个容器</span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span> 用于制作一个名词和对应解释的列表</span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span> 用于一个dl列表的某个dt名词</span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span> 用于强调一些文本内容</span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span> 用于一张图表的说明文字</span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span> 用于一张图表</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> 用于包裹页面的底部内容</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span> 用于制作一个表单</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>-<span class="tag">&lt;<span class="name">h6</span>&gt;</span> 用于标记标题，从h1到h6重要性依次递减</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> 用于包裹页面的元数据，如<span class="tag">&lt;<span class="name">meta</span>&gt;</span>, <span class="tag">&lt;<span class="name">link</span>&gt;</span>, <span class="tag">&lt;<span class="name">title</span>&gt;</span>等</span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span> 用于包裹页面的头部内容</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> 整个 HTML 文档的根元素，包裹住其他所有的元素</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> &gt;</span> 用于嵌入另一个小页面到一个页面中</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span> 用于显示一张图片</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span> 用于显示一个表格输入控件</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span> 用于给一个表格输入控件打上一个标签，说明输入控件的作用</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> 用于<span class="tag">&lt;<span class="name">ul</span>&gt;</span>和<span class="tag">&lt;<span class="name">ol</span>&gt;</span>标签，代表一个列表项</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span> 用于链接外部CSS文件</span><br><span class="line"><span class="tag">&lt;<span class="name">mark</span>&gt;</span> 用于高亮显示某些文本</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span> 用于下达一些元数据指令，或者对页面进行说明</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span> 用于包裹住一个导航条的内容</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span> 用于制作一个有序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 用于显示一个段落</span><br><span class="line"><span class="tag">&lt;<span class="name">q</span>&gt;</span> 用于一小段引用文字</span><br><span class="line"><span class="tag">&lt; <span class="attr">script</span>&gt;</span> 用于一段JavaScript脚本代码，或者引入一个外部JavaScript脚本文件</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span> 用于包裹一部分有逻辑关第的页面内容</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span> 用于制作一个下拉列表选框</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span> 用于包裹住一小段文字，作为一个容器</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span> 用于着重强调重要的文本内容</span><br><span class="line"><span class="tag">&lt; <span class="attr">style</span>&gt;</span> 用于给页面元素加上样式</span><br><span class="line"><span class="tag">&lt; <span class="attr">table</span>&gt;</span> 用于制作一个表格</span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span> 用于表格里的主体部分</span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span> 用于表格里的某一个单元格</span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span> 用于制作一大块文本输入框</span><br><span class="line"><span class="tag">&lt;<span class="name">tfoot</span>&gt;</span> 用于表格里的底部</span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span> 用于表格里的表头的单元格</span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span> 用于表格里的表头</span><br><span class="line"><span class="tag">&lt;<span class="name">time</span>&gt;</span> 用于页面内容中的时间</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span> 用于显示整个页面的标题（显示在浏览器的tab上）</span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span> 用于标记表格里的一行</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> 用于制作一个无序列表</span><br></pre></td></tr></table></figure><h2 id="9-表单标签都有哪些，对应着什么功能，都有哪些属性"><a href="#9-表单标签都有哪些，对应着什么功能，都有哪些属性" class="headerlink" title="9.表单标签都有哪些，对应着什么功能，都有哪些属性"></a>9.表单标签都有哪些，对应着什么功能，都有哪些属性</h2><p>   表单元素是允许用户在表单中(比如:文本域,下拉列表,单选框,复选框等等)输入信息的元素，最主要的作用就是收集信息。表单元素是页面中不可缺少的元素。一般来说，表单包含如下几个部分：</p><ol><li><p>提示信息：表单中包含的说明性文字</p></li><li><p>表单控件：包含了具体的表单功能项</p></li><li><p>表单域：容纳所有表单控件和提示信息</p><p>常用的表单元素，包括：</p></li><li><p>form: 定义供用户输入的表单。</p></li><li><p>fieldset: 定义域。即输入区加有文字的边框。</p></li><li><p>legend：定义域的标题，即边框上的文字。</p></li><li><p>label：定义一个控制的标签。如输入框前的文字，用以关联用户的选择。</p></li><li><p>input: 定义输入域，常用。可设置type属性，从而具有不同功能。</p></li><li><p>textarea: 定义文本域(一个多行的输入控件)，默认可通过鼠标拖动调整大小。</p></li><li><p>button: 定义一个按钮。</p></li><li><p>select: 定义一个选择列表，即下拉列表。</p></li><li><p>option: 定义下拉列表中的选项。</p><p>接下来是对这些表单元素的具体分析。</p><p><code>&lt;form name=&quot;&quot; action=&quot;&quot; method=&quot;get&quot;&gt;……&lt;/form&gt;</code><br>name : 表单名称；action : 用来指定表单处理程序的位置（url）；method : 定义表单结果从浏览器传送到服务器的方式，默认为”get”（也可以是post）<br><code>&lt;input type=&quot;&quot; name=&quot;&quot; value=&quot;&quot; size=&quot;&quot;&gt;</code><br>name:控件名称；value:input控件默认文本值；size:input控件在页面中的显示宽度（必须是正整数）<br>input常用type属性如下：</p></li><li><p>text：单行文本输入框，可以通过正整数的size控制框长度。</p></li><li><p>password：密码输入框。</p></li><li><p>radio：单选按钮，同一组的单选按钮必须要有相同的name。</p></li><li><p>checkbox：复选框，同一组的单选按钮必须要有相同的name。</p></li><li><p>button：普通按钮。</p></li><li><p>submit：提交按钮，每出现一次，一个 Submit 对象就会被创建。</p></li><li><p>reset：重置按钮，会重置当前表单中全部的内容。</p></li><li><p>image：图像形式的提交按钮，写法是“”。</p></li><li><p>hidden：隐藏域，隐藏字段对于用户是不可见的。</p></li><li><p>file：文件域，用于文件上传。</p><p><code>&lt;selectt size=&quot;&quot; multiple=&quot;multiple&quot;&gt;</code><br><code>&lt;option hidden&gt;选项1&lt;/option&gt;</code><br>size：下拉菜单的可见选项数；multiple：多选。<br>在最新的html5中，有一些表单的新增属性，多用于js，如<br>datalist : 定义填写一个input时，提示几个option用于提示。可通过input的list特性与此元素作关联。<br>output : 表示计算的结果。可通过for特性与其它能够影响运算的元素（如input）作关联。<br>还有一些新增的type属性：</p></li><li><p>search：input会呈现为搜索框（与text类型的唯一区别在于当鼠标覆盖时尾部出现叉号可快速清除输入的内容）。</p></li><li><p>url：编辑url的控件，提交时换行符与首位的空格都将自动去除。</p></li><li><p>email：可输入一个邮件地址。</p></li><li><p>color : 选择颜色的控件。</p></li><li><p>date : 选择年月日的控件。<br>此外，还有time、datetime、datetime-local、month、week、number、range类型</p></li></ol><h2 id="10-ol-ul-li-dl-dd-dt等这些标签都适合用在什么地方，举个例子"><a href="#10-ol-ul-li-dl-dd-dt等这些标签都适合用在什么地方，举个例子" class="headerlink" title="10.ol, ul, li, dl, dd, dt等这些标签都适合用在什么地方，举个例子"></a>10.<strong>ol, ul, li, dl, dd, dt等这些标签都适合用在什么地方，举个例子</strong></h2><pre><code>ol为有序列表,即为一个需要排序的列表内容进行排列; （问路）ul为无序列表,即为一个需要列表但不需要排顺序的内容排列; （早点清单）li为列表的内容; dl为定义列表; dt为定义列表内的标题或项目名称; dd为定义定义列表中项目的描述(独白旁白)</code></pre><hr><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-CSS选择器类型、优先级"><a href="#1-CSS选择器类型、优先级" class="headerlink" title="1.CSS选择器类型、优先级"></a>1.<strong>CSS选择器类型、优先级</strong></h2><p> 　 1.标签选择器(如：body,div,p,ul,li)</p><p>　　2.类选择器(如：class=”head”,class=”head_logo”)</p><p>　　3.ID选择器(如：id=”name”,id=”name_txt”)</p><p>　　4.全局选择器(如：*号)</p><p>　　5.组合选择器(如：.head .head_logo,注意两选择器用空格键分开)</p><p>　　6.后代选择器 (如：#head .nav ul li 从父集到子孙集的选择器)</p><p>　　7.群组选择器 div,span,img {color:Red} 即具有相同样式的标签分组显示</p><p>　　8.继承选择器(如：div p,注意两选择器用空格键分开)</p><p>　　9.伪类选择器(如：就是链接样式,a元素的伪类，4种不同的状态：link、visited、active、hover。)</p><p>　　10.字符串匹配的属性选择符(^ $ *三种，分别对应开始、结尾、包含)</p><p>　　11.子选择器 (如：div&gt;p ,带大于号&gt;)</p><p>　　12.CSS 相邻兄弟选择器器 (如：h1+p,带加号+)  </p><p> <strong>总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</strong></p><h2 id="2-CSS继承，层叠，样式优先级机制"><a href="#2-CSS继承，层叠，样式优先级机制" class="headerlink" title="2.CSS继承，层叠，样式优先级机制"></a>2.<strong>CSS继承，层叠，样式优先级机制</strong></h2><p>当多个相互冲突的CSS声明应用于同一个元素时，CSS层叠算法会根据一定的机制，从最高权重到最低权重的顺序列出</p><p>在CSS中，每个CSS属性定义的概述都指出了这个属性是默认继承的还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算值。当元素的一个</p><p>继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值；当元素的一个非继承属性没有指定值时，则取属性的初始值。</p><h2 id="3-文本，边框，背景，行高等相关属性"><a href="#3-文本，边框，背景，行高等相关属性" class="headerlink" title="3.文本，边框，背景，行高等相关属性"></a>3.<strong>文本，边框，背景，行高等相关属性</strong></h2><p>border:1px solid red;</p><p>background-color: cornflowerblue;</p><p>background-image: url(‘1.jpg’);</p><p>background-repeat: no-repeat;(repeat:平铺满)</p><p>background-position: right(左右距离) top（上下距离）（20px 20px）;(横向：left center right)(纵向：top center bottom)</p><p>简写：&lt; body style=”background: 20px 20px no-repeat #ff4 url(‘1.jpg’)”&gt;</p><p>&lt; div style=”width: 300px;height: 300px;background: 20px 20px no-repeat #ff4 url(‘1.jpg’)”&gt;</p><h2 id="4-块状元素，内联元素和内联块状元素的概念"><a href="#4-块状元素，内联元素和内联块状元素的概念" class="headerlink" title="4.块状元素，内联元素和内联块状元素的概念"></a>4.<strong>块状元素，内联元素和内联块状元素的概念</strong></h2><p>块级元素特点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;、&lt;<span class="selector-tag">p</span>&gt;、&lt;<span class="selector-tag">h1</span>&gt;<span class="selector-tag">-</span>&lt;<span class="selector-tag">h6</span>&gt;、&lt;<span class="selector-tag">ol</span>&gt;、&lt;<span class="selector-tag">ul</span>&gt;、&lt;<span class="selector-tag">dl</span>&gt;、&lt;<span class="selector-tag">table</span>&gt;、&lt;<span class="selector-tag">address</span>&gt;、&lt;<span class="selector-tag">blockquote</span>&gt; 、&lt;<span class="selector-tag">form</span>&gt;</span><br></pre></td></tr></table></figure><p>1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。</p><p>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p><p>3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致）。默认高度等于子元素高度。父子均是块级元素时，子块的高度可能冲破父级的限制</p><p>内联元素特点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span>&gt;、&lt;<span class="selector-tag">span</span>&gt;、&lt;<span class="selector-tag">br</span>&gt;、&lt;<span class="selector-tag">i</span>&gt;、&lt;<span class="selector-tag">em</span>&gt;、&lt;<span class="selector-tag">strong</span>&gt;、&lt;<span class="selector-tag">label</span>&gt;、&lt;<span class="selector-tag">q</span>&gt;、&lt;<span class="selector-tag">var</span>&gt;、&lt;<span class="selector-tag">cite</span>&gt;、&lt;<span class="selector-tag">code</span>&gt;</span><br></pre></td></tr></table></figure><p>1.和其他内联元素都在一行上；</p><p>2.可以通过margin、padding来改变左右的距离，但不可以改变上下的距离，导致width、height、line-height失效或。可以使用border。</p><p>3.内联元素之间有空白区域，空白区域的形成是因为<span>之间有回车，在html中，空格、制表符、回车都属于空白符，多个空白符都会视为一个空格，空格的大小由父级<div>的font-size决定。注意：只有内联(内联块)与内联(内联块)之间的空白符才会形成一个空格，文本元素(除空白符)也是属于内联元素。常用解决方法，给<div>设置font-size: 0;，在<span>上把font-size设置回去</span></div></div></span></p><p>inline-block 元素特点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span>&gt;、&lt;<span class="selector-tag">input</span>&gt;</span><br></pre></td></tr></table></figure><p>1.和其他元素都在一行上；</p><p>2.元素的高度、宽度、行高以及顶和底边距都可设置。</p><p>3.它也会有元素间出现空白区域的问题</p><h2 id="5-盒模型的所有概念，学习如何计算各种盒模型"><a href="#5-盒模型的所有概念，学习如何计算各种盒模型" class="headerlink" title="5.盒模型的所有概念，学习如何计算各种盒模型"></a>5.<strong>盒模型的所有概念，学习如何计算各种盒模型</strong></h2><p>IE盒子：宽高包括padding和border</p><p>W3C盒子：宽高为content的宽高</p><p>如果想要切换盒模型也很简单，这里需要借助css3的<code>box-sizing</code>属性</p><blockquote><ul><li><code>box-sizing: content-box</code> 是W3C盒子模型</li><li><code>box-sizing: border-box</code>   是IE盒子模型</li></ul></blockquote><h2 id="6-position的相关知识，position有几种，absolute和relative的区别"><a href="#6-position的相关知识，position有几种，absolute和relative的区别" class="headerlink" title="6.position的相关知识，position有几种，absolute和relative的区别"></a>6.<strong>position的相关知识，position有几种，absolute和relative的区别</strong></h2><p><code>position: static | relative | absolute | fixed | sticky</code></p><ul><li><p><code>static</code></p><p>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code>属性无效</p></li><li><p><code>relative</code></p><p>​    该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative  对 table-*-group, table-row, table-column, table-cell, table-caption  元素无效。</p><p>​    相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移，<strong>未脱离文档流。（其他元素的位置不会受该元素的影响发生位置改变来弥补该元素偏移后剩下的空隙）</strong></p></li><li><p><code>absolute</code></p><p>不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并，<strong>脱离了文档流</strong>。</p></li><li><p><code>fixed</code></p><p>固定定位与绝对定位相似，但元素的包含块为 viewport 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。</p><p>不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。<code>fixed</code> 属性会创建新的层叠上下文。当元素祖先的 <code>transform</code>  属性非 <code>none</code> 时，容器由视口改为该祖先。</p></li><li><p><code>sticky</code>  </p><p>盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 <code>table 时</code>），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<code>position: sticky</code>对 <code>table</code> 元素的效果与 <code>position: relative</code>相同。</p><p>粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。</p></li></ul><h2 id="7-float的相关知识"><a href="#7-float的相关知识" class="headerlink" title="7.float的相关知识"></a>7.<strong>float的相关知识</strong></h2><p>float CSS属性指定一个元素应沿其容器的左侧或右侧放置，<strong>允许文本和内联元素环绕它</strong>。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性（与<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position#Absolute_positioning" target="_blank" rel="noopener">绝对定位</a>相反）。</p><blockquote><p>当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到<strong>另外一个浮动的元素</strong>。</p></blockquote><hr><p>对于浮动，需要了解的是：</p><p> *浮动会将元素从文档流中删除，他的空间会被其它元素补上。</p><p> *浮动的参数物是父元素，是在父元素这个容器中飘。</p><p> *为了清除浮动造成的对浮动元素之后元素的影响，我们在浮动元素之后加一个div，并将这个div的clear设置为both。</p><p> *如果两个元素都设置了浮动，则两个元素并不会重叠，第一个元素占据一定空间，第二个元素紧跟其后。如果不想让第二个元素紧跟其后，可以对第二个浮动的元素使用clear。</p><hr><p><strong>浮动元素</strong>是 <code>float</code> 的计算值非 <code>none</code> 的元素。</p><h2 id="8-基本的布局方式"><a href="#8-基本的布局方式" class="headerlink" title="8.基本的布局方式"></a>8.<strong>基本的布局方式</strong></h2><p>   固定布局、流式（百分比）布局、弹性布局、浮动布局、定位布局</p><h2 id="9-Grid-Flexbox等布局方式"><a href="#9-Grid-Flexbox等布局方式" class="headerlink" title="9.Grid,Flexbox等布局方式"></a>9.<strong>Grid,Flexbox等布局方式</strong></h2><p>   弹性布局是指通过调整其内元素的宽高，从而在任何显示设备上实现对可用显示空间最佳填充的能力。弹性容器扩展其内元素来填充可用空间，或将其收缩来避免溢出。</p><p>   这二者都是 CSS  工作组为在不同用户代理、不同书写模式和其他灵活性要求下的网页应用程序有更好的互操作性而做出的更广泛的努力的一部分。都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。flex主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。</p><p>   Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。</p><h2 id="10-神马圣杯布局、双飞翼布局都是些什么东西"><a href="#10-神马圣杯布局、双飞翼布局都是些什么东西" class="headerlink" title="10.神马圣杯布局、双飞翼布局都是些什么东西"></a>10.<strong>神马圣杯布局、双飞翼布局都是些什么东西</strong></h2><h2 id="11-强大的负外边距都能干嘛"><a href="#11-强大的负外边距都能干嘛" class="headerlink" title="11.强大的负外边距都能干嘛"></a>11.<strong>强大的负外边距都能干嘛</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">影响元素在文档流中的位置、增加元素宽度、对浮动元素的影响、对居中的影响</span><br></pre></td></tr></table></figure><h2 id="12-display的几个属性，及其区别"><a href="#12-display的几个属性，及其区别" class="headerlink" title="12.display的几个属性，及其区别"></a>12.<strong>display的几个属性，及其区别</strong></h2><ul><li>inline:<ol><li>使元素变成行内元素，拥有行内元素的特性，即可以与其他行内元素共享一行，不会独占一行. </li><li>不能更改元素的height，width的值，大小由内容撑开. </li><li>可以使用padding，margin的left和right产生边距效果，但是top和bottom就不行.</li></ol></li><li>block:<ol><li>使元素变成块级元素，独占一行，在不设置自己的宽度的情况下，块级元素会默认填满父级元素的宽度. </li><li>能够改变元素的height，width的值. </li><li>可以设置padding，margin的各个属性值，top，left，bottom，right都能够产生边距效果.</li></ol></li><li>inline-block:<ol><li>结合了inline与block的一些特点，结合了上述inline的第1个特点和block的第2,3个特点.</li></ol></li></ul><h2 id="13-display-none与visibility-hidden的区别"><a href="#13-display-none与visibility-hidden的区别" class="headerlink" title="13.display:none与visibility:hidden的区别"></a>13.<strong>display:none与visibility:hidden的区别</strong></h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:none</span>是彻底消失，不在文档流中占位，浏览器也不会解析该元素；<span class="selector-tag">visibility</span><span class="selector-pseudo">:hidden</span>是视觉上消失了，可以理解为透明度为0的效果，在文档流中占位，浏览器会解析该元素；</span><br></pre></td></tr></table></figure><h2 id="14-浏览器清除浮动的方式及其原理"><a href="#14-浏览器清除浮动的方式及其原理" class="headerlink" title="14.浏览器清除浮动的方式及其原理"></a>14.<strong>浏览器清除浮动的方式及其原理</strong></h2><p>1》添加额外的标签：在浮动元素末尾添加一个空的标签例如 &lt; div style=”clear:both”&gt;，其他标签br等亦可</p><p>2》使用 br标签和其自身的 html属性：&lt; br clear=”all” /&gt;</p><p>3》父元素设置 overflow：hidden</p><p>4》父元素设置 overflow：auto 属性</p><p>5》父元素也设置浮动</p><p>6》父元素设置display:table</p><p>7》使用 :after 伪元素</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`.clearfix:after &#123;content:"."; display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1; &#125;`</span><br></pre></td></tr></table></figure><h2 id="15-BFC"><a href="#15-BFC" class="headerlink" title="15.BFC"></a>15.<strong>BFC</strong></h2><p>(1).BFC的特性:</p><p>​    ①块级格式化上下文会阻止外边距叠加</p><p>​    ②块级格式化上下文不会重叠浮动元素</p><p>​    ③块级格式化上下文通常可以包含浮动</p><p>创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC任然属于文档中的普通流。</p><p>2.触发BFC的条件</p><p>　    1、float 除了none以外的值</p><p>　　2、overflow 除了visible 以外的值（hidden，auto，scroll ）</p><p>　　3、display (table-cell，table-caption，inline-block)</p><p>　　4、position（absolute，fixed）</p><p>　　5、fieldset元素</p><h2 id="16-src与href的区别"><a href="#16-src与href的区别" class="headerlink" title="16.src与href的区别"></a>16.<strong>src与href的区别</strong></h2><pre><code>href表示超文本引用。用来建立当前文档和引用资源之间的链接。常用的有：link、a。src是source的缩写，是引入。src指向的内容会嵌入到文档中当前标签所在的位置。常用的有：img、script、iframe 简而言之，src用于替换当前元素；href用于在当前文档和引用资源之间建立联系。</code></pre><h2 id="17-px、em、rem的区别"><a href="#17-px、em、rem的区别" class="headerlink" title="17.px、em、rem的区别"></a>17.<strong>px、em、rem的区别</strong></h2><pre><code>都是用于设置字体的大小以及盒子的宽高，但是px不会因为浏览器尺寸的改变而改变，而em和rem会因为浏览器尺寸的变化而变化像素是相对于显示器屏幕分辨率而言的em是一个相对长度的单位，是相对于当前对象内文本的字体尺寸。如过我们未设置当前文本的字体尺寸，那么em就会相对于浏览器的默认字体尺寸， em大小不是固定的，会继承父级元素的字体大小。rem相对的只是HTML根元素，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。</code></pre><h2 id="18-为什么要使用css-sprites"><a href="#18-为什么要使用css-sprites" class="headerlink" title="18.为什么要使用css sprites"></a>18.<strong>为什么要使用css sprites</strong></h2><pre><code>CSS Sprites其实就是把网页中一些[背景图片]整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出[背景图片]的位置。当页面加载时，不是加载每个单独图片，而是一次加载整个组合图片。这是一个了不起的改进，它大大减少了[HTTP请求]的次数，减轻服务器压力，同时缩短了悬停加载图片所需要的时间延迟，使效果更流畅，不会停顿。缺点：就是在拼图时，比较麻烦，还有后期维护也比较麻烦，比如做好的图，然后一个图标改了大小，但是图标之间留的位置不够，那你就要重写很多css。因为每次的图片改动都得往这个图片删除或添加内容，显得稍微繁琐</code></pre><h2 id="19-什么是CSS及CSS怎么运作"><a href="#19-什么是CSS及CSS怎么运作" class="headerlink" title="19.什么是CSS及CSS怎么运作"></a>19.<strong>什么是CSS及CSS怎么运作</strong></h2><pre><code>CSS (Cascading Style Sheets) 是用来样式化和排版你的网页的 —— 例如更改网页内容的字体、颜色、大小和间距，将内容分割成多列或者加入动画以及别的装饰型效果。是一种用于向用户指定文档如何呈现的语言。Web浏览器将CSS规则应用于文档以影响它们的显示方式。</code></pre><h2 id="20-居中"><a href="#20-居中" class="headerlink" title="20.居中"></a>20.居中</h2><p> <a href="..\CSS\居中.xmind">居中.xmind</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-了解什么是Web&quot;&gt;&lt;a href=&quot;#1-了解什么是Web&quot; class=&quot;headerlink&quot; title=&quot;1.了解什么是Web&quot;&gt;&lt;/a&gt;1.了解什么是Web&lt;/h2&gt;&lt;p&gt;   web即全球广域网，也称万维网。它是一种基于超文本和HTTP的、全球性
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面试2</title>
    <link href="http://yoursite.com/2019/07/15/JavaScript%E9%9D%A2%E8%AF%952/"/>
    <id>http://yoursite.com/2019/07/15/JavaScript面试2/</id>
    <published>2019-07-15T03:09:04.943Z</published>
    <updated>2019-07-15T03:19:02.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-你觉得js是一门怎样的语言，它与你学过的其他语言有什么不同"><a href="#1-你觉得js是一门怎样的语言，它与你学过的其他语言有什么不同" class="headerlink" title="1.你觉得js是一门怎样的语言，它与你学过的其他语言有什么不同"></a>1.你觉得js是一门怎样的语言，它与你学过的其他语言有什么不同</h2><p>javaScript</p><p>​      一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。JavaScript兼容于ECMA标准，因此也称为ECMAScript。</p><p>Javascript的特点：</p><p>一、简单性：</p><p>JavaScript是一种基于Java基本语句和控制流之上的简单而紧凑的设计，从而对于学习Java是一种非常好的过渡。它的变量类型是采用弱类型，并未使用严格的数据类型。</p><p>二、动态性：</p><p> avaScript是动态的，它可以直接对用户或客户输入做出响应，无须经过Web服务程序。它对用户的反映响应，是采用以事件驱动的方式进行的。所谓事件驱动，就是指在主页(Home Page)中执行了某种操作所产生的动作，就称为“事件”(Event)。比如按下鼠标、移动窗口、选择菜单等都可以视为事件。当事件发生后，可能会引起相应的事件响应。</p><p>三、跨平台性：</p><p>JavaScript是依赖于浏览器本身，与操作环境无关，只要能运行浏览器的计算机，并支持JavaScript的浏览器就可正确执行。从而实现了“编写一次,走遍天下”的梦想。</p><p>四、安全性：</p><p>JavaScript是一种安全性语言，它不允许访问本地的硬盘，并不能将数据存入到服务器上，不允许对网络文档进行修改和删除，只能通过浏览器实现信息浏览或动态交互。从而有效地防止数据的丢失。</p><p><strong>2</strong>。从静态类型还是动态类型来看 </p><p>静态类型，编译的时候就能够知道每个变量的类型，编程的时候也需要给定类型，如Java中的整型int，浮点型float等。C、C++、Java都属于静态类型语言。 </p><p>  动态类型，运行的时候才知道每个变量的类型，编程的时候无需显示指定类型，如JavaScript中的var、PHP中的$。JavaScript、Ruby、Python都属于动态类型语言。 </p><p>  静态类型还是动态类型对语言的性能有很大影响。 </p><p>  对于静态类型，在编译后会大量利用已知类型的优势，如int类型，占用4个字节，编译后的代码就可以用内存地址加偏移量的方法存取变量，而地址加偏移量的算法汇编很容易实现。 </p><p>  对于动态类型，会当做字符串通通存下来，之后存取就用字符串匹配。 </p><p>  从编译型还是解释型来看 </p><p>  编译型语言，像C、C++，需要编译器编译成本地可执行程序后才能运行，由开发人员在编写完成后手动实施。用户只使用这些编译好的本地代码，这些本地代码由系统加载器执行，由操作系统的CPU直接执行，无需其他额外的虚拟机等。 </p><p>  源代码=》抽象语法树=》中间表示=》本地代码 </p><p>  解释性语言，像JavaScript、Python，开发语言写好后直接将代码交给用户，用户使用脚本解释器将脚本文件解释执行。对于脚本语言，没有开发人员的编译过程，当然，也不绝对。 </p><p>  源代码=》抽象语法树=》解释器解释执行。 </p><p>  对于JavaScript，随着Java虚拟机JIT技术的引入，工作方式也发生了改变。可以将抽象语法树转成中间表示（字节码），再转成本地代码，如JavaScriptCore，这样可以大大提高执行效率。也可以从抽象语法树直接转成本地代码，如V8 </p><p>​    Java语言，分为两个阶段。首先像C++语言一样，经过编译器编译。和C++的不同，C++编译生成本地代码，Java编译后，生成字节码，字节码与平台无关。第二阶段，由Java的运行环境也就是Java虚拟机运行字节码，使用解释器执行这些代码。一般情况下，Java虚拟机都引入了JIT技术，将字节码转换成本地代码来提高执行效率。  </p><p>  注意，在上述情况中，编译器的编译过程没有时间要求，所以编译器可以做大量的代码优化措施。 </p><p>  对于JavaScript与Java它们还有的不同： </p><p>  对于Java，Java语言将源代码编译成字节码，这个同执行阶段是分开的。也就是从源代码到抽象语法树到字节码这段时间的长短是无所谓的。 </p><p>  对于JavaScript，这些都是在网页和JavaScript文件下载后同执行阶段一起在网页的加载和渲染过程中实施的，所以对于它们的处理时间有严格要求</p><h2 id="2-js基本数据类型"><a href="#2-js基本数据类型" class="headerlink" title="2.js基本数据类型"></a>2.js基本数据类型</h2><p>字符串值，数值，布尔值，数组，undefined，null，对象。<br>基本类型数据<br>1.基本数据类型值是指简单的数据段，五种基本类型都是按值访问的（可以操作保存在变量中的实际值）；<br>2.基本类型的值在内存中占据固定大小的空间，被保存在栈内存中。（从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本）；<br>3.不能给基本类型的值添加属性。<br>引用类型数据：object（还有array、function）<br>1.引用类型值是指那些可以由多个值构成的对象。js不允许直接访问内存中的位置，也就是不能直接访问操作对象的内存空间，在操作对象时，实际上是在操作对象的引用而不是实际的对象；<br>2.引用类型的值是对象，保存在堆内存中，包含引用类型值的变量实际上包含的并不是对象本身，而是指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终指向同一个对象。<br>3.对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法。<br>4.在ECMAScript中用var关键字来定义变量，因为js是弱类型的，所以无法确定变量一定会存储什么值，也就不知道变量到底会是什么类型，而且变量的类型可以随时改变。这就是ECMAScript是松散类型的来由，所谓松散类型就是可以用来保存任何类型的数据。<br>在es6中新增了let命令来声明变量，const命令声明一个只读的常量<br>let的用法类似于var，但是所声明的变量，只有在let代码块内才有效；const一旦声明，常量的值就不能改变。</p><p><a href="https://www.cnblogs.com/zhengyeye/p/6485124.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengyeye/p/6485124.html</a></p><h2 id="3-js如何判断变量数据类型"><a href="#3-js如何判断变量数据类型" class="headerlink" title="3.js如何判断变量数据类型"></a>3.js如何判断变量数据类型</h2><p>typeof（typeof的局限性在于 数组、对象、null都为object；typeof运算符把函数返回function）、instanceof（[1,2] instanceof Array 只对数组有用)、Array.isArray()方法确定某个值是否为数组、Object.prototype.toString.call()（最理想，能够十分准确检测出全部类型）、constructor（引用了初始化该对象的构造函数来判断 （(“123”).constructor === String）</p><h2 id="4-类数组和数组"><a href="#4-类数组和数组" class="headerlink" title="4.类数组和数组"></a>4.类数组和数组</h2><p><strong>类数组定义</strong><br>1）拥有length属性，其它属性（索引）为非负整数（对象中的索引会被当做字符串来处理）；<br>2）不具有数组所具有的方法；<br>javascript中常见的类数组有 <code>arguments</code>对象和 DOM方法的返回结果。比如 <code>document.getElementsByTagName()</code>。</p><p>判断是否是类数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isLikeArray</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> o === <span class="string">'object'</span>&amp;&amp; <span class="built_in">isFinite</span>(o.length) &amp;&amp;  o.length &gt;= <span class="number">0</span> &amp;&amp; o.length &lt; <span class="number">4294967296</span>)&#123;<span class="comment">// 4294967296: 2^32</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-将类数组转换为数组"><a href="#5-将类数组转换为数组" class="headerlink" title="5.将类数组转换为数组"></a>5.将类数组转换为数组</h2><ol><li>创建一个新的数组，然后将将类数组中的元素添加到新数组里面</li><li>Array.prototype.slice.call()</li><li>Array.form(arguments)</li></ol><h2 id="6-如何遍历数组"><a href="#6-如何遍历数组" class="headerlink" title="6.如何遍历数组"></a>6.如何遍历数组</h2><p>1.普通for循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = arr.length; i &lt; len; i++)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; arr[i] != <span class="literal">null</span>; i++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.for in 循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.forEach循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//数组自带的foreach循环，使用频率较高，实际上性能比普通for循环弱</span></span><br></pre></td></tr></table></figure><p>4.map遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>))</span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>5.for of 遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> arr)&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这种方式是es6里面用到的，性能好于for in，但仍比不上普通for循环</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/function__/article/details/79555301" target="_blank" rel="noopener">https://blog.csdn.net/function__/article/details/79555301</a></p><h2 id="7-ARRAY常用方法"><a href="#7-ARRAY常用方法" class="headerlink" title="7.ARRAY常用方法"></a>7.ARRAY常用方法</h2><p>push(),pop(),shift(),unshift(),splice(),sort(),reverse(),map(),forEach(),isArray(),toString()等</p><h2 id="8-STRING常用方法"><a href="#8-STRING常用方法" class="headerlink" title="8.STRING常用方法"></a>8.STRING常用方法</h2><p><strong>toUpperCase()</strong>：把一个字符串全部变为大写</p><p><strong>toLowerCase()</strong>：把一个字符串全部变为小写</p><p><strong>indexOf()</strong>：会搜索制定字符串出现的位置，有返回索引，没有返回-1</p><p><strong>substring()</strong>：返回制定索引区间的子串（传一个参数的话表示从该参数索引位置开始到结束；传两个参数的话表示从开始索引到结束索引）</p><p><strong>slice()</strong>：使用与substring()基本相同，可以传负数，负数则从字符串尾部算起；substring()不能传负数</p><p><strong>substr()</strong>：用法与上面两个相似，但是第二个参数表示截取的字符串最大长度（三种字符串截取方法，未填第二参数时，自动截取起始位置到字符串末尾）</p><p><strong>toString()</strong>：可以将其他数据类型转换为字符串</p><p><strong>split()</strong>：对字符串进行分割，返回一个数组（如果只传一个参数则表示以哪个字符进行分割；传两个参数的话第二个参数表示返回的字符串数组的最大长度）</p><p><strong>replace()</strong>：字符串替换，默认只进行第一次匹配操作的替换，想要全局替换，需要加上正则全局标识g。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　　　var mystr=&quot;wozaijinxingzifuchuantihuancaozuo,zifuchuantihuano&quot;;</span><br><span class="line">　　　　var replaceStr=mystr.replace(&quot;zifuchuan&quot;,&quot; &quot;);    //wozaijinxing tihuancaozuo,zifuchuantihuano</span><br><span class="line">　　　　var replaceStr=mystr.replace(/zifuchuan/,&quot; &quot;);    //wozaijinxing tihuancaozuo,zifuchuantihuano</span><br><span class="line">　　　　var replaceStr=mystr.replace(/zifuchuan/g,&quot; &quot;);    //wozaijinxing tihuancaozuo, tihuano</span><br></pre></td></tr></table></figure><p><strong>length</strong>：获取字符串长度</p><p><strong>indexOf()</strong>：查询子字符串，对大小写敏感，返回字符串中子串第一处出现的索引（从左到右）。如果没有匹配项，返回-1。</p><p><strong>lastIndexOf()</strong>：查询子字符串，对大小写敏感，返回字符串中子串第一处出现的索引（从右到左）。如果没有匹配项，返回-1。</p><p><strong>charAt()</strong>：返回制定位置的字符</p><p><strong>match()</strong>：字符串匹配。若有相匹配的字符，则返回所要匹配的字符串；没有相匹配的，返回null（也可定义一个变量为正则表达式进行匹配）</p><p><strong>exec()</strong>：字符串匹配。与match()效果相同，用法相反</p><p><strong>search()</strong>：进行正则匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回-1</p><p><strong>trim()</strong>：删除字符串前后的空格</p><h2 id="9-DOM-事件级别"><a href="#9-DOM-事件级别" class="headerlink" title="9.DOM 事件级别"></a>9.DOM 事件级别</h2><p>dom0级事件就是在js中写到 element.onclick=function(){},是一种比较传统的方式：把一个函数(或者匿名函数)赋值给一个事件的处理程序属性。</p><blockquote><p>优势（兼容所有浏览器）</p><p>缺点：不能给元素添加多个事件处理程序，只能添加一个，如果添加多个事件处理程序，后面的会覆盖前面的</p></blockquote><p> 2 DOM1级主要是映射文档，<strong>没有事件</strong>。  </p><p> 3 DOM2级事件 element.addEventListerner(‘click’,function(){},false)  false指的是冒泡，早期浏览器都支持冒泡，为了兼容基本上最后一个参数都是false.</p><blockquote><p>删除事件：element.removeEventListener(‘click’,function(){},false)，这样的删除方式只能删除DOM2级添加的事件。删除的时候传递的参数必须跟添加时传递的参数一样才能正确删除事件。</p><p>优点，可以给元素添加多个事件处理程序，这些事件处理程序按照他们的顺序执行。</p></blockquote><p>4 Dom3级事件跟dom2级事件写法一样的，只是增加了许多事件类型，包括点击事件和键盘事件。</p><h2 id="10-DOM-事件类型"><a href="#10-DOM-事件类型" class="headerlink" title="10.DOM 事件类型"></a>10.DOM 事件类型</h2><p>Web浏览器中可能发生的事件有很多类型。不同的事件类型具有不同的信息，而“DOM3级事件”规定了以下几类事件：</p><ul><li>UI（用户界面）事件，当用户与界面上的元素交互时触发</li><li>焦点事件，当元素获得或失去焦点时触发</li><li>鼠标事件，当用户通过鼠标在页面上执行操作时触发</li><li>滚轮事件，当使用鼠标滚轮时触发</li><li>文本事件，当在文档中输入文本时触发</li><li>键盘事件，当用户通过键盘在页面上执行操作时触发</li><li>合成事件，当为IME输入字符时触发</li><li>变动事件，当底层DOM结构发生变化时触发</li></ul><h2 id="11-DOM-事件流"><a href="#11-DOM-事件流" class="headerlink" title="11.DOM 事件流"></a>11.DOM 事件流</h2><p>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。<br>事件捕获阶段<br>处于目标阶段<br>事件冒泡阶段</p><p>首先发生的是事件捕获，为截获事件提供了机会；然后是实际的目标接收到事件；最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。</p><p>addEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。<br>IE只支持事件冒泡。 </p><h2 id="12-描述一下冒泡-事件捕获的具体流程"><a href="#12-描述一下冒泡-事件捕获的具体流程" class="headerlink" title="12.描述一下冒泡/事件捕获的具体流程"></a><img src="https://images2015.cnblogs.com/blog/315302/201606/315302-20160621155328756-279009443.png" alt="img">12.描述一下冒泡/事件捕获的具体流程</h2><p>1.事件冒泡：即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p><p>2.事件捕获：思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。</p><h2 id="13-html、dom0、dom2是如何注册事件"><a href="#13-html、dom0、dom2是如何注册事件" class="headerlink" title="13.html、dom0、dom2是如何注册事件"></a>13.html、dom0、dom2是如何注册事件</h2><p>1.在html代码元素中添加事件为Html事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"按钮"</span> id=<span class="string">"btn1"</span> onclick=<span class="string">"showMess()"</span>/&gt;</span><br></pre></td></tr></table></figure><p>2.使用元素的onclick方法为DOM0级事件处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn2.onclick=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>3.使用事件添加方法为元素添加事件（</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrome:addEventListener,removeEventListener</span><br><span class="line">IE:attachEvent,detachEvent</span><br></pre></td></tr></table></figure><p>）为DOM2级事件处理。</p><h2 id="14-事件流"><a href="#14-事件流" class="headerlink" title="14.事件流"></a>14.事件流</h2><p>JavaScript高级程序设计–p345</p><h2 id="15-事件委托-代理"><a href="#15-事件委托-代理" class="headerlink" title="15.事件委托(代理)"></a>15.事件委托(代理)</h2><p><a href="https://www.jianshu.com/p/a77d8928c5c9" target="_blank" rel="noopener">https://www.jianshu.com/p/a77d8928c5c9</a></p><h2 id="16-自定义事件"><a href="#16-自定义事件" class="headerlink" title="16.自定义事件"></a>16.自定义事件</h2><p>　1.<strong>Event()</strong> 构造函数, 创建一个新的事件对象 <code>Event</code><br>　2.<strong>CustomEvent()</strong>  创建一个自定义事件<br>　3.<strong>document.createEvent()</strong> <code>创建一个新的事件（Event），随之必须调用自身的 init 方法进行初始化</code><br>  4.<a href="https://www.cnblogs.com/shapeY/p/7923353.html" target="_blank" rel="noopener">https://www.cnblogs.com/shapeY/p/7923353.html</a></p><h2 id="17-怎么防止冒泡"><a href="#17-怎么防止冒泡" class="headerlink" title="17.怎么防止冒泡"></a>17.怎么防止冒泡</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopBubble</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line"><span class="comment">//如果提供了事件对象，则这是一个非IE浏览器 </span></span><br><span class="line"><span class="keyword">if</span> ( e &amp;&amp; e.stopPropagation ) </span><br><span class="line">    <span class="comment">//因此它支持W3C的stopPropagation()方法 </span></span><br><span class="line">    e.stopPropagation(); </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="comment">//否则，我们需要使用IE的方式来取消事件冒泡 </span></span><br><span class="line">    <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻止默认行为</p><p><a href="http://caibaojian.com/javascript-stoppropagation-preventdefault.html" target="_blank" rel="noopener">http://caibaojian.com/javascript-stoppropagation-preventdefault.html</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻止浏览器的默认行为 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopDefault</span>(<span class="params"> e </span>) </span>&#123; </span><br><span class="line">    <span class="comment">//阻止默认浏览器动作(W3C) </span></span><br><span class="line">    <span class="keyword">if</span> ( e &amp;&amp; e.preventDefault ) </span><br><span class="line">        e.preventDefault(); </span><br><span class="line">    <span class="comment">//IE中阻止函数器默认动作的方式 </span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-谈谈innerHTML、-nodeValue与-textContent之间的区别"><a href="#18-谈谈innerHTML、-nodeValue与-textContent之间的区别" class="headerlink" title="18.谈谈innerHTML、 nodeValue与 textContent之间的区别"></a>18.谈谈innerHTML、 nodeValue与 textContent之间的区别</h2><p>nodeValue：是节点的值</p><p>innerHTML:浏览器会将内容解析为HTML代码</p><p>textContent：使用纯文本而不是解析为HTML</p><h2 id="19-简单说一下DOM操作中如何查找元素"><a href="#19-简单说一下DOM操作中如何查找元素" class="headerlink" title="19.简单说一下DOM操作中如何查找元素"></a>19.简单说一下DOM操作中如何查找元素</h2><p>document.getElementById(id) 通过元素 id 来查找元素 </p><p>document.getElementsByTagName(name) 通过标签名来查 </p><p> document.getElementsByClassName(name) 通过类名来查 </p><p>document.getElementsByName();//name属性值，一般不用</p><p>* 通过css选择器查找HTML元素 (document.querySelector()返回与该模式匹配的第一个元素，结果为一个元素；如果没找到匹配的元素，则返回null)</p><p>* 通过HTML对象选择器查找HTML对象</p><h2 id="20-dom节点获取，及其特性"><a href="#20-dom节点获取，及其特性" class="headerlink" title="20.dom节点获取，及其特性"></a>20.dom节点获取，及其特性</h2><p>通过 JavaScript，您可以使用以下节点属性在节点之间导航： </p><p> parentNode </p><p> childNodes[nodenumber] </p><p> firstChild </p><p> lastChild </p><p> nextSibling </p><p> previousSibling</p><h2 id="21-如果一个-ul-下面有-5个-li-如何给他们添加点击事情的方法"><a href="#21-如果一个-ul-下面有-5个-li-如何给他们添加点击事情的方法" class="headerlink" title="21.如果一个 ul 下面有 5个 li 如何给他们添加点击事情的方法"></a>21.如果一个 ul 下面有 5个 li 如何给他们添加点击事情的方法</h2><p><a href="https://blog.csdn.net/caoPengFlying/article/details/78495310" target="_blank" rel="noopener">js为li列表添加点击事件 - caoPengFlying的博客 - CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_42445490/article/details/88819063" target="_blank" rel="noopener">JS中for循环出现的问题：如何给li元素绑定事件，点击每个li元素弹出对应的 - 骆小胖~ - CSDN博客</a></p><h2 id="22-window-document-对象是什么？"><a href="#22-window-document-对象是什么？" class="headerlink" title="22.window document 对象是什么？"></a>22.window document 对象是什么？</h2><p>window对象</p><p>代表浏览器中的一个打开的窗口或者框架，window对象会在<body>或者<frameset>每次出现时被自动创建，在客户端JavaScript中，Window对象是全局对象，所有的表达式都在当前的环境中计算，要引用当前的窗口不需要特殊的语法，可以把那个窗口属性作为全局变量使用，例如：可以只写document，而不必写window.document。同样可以把窗口的对象方法当做函数来使用，如：只写alert（），而不必写window.alert</frameset></body></p><p>window对象实现了核心JavaScript所定义的全局属性和方法。</p><p>indow对象的window属性和self属性引用都是他自己。</p><p>document对象</p><p>代表整个HTML文档，可以用来访问页面中的所有元素 。</p><p>每一个载入浏览器的HTML文档都会成为document对象。document对象使我们可以从脚本中对HTML页面中的所有元素进行访问。<br> document对象是window对象的一部分可以通过window.document属性对其进行访问<br> HTMLDocument接口进行了扩展，定义HTML专用的属性和方法，很多属性和方法都是HTMLCollection对象，其中保存了对锚、表单、链接以及其他可脚本元素的引用。</p><h2 id="23-setTimeout-和-setInteval-的区别和使用方法"><a href="#23-setTimeout-和-setInteval-的区别和使用方法" class="headerlink" title="23.setTimeout 和 setInteval 的区别和使用方法"></a>23.setTimeout 和 setInteval 的区别和使用方法</h2><p><a href="https://blog.csdn.net/HandSome_He/article/details/81676640" target="_blank" rel="noopener">https://blog.csdn.net/HandSome_He/article/details/81676640</a></p><h2 id="24-异步同步"><a href="#24-异步同步" class="headerlink" title="24.异步同步"></a>24.异步同步</h2><p><strong>异步</strong></p><p>如果在函数返回的时候，调用者还不能购得到预期结果，而是将来通过一定的手段得到（例如回调函数），这就是异步。例如ajax操作。<br>如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。</p><p><strong>同步</strong></p><p>如果在函数返回结果的时候，调用者能够拿到预期的结果(就是函数计算的结果)，那么这个函数就是同步的.如果函数是同步的，即使调用函数执行任务比较耗时，也会一致等待直到得到执行结果。</p><h2 id="25-如何实现页面跳转"><a href="#25-如何实现页面跳转" class="headerlink" title="25.如何实现页面跳转"></a>25.如何实现页面跳转</h2><p><strong>第一种：直接跳转加参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &lt;script language=<span class="string">"javascript"</span> type=<span class="string">"text/javascript"</span>&gt;           <span class="built_in">window</span>.location.href=<span class="string">"login.jsp?backurl="</span>+<span class="built_in">window</span>.location.href;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>直接跳转无参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">window</span>.location.href=<span class="string">'http://www.baidu.com'</span>;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>第二种：返回上一次预览界面</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;alert(<span class="string">"返回"</span>);<span class="built_in">window</span>.history.back(<span class="number">-1</span>);<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>标签嵌套：</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"javascript:history.go(-1)"</span>&gt;返回上一步&lt;a&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%=Request.ServerVariables("</span><span class="attr">HTTP_REFERER</span>")%&gt;</span>"&gt;返回上一步<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>第三种：指定跳转页面 对框架无效。。。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;       <span class="built_in">window</span>.navigate(<span class="string">"top.jsp"</span>);  <span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>第四种：指定自身跳转页面 对框架无效。。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"JavaScript"</span>&gt;          self.location=<span class="string">'top.htm'</span>;   <span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>第五种：指定自身跳转页面 对框架有效。。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;          alert(<span class="string">"非法访问！"</span>);          top.location=<span class="string">'xx.aspx'</span>;   <span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>第六种：按钮式 在button按钮添加 事件跳转。。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=<span class="string">"pclog"</span> type=<span class="string">"button"</span> value=<span class="string">"GO"</span> onClick=<span class="string">"location.href='login.aspx'"</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>第七种：在新窗口打开：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　&lt;a href=<span class="string">"javascript:"</span> onClick=<span class="string">"window.open('login.aspx','','height=500,width=611,scrollbars=yes,status=yes')"</span>&gt;开新窗口&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><h2 id="26-children-和-childNodes-的区别"><a href="#26-children-和-childNodes-的区别" class="headerlink" title="26.children 和 childNodes 的区别"></a>26.children 和 childNodes 的区别</h2><p>childNodes：获取节点，不同浏览器表现不同；</p><p>　　IE：只获取元素节点；</p><p>　　非IE：获取元素节点与文本节点；</p><p>　　解决方案：if(childNode.nodeName==”#text”) continue 或者 if(childNode.nodeType != ‘3’) continue </p><p>2、children：获取元素节点，浏览器表现相同。</p><p>　　因此建议使用children。</p><h2 id="27-如何实现insertAfter"><a href="#27-如何实现insertAfter" class="headerlink" title="27.如何实现insertAfter"></a>27.如何实现insertAfter</h2><p><code>parent.insertBefore(newElement,targetElement.nextSibling)</code>他的三部分为 父节点 新节点 目标节点 他会把新节点创建在目标节点之前 需要注意的是 父节点并无需获取 你通过目标节点.parentNode就可以获取<br>但是js并没有提供插入在目标节点之后的方法 我们可以自己写一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertAfter</span>(<span class="params">newElement,targetElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parent = targetElement.parentNode;</span><br><span class="line">    <span class="keyword">if</span>(parent.lastChild == targetElement)&#123;</span><br><span class="line">        parent.appendChild(newElement);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;           parent.insertBefore(newElement,targetElement.nextSibling);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先 他把目标节点的父节点找到包装在parent里 然后进行对比 如果这个父节点的最后一个节点是目标节点 那么无需插入在中间 因为appendChild默认就是将节点插入到末尾 </p><p>如果不是 目标节点游在中间 那么他会调用Before方法 把新节点插入到 目标节点的后面一个节点之前 其实也就是他的节点之后 绕了一点</p><h2 id="28-变量提升"><a href="#28-变量提升" class="headerlink" title="28.变量提升"></a>28.变量提升</h2><p><a href="https://cloud.tencent.com/developer/article/1405726" target="_blank" rel="noopener">JavaScript 变量提升 - 云+社区 - 腾讯云</a></p><h2 id="29-执行环境与作用域"><a href="#29-执行环境与作用域" class="headerlink" title="29.执行环境与作用域"></a>29.执行环境与作用域</h2><p><a href="https://www.jb51.net/article/83585.htm" target="_blank" rel="noopener">https://www.jb51.net/article/83585.htm</a></p><h2 id="30-克隆对象"><a href="#30-克隆对象" class="headerlink" title="30.克隆对象"></a>30.克隆对象</h2><h2 id="31-this以及修改this"><a href="#31-this以及修改this" class="headerlink" title="31.this以及修改this"></a>31.this以及修改this</h2><p><a href="https://www.cnblogs.com/yummylucky/p/10225066.html" target="_blank" rel="noopener">https://www.cnblogs.com/yummylucky/p/10225066.html</a></p><h2 id="32-call和apply区别"><a href="#32-call和apply区别" class="headerlink" title="32.call和apply区别"></a>32.call和apply区别</h2><p>通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2…这种形式（两者区别仅在于接收参数的方式不同。apply()方法第二个参数可以是Array的实例也可以是argument对象，call()方法必须明确地传入每一个参数）。通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。  </p><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。 </p><p> call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。 </p><p> bind除了返回是函数以外，它的参数和call一样。 </p><h2 id="33-闭包"><a href="#33-闭包" class="headerlink" title="33.闭包"></a>33.闭包</h2><p>  一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。 </p><p>  （1）什么是闭包：  闭包是指有权访问另外一个函数作用域中的变量的函数。闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。 </p><p>（2）为什么要用：  匿名自执行函数：我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。  结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p><h2 id="34-js运行机制"><a href="#34-js运行机制" class="headerlink" title="34.js运行机制"></a>34.js运行机制</h2><p><a href="https://www.baidu.com/link?url=HbzsQy4I1L5Y8RWr5NEReBaQkfm4vCCrb7qa9KYGo0tAglavxUxtAFUCZ2uxKxsEFl3ToD2XukSuaPtSDSDgcWGQmN2PlrmRRrj-ZRpq7g7&amp;wd=&amp;eqid=bfa5949d0000d54b000000065d294ed0" target="_blank" rel="noopener">https://www.baidu.com/link?url=HbzsQy4I1L5Y8RWr5NEReBaQkfm4vCCrb7qa9KYGo0tAglavxUxtAFUCZ2uxKxsEFl3ToD2XukSuaPtSDSDgcWGQmN2PlrmRRrj-ZRpq7g7&amp;wd=&amp;eqid=bfa5949d0000d54b000000065d294ed0</a></p><h2 id="35-js对象的创建方法"><a href="#35-js对象的创建方法" class="headerlink" title="35.js对象的创建方法"></a>35.js对象的创建方法</h2><p><a href="https://www.jb51.net/article/157045.htm" target="_blank" rel="noopener">js中对象与对象创建方法的各种方法_javascript技巧_脚本之家</a></p><h2 id="36-原型链"><a href="#36-原型链" class="headerlink" title="36.原型链"></a>36.原型链</h2><p><a href="https://blog.csdn.net/sinat_21274091/article/details/52741788" target="_blank" rel="noopener">JS重点整理之JS原型链彻底搞清楚 - sinat_21274091的博客 - CSDN博客</a></p><h2 id="37-对象的继承机制"><a href="#37-对象的继承机制" class="headerlink" title="37.对象的继承机制"></a>37.对象的继承机制</h2><p><a href="https://www.cnblogs.com/jofun/p/8727814.html" target="_blank" rel="noopener">详解JavaScript对象继承方式 - 雨霖月寒 - 博客园</a></p><h2 id="38-JS垃圾回收机制"><a href="#38-JS垃圾回收机制" class="headerlink" title="38.JS垃圾回收机制"></a>38.JS垃圾回收机制</h2><p><a href="https://blog.csdn.net/yingzizizizizizzz/article/details/77333996" target="_blank" rel="noopener">面试题——js垃圾回收机制和引起内存泄漏的操作 - yingzizizizizizzz的专栏 - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-你觉得js是一门怎样的语言，它与你学过的其他语言有什么不同&quot;&gt;&lt;a href=&quot;#1-你觉得js是一门怎样的语言，它与你学过的其他语言有什么不同&quot; class=&quot;headerlink&quot; title=&quot;1.你觉得js是一门怎样的语言，它与你学过的其他语言有什么不
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面试1</title>
    <link href="http://yoursite.com/2019/07/15/JavaScript%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/07/15/JavaScript面试/</id>
    <published>2019-07-15T03:09:04.940Z</published>
    <updated>2019-07-15T03:20:54.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="几个很实用的BOM属性对象方法？"><a href="#几个很实用的BOM属性对象方法？" class="headerlink" title="几个很实用的BOM属性对象方法？"></a>几个很实用的BOM属性对象方法？</h2><p>Bom是浏览器对象。<br>(1)location对象<br>     location.href– 返回或设置当前文档的URL<br>     location.search – 返回URL中的查询字符串部分。例    如<code>http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu</code>返回包括(?)后面的内容?id=5&amp;name=dreamdu<br>     location.hash – 返回URL#后面的内容，如果没有#，返回空<br>     location.host – 返回URL中的域名部分，例如<code>[www.dreamdu.com](http://www.dreamdu.com)</code><br>     location.hostname – 返回URL中的主域名部分，例如dreamdu.com<br>     location.pathname – 返回URL的域名后的部分。例如 <code>http://www.dreamdu.com/xhtml/</code> 返回/xhtml/<br>     location.port – 返回URL中的端口部分。例如 <code>http://www.dreamdu.com:8080/xhtml/</code> 返回8080<br>     location.protocol – 返回URL中的协议部分。例如 <code>http://www.dreamdu.com:8080/xhtml/</code>返回(//)前面的内容http:<br>    location.assign – 设置当前文档的URL<br>    location.replace() – 设置当前文档的URL，并且在history对象的地址列表中移除这个URL<br>    location.replace(url);<br>     location.reload() – 重载当前页面<br>  (2)history对象<br>     history.go() – 前进或后退指定的页面数 history.go(num);<br>    history.back() – 后退一页<br>     history.forward() – 前进一页<br>  (3)Navigator对象<br>     navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)<br>     navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie </p><h2 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作用?严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用?严格模式与混杂模式如何区分？它们有何意义?</h2><p>  Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。<br>  严格模式的排版和JS 运作模式是 以该浏览器支持的最高标准运行。<br>  混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。 </p><h2 id="click在ios上有300ms延迟，原因及如何解决？"><a href="#click在ios上有300ms延迟，原因及如何解决？" class="headerlink" title="click在ios上有300ms延迟，原因及如何解决？"></a>click在ios上有300ms延迟，原因及如何解决？</h2><p>  (1)粗暴型，禁用缩放<br>  &lt; meta name=”viewport” content=”width=device-width, user-scalable=no”&gt;<br>  (2)利用FastClick，其原理是：<br>  检测到touchend事件后，立刻出发模拟click事件，并且把浏览器300毫秒之后真正出发的事件给阻断掉 </p><h2 id="addEventListener参数"><a href="#addEventListener参数" class="headerlink" title="addEventListener参数"></a>addEventListener参数</h2><p>  addEventListener(event, function, useCapture)<br>  其中，event指定事件名；function指定要事件触发时执行的函数；useCapture指定事件是否在捕获或冒泡阶段执行。 </p><h2 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h2><p>  降低请求量：合并资源，减少HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。<br>  加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。<br>  缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。<br>  渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline。 </p><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><p>  get和post是http常见的请求方法，还有很多比如patch、delete、put、options等等<br>  get参数通过url传递，post放在request body中。<br>  get请求在url中传递的参数是有长度限制的，而post没有。<br>  get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。<br>  get请求只能进行url编码，而post支持多种编码方式<br>  get请求会浏览器主动cache，而post支持多种编码方式。<br>  get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。<br>  GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。<br>  GET产生一个TCP数据包；POST产生两个TCP数据包。 </p><h2 id="说一下浏览器缓存"><a href="#说一下浏览器缓存" class="headerlink" title="说一下浏览器缓存"></a>说一下浏览器缓存</h2><pre><code>缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。强缓存相关字段有expires，cache-control。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。协商缓存相关字段有Last-Modified/If-Modified-Since，Etag/If-None-Match </code></pre><h2 id="浏览器在生成页面的时候，会生成那两颗树？"><a href="#浏览器在生成页面的时候，会生成那两颗树？" class="headerlink" title="浏览器在生成页面的时候，会生成那两颗树？"></a>浏览器在生成页面的时候，会生成那两颗树？</h2><pre><code>构造两棵树，DOM树和CSSOM规则树.当浏览器接收到服务器相应来的HTML文档后，会遍历文档节点，生成DOM树，CSSOM规则树由浏览器解析CSS文件生成， </code></pre><h2 id="怎么看网站的性能如何"><a href="#怎么看网站的性能如何" class="headerlink" title="怎么看网站的性能如何"></a>怎么看网站的性能如何</h2><pre><code>检测页面加载时间一般有两种方式，一种是被动去测：就是在被检测的页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析，另一种主动监测的方式，即主动的搭建分布式受控环境，模拟用户发起页面访问请求，主动采集性能数据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如说性能极客 </code></pre><h2 id="浏览器输入网址到页面渲染全过程"><a href="#浏览器输入网址到页面渲染全过程" class="headerlink" title="浏览器输入网址到页面渲染全过程"></a>浏览器输入网址到页面渲染全过程</h2><pre><code>DNS解析 TCP连接发送 HTTP请求服务器 处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束 </code></pre><h2 id="HTML5和CSS3用的多吗？你了解它们的新属性吗？有在项目中用过吗？"><a href="#HTML5和CSS3用的多吗？你了解它们的新属性吗？有在项目中用过吗？" class="headerlink" title="HTML5和CSS3用的多吗？你了解它们的新属性吗？有在项目中用过吗？"></a>HTML5和CSS3用的多吗？你了解它们的新属性吗？有在项目中用过吗？</h2><p> html5：<br>    1）标签增删<br>    8个语义元素 header section footer aside nav main article figure<br>    内容元素mark高亮 progress进度<br>    新的表单控件calander date time email url search<br>    新的input类型 color date datetime datetime-local email<br>    移除过时标签big font frame frameset<br>    2）canvas绘图，支持内联SVG。支持MathML<br>    3）多媒体audio video source embed track<br>    4）本地离线存储，把需要离线存储在本地的文件列在一个manifest配置文件<br>    5）web存储。localStorage、SessionStorage<br> css3：<br>    CSS3边框如border-radius，box-shadow等；CSS3背景如background-size，background-origin等；CSS3 2D，3D转换如transform等；CSS3动画如animation等。</p><h2 id="link标签和-import标签的区别"><a href="#link标签和-import标签的区别" class="headerlink" title="link标签和@import标签的区别"></a>link标签和@import标签的区别</h2><pre><code>link属于html标签，而@import是css提供的页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。link方式样式的权重高于@import的。 </code></pre><h2 id="transition和animation的区别"><a href="#transition和animation的区别" class="headerlink" title="transition和animation的区别"></a>transition和animation的区别</h2><pre><code>animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。 </code></pre><h2 id="BFC（块级格式化上下文，用于清楚浮动，防止margin重叠等）"><a href="#BFC（块级格式化上下文，用于清楚浮动，防止margin重叠等）" class="headerlink" title="BFC（块级格式化上下文，用于清楚浮动，防止margin重叠等）"></a>BFC（块级格式化上下文，用于清楚浮动，防止margin重叠等）</h2><pre><code>直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。BFC区域不会与float box重叠BFC是页面上的一个独立容器，子元素不会影响到外面计算BFC的高度时，浮动元素也会参与计算那些元素会生成BFC：根元素float不为none的元素position为fixed和absolute的元素display为inline-block、table-cell、table-caption，flex，inline-flex的元素overflow不为visible的元素 </code></pre><h2 id="visibility-hidden-opacity-0，display-none"><a href="#visibility-hidden-opacity-0，display-none" class="headerlink" title="visibility=hidden, opacity=0，display:none"></a>visibility=hidden, opacity=0，display:none</h2><pre><code>opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</code></pre><h2 id="双边距重叠问题（外边距折叠）"><a href="#双边距重叠问题（外边距折叠）" class="headerlink" title="双边距重叠问题（外边距折叠）"></a>双边距重叠问题（外边距折叠）</h2><pre><code>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠折叠的结果为：两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。两个外边距一正一负时，折叠结果是两者的相加的和。 </code></pre><h2 id="position属性-比较"><a href="#position属性-比较" class="headerlink" title="position属性 比较"></a>position属性 比较</h2><pre><code>固定定位fixed：元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed定位使元素的位置与文档流无关，因此不占据空间。 Fixed定位的元素和其他元素重叠。相对定位relative：如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。绝对定位absolute：绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。粘性定位sticky：元素先按照普通文档流定位，然后相对于该元素在流中的flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。默认定位Static：默认值。没有定位，元素出现在正常的流中（忽略top, bottom, left, right 或者 z-index 声明）。inherit:规定应该从父元素继承position 属性的值。 </code></pre><h2 id="z-index的定位方法"><a href="#z-index的定位方法" class="headerlink" title="z-index的定位方法"></a>z-index的定位方法</h2><pre><code>z-index属性设置元素的堆叠顺序，拥有更好堆叠顺序的元素会处于较低顺序元素之前，z-index可以为负，且z-index只能在定位元素上奏效，该属性设置一个定位元素沿z轴的位置，如果为正数，离用户越近，为负数，离用户越远，它的属性值有auto，默认，堆叠顺序与父元素相等，number，inherit，从父元素继承z-index属性的值 </code></pre><h2 id="line-height和height的区别"><a href="#line-height和height的区别" class="headerlink" title="line-height和height的区别"></a>line-height和height的区别</h2><pre><code>line-height一般是指布局里面一段文字上下行之间的高度，是针对字体来设置的，height一般是指容器的整体高度</code></pre><h2 id="设置一个元素的背景颜色，背景颜色会填充哪些区域？"><a href="#设置一个元素的背景颜色，背景颜色会填充哪些区域？" class="headerlink" title="设置一个元素的背景颜色，背景颜色会填充哪些区域？"></a>设置一个元素的背景颜色，背景颜色会填充哪些区域？</h2><pre><code>background-color设置的背景颜色会填充元素的content、padding、border区域</code></pre><h2 id="知道属性选择器和伪类选择器的优先级吗"><a href="#知道属性选择器和伪类选择器的优先级吗" class="headerlink" title="知道属性选择器和伪类选择器的优先级吗"></a>知道属性选择器和伪类选择器的优先级吗</h2><pre><code>属性选择器和伪类选择器优先级相同 </code></pre><h2 id="inline-block、inline和block的区别；为什么img是inline还可以设置宽高"><a href="#inline-block、inline和block的区别；为什么img是inline还可以设置宽高" class="headerlink" title="inline-block、inline和block的区别；为什么img是inline还可以设置宽高"></a>inline-block、inline和block的区别；为什么img是inline还可以设置宽高</h2><p>   Block是块级元素，其前后都会有换行符，能设置宽度，高度，margin/padding水平垂直方向都有效。<br>   Inline：设置width和height无效，margin在竖直方向上无效，padding在水平方向垂直方向都有效，前后无换行符<br>   Inline-block：能设置宽度高度，margin/padding水平垂直方向 都有效，前后无换行符 </p><h2 id="overflow的原理"><a href="#overflow的原理" class="headerlink" title="overflow的原理"></a>overflow的原理</h2><p>   要讲清楚这个解决方案的原理，首先需要了解块格式化上下文，A block formatting context is a part of a visual CSS rendering of a Web page. It is the region in which the layout of block boxes occurs and in which floats interact with each other.翻译过来就是块格式化上下文是CSS可视化渲染的一部分，它是一块区域，规定了内部块盒 的渲染方式，以及浮动相互之间的影响关系<br>   当元素设置了overflow样式且值部位visible时，该元素就构建了一个BFC，BFC在计算高度时，内部浮动元素的高度也要计算在内，也就是说技术BFC区域内只有一个浮动元素，BFC的高度也不会发生塌缩，所以达到了清除浮动的目的</p><h2 id="css布局"><a href="#css布局" class="headerlink" title="css布局"></a>css布局</h2><p>   六种布局方式总结：圣杯布局、双飞翼布局、Flex布局、绝对定位布局、表格布局、网格布局。<br>   圣杯布局是指布局从上到下分为header、container、footer，然后container部分定为三栏布局。这种布局方式同样分为header、container、footer。圣杯布局的缺陷在于 center 是在 container 的padding中的，因此宽度小的时候会出现混乱。<br>   双飞翼布局给center 部分包裹了一个 main 通过设置margin主动地把页面撑开。<br>   Flex布局是由CSS3提供的一种方便的布局方式。<br>   绝对定位布局是给container 设置position: relative和overflow: hidden，因为绝对定位的元素的参照物为第一个postion不为static的祖先元素。 left 向左浮动，right 向右浮动。center 使用绝对定位，通过设置left和right并把两边撑开。 center 设置top: 0和bottom: 0使其高度撑开。<br>   表格布局的好处是能使三栏的高度统一。<br>   网格布局可能是最强大的布局方式了，使用起来极其方便，但目前而言，兼容性并不好。网格布局，可以将页面分割成多个区域，或者用来定义内部元素的大小，位置，图层关系。 </p><h2 id="说一下闭包"><a href="#说一下闭包" class="headerlink" title="说一下闭包"></a>说一下闭包</h2><p>   一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。 </p><p>  （1）什么是闭包：  闭包是指有权访问另外一个函数作用域中的变量的函数。闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。 </p><p>（2）为什么要用：  匿名自执行函数：我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。  结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。  </p><h2 id="类的继承和创建"><a href="#类的继承和创建" class="headerlink" title="类的继承和创建"></a>类的继承和创建</h2><p> （1）类的创建（es5）：new一个function，在这个function的prototype里面增加属性和方法。<br>下面来创建一个Animal类：<br>// 定义一个动物类<br>function Animal (name) {<br>// 属性<br>this.name = name || ‘Animal’;<br>// 实例方法<br>this.sleep = function(){<br>console.log(this.name + ‘正在睡觉！’);<br>}<br>}<br>// 原型方法<br>Animal.prototype.eat = function(food) {<br>console.log(this.name + ‘正在吃：’ + food);<br>};<br>这样就生成了一个Animal类，实力化生成对象后，有方法和属性。<br>（2）类的继承——原型链继承<br>–原型链继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.name = <span class="string">'cat'</span>;</span><br><span class="line"><span class="comment">//　Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.eat(<span class="string">'fish'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>介绍：在这里我们可以看到new了一个空对象,这个空对象指向Animal并且Cat.prototype指向了这个空对象，这种就是基于原型链的继承。<br>特点：基于原型链，既是父类的实例，也是子类的实例<br>缺点：无法实现多继承<br>（3）构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">Animal.call(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>特点：可以实现多继承<br>缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。<br>（4）实例继承和拷贝继承<br>实例继承：为父类实例添加新特性，作为子类实例返回<br>拷贝继承：拷贝父类元素上的属性和方法<br>上述两个实用性不强，不一一举例。<br>（5）组合继承：相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">Animal.call(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>特点：可以继承实例属性/方法，也可以继承原型属性/方法<br>缺点：调用了两次父类构造函数，生成了两份实例<br>（6）寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">Animal.call(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br></pre></td></tr></table></figure><p>// 创建一个没有实例方法的类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Super.prototype = Animal.prototype;</span><br></pre></td></tr></table></figure><p>//将实例作为子类的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>较为推荐 </p><h2 id="说说前端中的事件流"><a href="#说说前端中的事件流" class="headerlink" title="说说前端中的事件流"></a>说说前端中的事件流</h2><p>HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。<br>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。<br>事件捕获阶段<br>处于目标阶段<br>事件冒泡阶段<br>addEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。<br>IE只支持事件冒泡。 </p><h2 id="如何让事件先冒泡后捕获"><a href="#如何让事件先冒泡后捕获" class="headerlink" title="如何让事件先冒泡后捕获"></a>如何让事件先冒泡后捕获</h2><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。 </p><h2 id="说一下事件委托"><a href="#说一下事件委托" class="headerlink" title="说一下事件委托"></a>说一下事件委托</h2><p>事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。<br>举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。<br>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。 </p><h2 id="mouseover和mouseenter的区别"><a href="#mouseover和mouseenter的区别" class="headerlink" title="mouseover和mouseenter的区别"></a>mouseover和mouseenter的区别</h2><p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout<br>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave </p><h2 id="js的new操作符做了哪些事情"><a href="#js的new操作符做了哪些事情" class="headerlink" title="js的new操作符做了哪些事情"></a>js的new操作符做了哪些事情</h2><p>new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。 </p><h2 id="改变函数内部this指针的指向函数（bind，apply，call的区别）"><a href="#改变函数内部this指针的指向函数（bind，apply，call的区别）" class="headerlink" title="改变函数内部this指针的指向函数（bind，apply，call的区别）"></a>改变函数内部this指针的指向函数（bind，apply，call的区别）</h2><p>通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2…这种形式。通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。  </p><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。 </p><p> call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。 </p><p> bind除了返回是函数以外，它的参数和call一样。 </p><h2 id="js的各种位置，比如clientHeight-scrollHeight-offsetHeight-以及scrollTop-offsetTop-clientTop的区别？"><a href="#js的各种位置，比如clientHeight-scrollHeight-offsetHeight-以及scrollTop-offsetTop-clientTop的区别？" class="headerlink" title="js的各种位置，比如clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？"></a>js的各种位置，比如clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？</h2><p>clientHeight：表示的是可视区域的高度，不包含border和滚动条<br>offsetHeight：表示可视区域的高度，包含了border和滚动条<br>scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。<br>clientTop：表示边框border的厚度，在未指定的情况下一般为0<br>scrollTop：滚动后被隐藏的高度，获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)距离顶端的高度。 </p><h2 id="js拖拽功能的实现"><a href="#js拖拽功能的实现" class="headerlink" title="js拖拽功能的实现"></a>js拖拽功能的实现</h2><p>首先是三个事件，分别是mousedown，mousemove，mouseup<br>当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mousemove里面的具体方法。<br>clientX，clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用offsetX和offsetY来表示元素的元素的初始坐标，移动的举例应该是：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标。<br>也就是说定位信息为：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.<br>还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的left<br>以及top等等值。<br>补充：也可以通过html5的拖放（Drag 和 drop）来实现 </p><h2 id="JS中的垃圾回收机制"><a href="#JS中的垃圾回收机制" class="headerlink" title="JS中的垃圾回收机制"></a>JS中的垃圾回收机制</h2><p> 必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。<br>这段话解释了为什么需要系统需要垃圾回收，JS不像C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：<br>var a=”hello world”;<br>var b=”world”;<br>var a=b;<br>//这时，会释放掉”hello world”，释放内存以便再引用<br>垃圾回收的方法：标记清除、计数引用。<br>标记清除<br>这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。<br>垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。<br>引用计数法<br>另一种不太常见的方法就是引用计数法，引用计数法的意思就是每个值没引用的次数，当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减1，当这个值的引用次数为0的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为0的这些值。<br>用引用计数法会存在内存泄露，下面来看原因：<br>function problem() {<br>var objA = new Object();<br>var objB = new Object();<br>objA.someOtherObject = objB;<br>objB.anotherObject = objA;<br>}<br>在这个例子里面，objA和objB通过各自的属性相互引用，这样的话，两个对象的引用次数都为2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为0，这样的相互引用如果大量存在就会导致内存泄露。<br>特别是在DOM对象中，也容易存在这种问题：<br>var element=document.getElementById（’‘）；<br>var myObj=new Object();<br>myObj.element=element;<br>element.someObject=myObj;<br>这样就不会有垃圾回收的过程。 </p><h2 id="eval是做什么的"><a href="#eval是做什么的" class="headerlink" title="eval是做什么的"></a>eval是做什么的</h2><p>它的功能是将对应的字符串解析成js并执行，应该避免使用js，因为非常消耗性能（2次，一次解析成js，一次执行） </p><h2 id="如何理解前端模块化"><a href="#如何理解前端模块化" class="headerlink" title="如何理解前端模块化"></a>如何理解前端模块化</h2><p>前端模块化就是复杂的文件编程一个一个独立的模块，比如js文件等等，分成独立的模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问题，所以有了commonJS规范，AMD，CMD规范等等，以及用于js打包（编译等处理）的工具webpack </p><h2 id="对象深度克隆的简单实现"><a href="#对象深度克隆的简单实现" class="headerlink" title="对象深度克隆的简单实现"></a>对象深度克隆的简单实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> newObj= obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? []:&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> obj)&#123;</span><br><span class="line"><span class="keyword">var</span> temple= <span class="keyword">typeof</span> obj[item] == <span class="string">'object'</span> ? deepClone(obj[item]):obj[item];</span><br><span class="line">newObj[item] = temple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5的常用的对象克隆的一种方式。注意数组是对象，但是跟对象又有一定区别，所以我们一开始判断了一些类型，决定newObj是对象还是数组</p><h2 id="实现一个once函数，传入函数参数只执行一次"><a href="#实现一个once函数，传入函数参数只执行一次" class="headerlink" title="实现一个once函数，传入函数参数只执行一次"></a>实现一个once函数，传入函数参数只执行一次</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ones</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> tag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag==<span class="literal">true</span>)&#123;</span><br><span class="line">func.apply(<span class="literal">null</span>,<span class="built_in">arguments</span>);</span><br><span class="line">tag=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js监听对象属性的改变"><a href="#js监听对象属性的改变" class="headerlink" title="js监听对象属性的改变"></a>js监听对象属性的改变</h2><p> 我们假设这里有一个user对象,<br>(1)在ES5中可以通过Object.defineProperty来实现已有属性的监听<br>Object.defineProperty(user,’name’,{<br>set：function(key,value){<br>}<br>})<br>缺点：如果id不在user对象中，则不能监听id的变化<br>(2)在ES6中可以通过Proxy来实现<br>var  user = new Proxy({}，{<br>set：function(target,key,value,receiver){<br>}<br>})<br>这样即使有属性在user中不存在，通过user.id来定义也同样可以这样监听这个属性的变化哦~ </p><h2 id="如何实现一个私有变量，用getName方法可以访问，不能直接访问"><a href="#如何实现一个私有变量，用getName方法可以访问，不能直接访问" class="headerlink" title="如何实现一个私有变量，用getName方法可以访问，不能直接访问"></a>如何实现一个私有变量，用getName方法可以访问，不能直接访问</h2><p>(1)通过defineProperty来实现<br>obj={<br>name:yuxiaoliang,<br>getName:function(){<br>return this.name<br>}<br>}<br>object.defineProperty(obj,”name”,{<br>//不可枚举不可配置<br>});<br>(2)通过函数的创建形式<br>function product(){<br>var name=’yuxiaoliang’;<br>this.getName=function(){<br>return name;<br>}<br>}<br>var obj=new product();</p><h2 id="和-、以及Object-is的区别"><a href="#和-、以及Object-is的区别" class="headerlink" title="==和===、以及Object.is的区别"></a><code>==</code>和<code>===</code>、以及Object.is的区别</h2><p> (1)<code>==</code><br>主要存在：强制转换成number,null==undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" "</span>==<span class="number">0</span>  <span class="comment">//true</span></span><br><span class="line"><span class="string">"0"</span>==<span class="number">0</span>  <span class="comment">//true</span></span><br><span class="line"><span class="string">" "</span> !=<span class="string">"0"</span> <span class="comment">//true</span></span><br><span class="line"><span class="number">123</span>==<span class="string">"123"</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">null</span>==<span class="literal">undefined</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>(2)Object.js<br>主要的区别就是<code>+0！=-0</code>而<code>NaN==NaN</code><br>(相对比<code>===</code>和<code>==</code>的改进) </p><h2 id="setTimeout、setInterval和requestAnimationFrame之间的区别"><a href="#setTimeout、setInterval和requestAnimationFrame之间的区别" class="headerlink" title="setTimeout、setInterval和requestAnimationFrame之间的区别"></a>setTimeout、setInterval和requestAnimationFrame之间的区别</h2><p>这里有一篇文章讲的是requestAnimationFrame：<a href="http://www.cnblogs.com/xiaohuochai/p/5777186.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaohuochai/p/5777186.html</a><br>与setTimeout和setInterval不同，requestAnimationFrame不需要设置时间间隔，<br>大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms。<br>RAF采用的是系统时间间隔，不会因为前面的任务，不会影响RAF，但是如果前面的任务多的话，<br>会响应setTimeout和setInterval真正运行时的时间间隔。<br>特点：<br>（1）requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。<br>（2）在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量<br>（3）requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。 </p><h2 id="实现一个两列等高布局，讲讲思路"><a href="#实现一个两列等高布局，讲讲思路" class="headerlink" title="实现一个两列等高布局，讲讲思路"></a>实现一个两列等高布局，讲讲思路</h2><p>为了实现两列等高，可以给每列加上 padding-bottom:9999px;<br>margin-bottom:-9999px;同时父元素设置overflow:hidden; </p><h2 id="this的指向-哪几种"><a href="#this的指向-哪几种" class="headerlink" title="this的指向 哪几种"></a>this的指向 哪几种</h2><p>默认绑定：全局环境中，this默认绑定到window。<br>隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，this隐式绑定到该直接对象。<br>隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到window。显式绑定：通过call()、apply()、bind()方法把对象绑定到this上，叫做显式绑定。<br>new绑定：如果函数或者方法调用之前带有关键字new，它就构成构造函数调用。对于this绑定来说，称为new绑定。<br>【1】构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。<br>【2】如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。<br>【3】如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象。 </p><h2 id="数组移除第一个元素的方法"><a href="#数组移除第一个元素的方法" class="headerlink" title="数组移除第一个元素的方法"></a>数组移除第一个元素的方法</h2><p>splice和shift方法</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>把一个元素响应事件（click、keydown……）的函数委托到另一个元素；<br>优点：减少内存消耗、动态绑定事件。 </p><h2 id="dom是什么，你的理解？"><a href="#dom是什么，你的理解？" class="headerlink" title="dom是什么，你的理解？"></a>dom是什么，你的理解？</h2><p>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。 </p><h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>事件代理是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件代理，代理它们父级代为执行事件。   事件代理/事件委托：利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的事件，   简而言之：事件代理就是说我们将事件添加到本来要添加的事件的父节点，将事件委托给父节点来触发处理函数，这通常会使用在大量的同级元素需要添加同一类事件的时候，比如一个动态的非常多的列表，需要为每个列表项都添加点击事件，这时就可以使用事件代理，通过判断e.target.nodeName来判断发生的具体元素，这样做的好处是减少事件绑定，同事动态的DOM结构任然可以监听，事件代理发生在冒泡阶段  </p><h2 id="箭头函数和function的区别"><a href="#箭头函数和function的区别" class="headerlink" title="箭头函数和function的区别"></a>箭头函数和function的区别</h2><p>箭头函数根本就没有绑定自己的this，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用 </p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>arguments是类数组对象，有length属性，不能调用数组方法<br>可用Array.from()转换 </p><h2 id="箭头函数获取arguments"><a href="#箭头函数获取arguments" class="headerlink" title="箭头函数获取arguments"></a>箭头函数获取arguments</h2><p>可用…rest参数获取</p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>法一：indexOf循环去重<br>法二：ES6 Set去重；Array.from(new Set(array))<br>法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。 </p><h2 id="es6的常用"><a href="#es6的常用" class="headerlink" title="es6的常用"></a>es6的常用</h2><p>promise，await/async，let，const，块级作用域，箭头函数</p><h2 id="引用类型常见的对象"><a href="#引用类型常见的对象" class="headerlink" title="引用类型常见的对象"></a>引用类型常见的对象</h2><p>Object、Array、RegExp、Date、Function、特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)等 </p><h2 id="JS的数据类型"><a href="#JS的数据类型" class="headerlink" title="JS的数据类型"></a>JS的数据类型</h2><p>字符串，数字，布尔，数组，null，Undefined，symbol，对象。 </p><h2 id="JavaScript中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？"><a href="#JavaScript中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？" class="headerlink" title="JavaScript中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？"></a>JavaScript中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？</h2><p>图片轮播的原理就是图片排成一行，然后准备一个只有一张图片大小的容器，对这个容器设置超出部分隐藏，在控制定时器来让这些图片整体左移或右移，这样呈现出来的效果就是图片在轮播了。<br>如果有两个轮播，可封装一个轮播组件，供两处调用 </p><h2 id="js对象类型，基本对象类型以及引用对象类型的区别"><a href="#js对象类型，基本对象类型以及引用对象类型的区别" class="headerlink" title="js对象类型，基本对象类型以及引用对象类型的区别"></a>js对象类型，基本对象类型以及引用对象类型的区别</h2><p>分为基本对象类型和引用对象类型<br>基本数据类型：按值访问，可操作保存在变量中的实际的值。基本类型值指的是简单的数据段。基本数据类型有这六种:undefined、null、string、number、boolean、symbol。<br>引用类型：当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。引用类型值指那些可能为多个值构成的对象。<br>引用类型有这几种：Object、Array、RegExp、Date、Function、特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)。 </p><h2 id="js加载过程阻塞，解决方法。"><a href="#js加载过程阻塞，解决方法。" class="headerlink" title="js加载过程阻塞，解决方法。"></a>js加载过程阻塞，解决方法。</h2><p>指定script标签的async属性。<br>如果async=”async”，脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）<br>如果不使用async 且 defer=”defer”：脚本将在页面完成解析时执行 </p><h2 id="private和public"><a href="#private和public" class="headerlink" title="private和public"></a>private和public</h2><p>public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用<br>private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用 </p><h2 id="怎么获得对象上的属性：比如说通过Object-key（）"><a href="#怎么获得对象上的属性：比如说通过Object-key（）" class="headerlink" title="怎么获得对象上的属性：比如说通过Object.key（）"></a>怎么获得对象上的属性：比如说通过Object.key（）</h2><p>从ES5开始，有三种方法可以列出对象的属性<br>for（let I in obj）该方法依次访问一个对象及其原型链中所有可枚举的类型<br>object.keys:返回一个数组，包括所有可枚举的属性名称<br>object.getOwnPropertyNames:返回一个数组包含不可枚举的属性 </p><h2 id="js原型链，原型链的顶端是什么？Object的原型是什么？Object的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法"><a href="#js原型链，原型链的顶端是什么？Object的原型是什么？Object的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法" class="headerlink" title="js原型链，原型链的顶端是什么？Object的原型是什么？Object的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法"></a>js原型链，原型链的顶端是什么？Object的原型是什么？Object的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法</h2><p>能够把这个讲清楚弄明白是一件很困难的事，<br>首先明白原型是什么，在ES6之前，JS没有类和继承的概念，JS是通过原型来实现继承的，在JS中一个构造函数默认带有一个prototype属性，这个的属性值是一个对象，同时这个prototype对象自带有一个constructor属性，这个属性指向这个构造函数，同时每一个实例都会有一个<em>proto_属性指向这个prototype对象，我们可以把这个叫做隐式原型，我们在使用一个实例的方法的时候，会先检查这个实例中是否有这个方法，没有的话就会检查这个prototype对象是否有这个方法，<br>基于这个规则，如果让原型对象指向另一个类型的实例，即constructor1.protoytpe=instance2，这时候如果试图引用constructor1构造的实例instance1的某个属性p1,<br>首先会在instance1内部属性中找一遍，<br>接着会在instance1._proto_（constructor1.prototype）即是instance2中寻找p1<br>搜寻轨迹：instance1-&gt;instance2-&gt;constructor2.prototype……-&gt;Object.prototype;这即是原型链，原型链顶端是Object.prototype<br>补充学习：<br>每个函数都有一个prototype属性，这个属性指向了一个对象，这个对象正是调用该函数而创建的实例的原型，那么什么是原型呢，可以这样理解，每一个JavaScript对象在创建的时候就会预制管理另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性，如图：  <img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552431147224_7A94EFA1E3409049184A20DD1711F1B6" alt="img"><br>那么怎么表示实例与实例原型的关系呢，这时候就要用到第二个属性_proto</em><br>这是每一个JS对象都会有的一个属性，指向这个对象的原型，如图：  <img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552431218799_241BFEF25322EAB2AC14C47F68A7E31F" alt="img"><br>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢，指向实例是没有的，因为一个构造函数可以生成多个实例，但是原型有属性可以直接指向构造函数，通过constructor即可<br>接下来讲解实例和原型的关系：<br>当读取实例的属性时，如果找不到，就会查找与对象相关的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层，那么原型的原型是什么呢，首先，原型也是一个对象，既然是对象，我们就可以通过构造函数的方式创建它，所以原型对象就是通过Object构造函数生成的，如图：<img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552431256187_AE645DCD4DDEE468730F9EE81F7D1983" alt="img"><br>那么Object.prototype的原型呢，我们可以打印console.log(Object.prototype.<strong>proto</strong> === null)，返回true<br>null表示没有对象，即该处不应有值，所以Object.prototype没有原型，如图：  <img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552431329816_BC67B14895C30FC45BA53BF8B01127BF" alt="img"><br>图中这条蓝色的线即是原型链，<br>最后补充三点：<br>constructor：<br>function Person(){<br>}<br>var person = new Person();<br>console.log(Person === person.constructor);<br>原本person中没有constructor属性，当不能读取到constructor属性时，会从person的原型中读取，所以指向构造函数Person<br><strong>proto</strong>：<br>绝大部分浏览器支持这个非标准的方法访问原型，然而它并不存在与Person.prototype中，实际上它来自Object.prototype，当使用obj.<strong>proto</strong>时，可以理解为返回来Object.getPrototype(obj)<br>继承：<br>前面说到，每个对象都会从原型继承属性，但是引用《你不知道的JS》中的话，继承意味着复制操作，然而JS默认不会复制对象的属性，相反，JS只是在两个对象之间创建一个关联，这样子一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，叫委托更合适</p><h2 id="let-const-var的区别-，什么是块级作用域，如何用ES5的方法实现块级作用域（立即执行函数），ES6-呢"><a href="#let-const-var的区别-，什么是块级作用域，如何用ES5的方法实现块级作用域（立即执行函数），ES6-呢" class="headerlink" title="let const var的区别 ，什么是块级作用域，如何用ES5的方法实现块级作用域（立即执行函数），ES6 呢"></a>let const var的区别 ，什么是块级作用域，如何用ES5的方法实现块级作用域（立即执行函数），ES6 呢</h2><p>提起这三个最明显的区别是var声明的变量是全局或者整个函数块的，而let,const声明的变量是块级的变量，var声明的变量存在变量提升，let,const不存在，let声明的变量允许重新赋值，const不允许</p><h2 id="JS中string的startwith和indexof两种方法的区别"><a href="#JS中string的startwith和indexof两种方法的区别" class="headerlink" title="JS中string的startwith和indexof两种方法的区别"></a>JS中string的startwith和indexof两种方法的区别</h2><p> JS中startwith函数，其参数有3个，stringObj,要搜索的字符串对象，str，搜索的字符串，position，可选，从哪个位置开始搜索，如果以position开始的字符串以搜索字符串开头，则返回true，否则返回false<br>Indexof函数，indexof函数可返回某个指定字符串在字符串中首次出现的位置</p><h2 id="有了解过事件模型吗，DOM0级和DOM2级有什么区别，DOM的分级是什么"><a href="#有了解过事件模型吗，DOM0级和DOM2级有什么区别，DOM的分级是什么" class="headerlink" title="有了解过事件模型吗，DOM0级和DOM2级有什么区别，DOM的分级是什么"></a>有了解过事件模型吗，DOM0级和DOM2级有什么区别，DOM的分级是什么</h2><p>JSDOM事件流存在如下三个阶段：<br>事件捕获阶段<br>处于目标阶段<br>事件冒泡阶段<br>JSDOM标准事件流的触发的先后顺序为：先捕获再冒泡，点击DOM节点时，事件传播顺序：事件捕获阶段，从上往下传播，然后到达事件目标节点，最后是冒泡阶段，从下往上传播<br>DOM节点添加事件监听方法addEventListener，中参数capture可以指定该监听是添加在事件捕获阶段还是事件冒泡阶段，为false是事件冒泡，为true是事件捕获，并非所有的事件都支持冒泡，比如focus，blur等等，我们可以通过event.bubbles来判断<br>事件模型有三个常用方法：<br>event.stopPropagation:阻止捕获和冒泡阶段中，当前事件的进一步传播，<br>event.stopImmediatePropagetion，阻止调用相同事件的其他侦听器，<br>event.preventDefault，取消该事件（假如事件是可取消的）而不停止事件的进一步传播，<br>event.target：指向触发事件的元素，在事件冒泡过程中这个值不变<br>event.currentTarget = this，时间帮顶的当前元素，只有被点击时目标元素的target才会等于currentTarget，<br>最后，对于执行顺序的问题，如果DOM节点同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序真的是先捕获在冒泡吗，答案是否定的，绑定在被点击元素的事件是按照代码添加顺序执行的，其他函数是先捕获再冒泡 </p><h2 id="setTimeout-fn-100-100毫秒是如何权衡的"><a href="#setTimeout-fn-100-100毫秒是如何权衡的" class="headerlink" title="setTimeout(fn,100);100毫秒是如何权衡的"></a>setTimeout(fn,100);100毫秒是如何权衡的</h2><p>etTimeout()函数只是将事件插入了任务列表，必须等到当前代码执行完，主线程才会去执行它指定的回调函数，有可能要等很久，所以没有办法保证回调函数一定会在setTimeout指定的时间内执行，100毫秒是插入队列的时间+等待的时间 </p><h2 id="深浅拷贝的区别和实现"><a href="#深浅拷贝的区别和实现" class="headerlink" title="深浅拷贝的区别和实现"></a>深浅拷贝的区别和实现</h2><p>数组的浅拷贝：<br>如果是数组，我们可以利用数组的一些方法，比如slice，concat方法返回一个新数组的特性来实现拷贝，但假如数组嵌套了对象或者数组的话，使用concat方法克隆并不完整，如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化，我们把这种复制引用的拷贝方法称为浅拷贝，<br>深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也互相分离，修改一个对象的属性，不会影响另一个<br>如何深拷贝一个数组<br>1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'old'</span>, <span class="number">1</span>, <span class="literal">true</span>, [<span class="string">'old1'</span>, <span class="string">'old2'</span>], &#123;<span class="attr">old</span>: <span class="number">1</span>&#125;]</span><br><span class="line"><span class="keyword">var</span> new_arr = <span class="built_in">JSON</span>.parse( <span class="built_in">JSON</span>.stringify(arr) );</span><br><span class="line"><span class="built_in">console</span>.log(new_arr);</span><br></pre></td></tr></table></figure><p>原理是JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象，通过这两个方法，也可以实现对象的深复制。<br>但是这个方法不能够拷贝函数<br>浅拷贝的实现：<br>以上三个方法concat,slice ,JSON.stringify都是技巧类，根据实际项目情况选择使用，我们可以思考下如何实现一个对象或数组的浅拷贝，遍历对象，然后把属性和属性值都放在一个新的对象里即可    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shallowCopy = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 只拷贝对象</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 根据obj的类型判断是新建一个数组还是对象</span></span><br><span class="line"><span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line"><span class="comment">// 遍历obj，并且判断是obj的属性才拷贝</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">newObj[key] = obj[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深拷贝的实现<br>那如何实现一个深拷贝呢？说起来也好简单，我们在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数不就好了~    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deepCopy = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">newObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ? deepCopy(obj[key]) : obj[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同数据类型的值的比较，是怎么转换的，有什么规则"><a href="#不同数据类型的值的比较，是怎么转换的，有什么规则" class="headerlink" title="不同数据类型的值的比较，是怎么转换的，有什么规则   "></a>不同数据类型的值的比较，是怎么转换的，有什么规则   <img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552428573113_1325658F6CAFABD8492C05155F5B8281" alt="img"></h2><h2 id="去除字符串首尾空格"><a href="#去除字符串首尾空格" class="headerlink" title="去除字符串首尾空格"></a>去除字符串首尾空格</h2><p>使用正则(^\s<em>)|(\s</em>$)即可 </p><h2 id="如何判断一个数组-讲到typeof差点掉坑里"><a href="#如何判断一个数组-讲到typeof差点掉坑里" class="headerlink" title="如何判断一个数组(讲到typeof差点掉坑里)"></a>如何判断一个数组(讲到typeof差点掉坑里)</h2><p>instanceof<br>Object.prototype.call.toString()</p><h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><p>push()，pop()，shift()，unshift()，splice()，sort()，reverse()，map()等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试&quot;&gt;&lt;a href=&quot;#面试&quot; class=&quot;headerlink&quot; title=&quot;面试&quot;&gt;&lt;/a&gt;面试&lt;/h1&gt;&lt;h2 id=&quot;几个很实用的BOM属性对象方法？&quot;&gt;&lt;a href=&quot;#几个很实用的BOM属性对象方法？&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>简单使用hexo</title>
    <link href="http://yoursite.com/2019/07/15/Hexo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/07/15/Hexo简单使用/</id>
    <published>2019-07-15T01:23:08.989Z</published>
    <updated>2019-07-15T03:06:09.550Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
