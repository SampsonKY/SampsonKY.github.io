<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SampsonKY&#39;blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-17T08:46:06.636Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SampsonKY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js的new操作符</title>
    <link href="http://yoursite.com/2019/07/17/js%E7%9A%84new%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://yoursite.com/2019/07/17/js的new操作符/</id>
    <published>2019-07-17T07:08:13.473Z</published>
    <updated>2019-07-17T08:46:06.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js的new操作符"><a href="#js的new操作符" class="headerlink" title="js的new操作符"></a>js的new操作符</h1><p>我们先来了解一下<code>new</code>运算符的基本概念：</p><p><code>new</code><strong>运算符</strong>创建一个用户自定义的对象类型的实例或具有构造函数的内置对象的实例。<code>new</code>关键字会进行如下操作：</p><ol><li>先创建一个新的空的简单JavaScript对象（即<code>{}</code>）</li><li>然后让这个空对象的<code>_proto_</code>指向函数的原型<code>prototype</code></li><li>将步骤1创建的对象作为<code>this</code>的上下文（将对象作为函数的this传进去）</li><li>如果该函数没有返回对象，则返回<code>this</code></li></ol><p>再来看一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>);</span><br><span class="line"><span class="keyword">var</span> person1 = Person(<span class="string">"Tom"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">//Person &#123; name: 'Tom' &#125;（返回的是构造函数实例化后的对象）</span></span><br><span class="line"><span class="built_in">console</span>.log(person1);<span class="comment">//Tom</span></span><br></pre></td></tr></table></figure><p>可以看到，有<code>new</code>和没<code>new</code>的区别所在，现在分析一下<code>new</code>做了什么</p><p>当代码<code>new Person(...)</code>执行时，会发生以下事情：</p><ol><li>一个继承自<code>Person.prototype</code>的新对象被创建</li><li>使用参数<code>Tom</code>调用构造函数<code>Person</code>，并将<code>this</code>绑定到新创建的对象。</li><li>由构造函数<code>Person</code>返回的对象就是 <code>new</code> 表达式的结果（即构造函数实例化后的对象）。</li></ol><p>那要是构造函数返回的是一个对象呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">name</span> : <span class="string">"Gates"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>); <span class="comment">//Person&#123; name: 'Gates'&#125;</span></span><br><span class="line"><span class="keyword">var</span> person1 = Person(<span class="string">"Tom"</span>);<span class="comment">//Person&#123; name: 'Gates'&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，当函数返回的是对象时，则返回的即为该对象。</p><p>可是，当构造函数返回null，undefined等非对象时，情况又是什么样的？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>); <span class="comment">//Person&#123; name: 'Tom'&#125;</span></span><br><span class="line"><span class="keyword">var</span> person1 = Person(<span class="string">"Tom"</span>);<span class="comment">//null</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>return null</code>时（当使用<code>new</code>操作符）返回的也是构造函数实例后的对象。这是因为<code>null、undefined</code>为非对象，所以<code>return</code>的其实为<code>this</code></p><p>那，要是没有<code>return</code>语句呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>); <span class="comment">//Person&#123; name: 'Tom'&#125;</span></span><br><span class="line"><span class="keyword">var</span> person1 = Person(<span class="string">"Tom"</span>); <span class="comment">//Undefined</span></span><br></pre></td></tr></table></figure><p>其实，如果在JavaScript没有<code>return</code>语句，那么函数就会默认<code>return this</code></p><p>所以，我们可以得出结论：当我们使用了<code>new</code>操作符时，<strong>①构造函数如果没有返回对象，那么这个返回值毫无意义；②构造函数如果返回值为对象，那么这个返回值会被正常使用</strong></p><p>接下来，我们再看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//Tom</span></span><br><span class="line">person.sayName();  <span class="comment">//Tom</span></span><br></pre></td></tr></table></figure><p>从这里，我们可以看出<code>new</code>操作符的一些作用：</p><ul><li><strong><code>new</code> 通过构造函数<code>Person</code> 创建出来的实例可以访问到构造函数中的属性</strong></li><li><strong><code>new</code> 通过构造函数<code>Person</code> 创建出来的实例可以访问到构造函数原型链中的属性，也就是说通过 new 操作符，实例与构造函数通过原型链连接了起来</strong></li></ul><p>最后，我们可以自己尝试模拟实现<code>new</code>运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123; <span class="comment">//(Con, ...args)函数接收不定量的参数，第一个参数为构造函数，接下来的参数被构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; <span class="comment">//内部创建一个空对象obj</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    obj._proto_ = Con.prototype;</span><br><span class="line">    <span class="comment">//将新对象的内部属性__proto__指向构造函数的原型，这样新对象就可以访问原型中的属性和方法。等同于Object.setPrototypeOf(obj, Con.prototype);</span></span><br><span class="line"><span class="keyword">var</span> result = Con.apply(obj, <span class="built_in">arguments</span>);<span class="comment">//使用apply，将构造函数中的this指向新对象，这样新对象就可以访问构造函数中的属性和方法；将obj对象绑定到构造函数上，并且传入剩余参数</span></span><br><span class="line"><span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj;<span class="comment">//判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 obj，这样就实现了忽略构造函数返回的原始值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = objectFactory(Person, <span class="string">'Tom'</span>);</span><br></pre></td></tr></table></figure><p>参考资料：</p><ul><li><p>MDN文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new</a></p></li><li><p>通过例子深入了解new：<a href="https://www.cnblogs.com/shuaihan/p/7392771.html" target="_blank" rel="noopener">https://www.cnblogs.com/shuaihan/p/7392771.html</a></p></li><li><p>一道面试题引发的思考：<a href="https://juejin.im/post/5c1bbc16e51d4552e01a0114" target="_blank" rel="noopener">https://juejin.im/post/5c1bbc16e51d4552e01a0114</a></p></li><li><p>聊聊new操作符：<a href="https://juejin.im/post/5c7b963ae51d453eb173896e" target="_blank" rel="noopener">https://juejin.im/post/5c7b963ae51d453eb173896e</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;js的new操作符&quot;&gt;&lt;a href=&quot;#js的new操作符&quot; class=&quot;headerlink&quot; title=&quot;js的new操作符&quot;&gt;&lt;/a&gt;js的new操作符&lt;/h1&gt;&lt;p&gt;我们先来了解一下&lt;code&gt;new&lt;/code&gt;运算符的基本概念：&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>HTML、CSS面试</title>
    <link href="http://yoursite.com/2019/07/15/HTML%E3%80%81CSS%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/07/15/HTML、CSS面试/</id>
    <published>2019-07-15T03:09:04.945Z</published>
    <updated>2019-07-17T08:52:34.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-了解什么是Web"><a href="#1-了解什么是Web" class="headerlink" title="1.了解什么是Web"></a>1.了解什么是Web</h2><p>   web即全球广域网，也称万维网。它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。它有三种表现形式：超文本、超媒体、超文本协议。</p><h2 id="2-HTML是什么，HTML5是什么"><a href="#2-HTML是什么，HTML5是什么" class="headerlink" title="2.HTML是什么，HTML5是什么"></a>2.HTML是什么，HTML5是什么</h2><p>   HTML  不是一门编程语言，而是一种用来告知浏览器如何组织页面的标记语言。它用来构造一个网页的基本骨架，由一系列的元素组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。 </p><p>   html5是html的最新标准。</p><h2 id="3-HTML元素标签、属性都是什么概念？"><a href="#3-HTML元素标签、属性都是什么概念？" class="headerlink" title="3.HTML元素标签、属性都是什么概念？"></a>3.HTML元素标签、属性都是什么概念？</h2><h3 id="一：标签"><a href="#一：标签" class="headerlink" title="一：标签"></a>一：标签</h3><p>   标签用来标记内容块，也用来标明元素内容的意义，标签使用尖括号包围，如<html>和</html>，这两个标签表示一个HTML文档。<br>   标签有两种形式：成对出现的标签和单独出现的标签<br>   1、成对出现的标签<br>   成对出现的标签包括开始标签和结束标签，&lt;开始标签&gt;内容&lt;/结束标签&gt;<br>   所谓开始标签，及标志一段内容的开始，例如：<br>   <code>&lt;html&gt;</code>表示HTML文档开始了；到<code>&lt;/html&gt;</code>结束，从而形成一个HTML文档。<br>   <code>&lt;head&gt;</code>和<code>&lt;/head&gt;</code>标签描述HTML文档的相关信息，之间的内容不会在浏览器窗口上显示出来<br>   <code>&lt;body&gt;</code>和<code>&lt;/body&gt;</code>标签包含所有要在浏览器窗口上显示的内容，也就是HTML文件的主体部分。<br>   所谓结束标签，是指和开始标签相对的标签。结束标签比开始标签多一个斜杠”/“。<br>   2、单独出现的标签<br>   虽然并不是所有的开始标签都必须有结束标签对应<code>&lt;br&gt;&lt;hr&gt;&lt;img&gt;&lt;input&gt;&lt;link&gt;&lt;meta&gt;</code>等<br>   3、标签的嵌套<br>   标签可以放在另外一个标签所能影响的片段中，以实现对某一段文档的多重标签效果，但是要注意必须要正确嵌套。</p><h3 id="二：元素"><a href="#二：元素" class="headerlink" title="二：元素"></a>二：元素</h3><p>   标签是为一个元素的开始和结束做标记，网页内容是由元素组成的，一个元素通常由一个开始标签、内容、其他元素及一个结束标签组成。</p><p>   如<code>&lt;head&gt;和&lt;/head&gt;</code>是标签，但是下面的就是一个head元素：</p><p>   <code>&lt;head&gt;&lt;title&gt;HTML中的几个基本概念------标签、元素、属性&lt;/title&gt;&lt;/head&gt;</code></p><p>   其中<code>&lt;title&gt;&lt;/title&gt;</code>是标签，但</p><p> <code>&lt;title&gt;HTML中的几个基本概念------标签、元素、属性&lt;/title&gt;</code></p><p>   又是一个title元素，同时这个title元素又是嵌套在head元素中的另一个元素。</p><h3 id="三：属性"><a href="#三：属性" class="headerlink" title="三：属性"></a>三：属性</h3><p>与元素相关的特性叫做属性，可以为属性赋值，属性包含元素的额外信息，这些信息不会出现在实际的内容中<br>  ①：不定义属性值<br>  HTML规定属性也可以没有值<br>   浏览器会使用compact属性的默认值，但有的属性没有默认值，因此不能省略属性值。</p><h2 id="4-文档类型doctype是什么概念，起什么作用？"><a href="#4-文档类型doctype是什么概念，起什么作用？" class="headerlink" title="4.文档类型doctype是什么概念，起什么作用？"></a>4.文档类型doctype是什么概念，起什么作用？</h2><p>   !DOCTYPE ,是用来声明并帮助浏览器正确识别网页的最短有效声明。因为HTML发展至今有许多的不同版本，所以声明不同的文档类型可以让浏览器完全正确地显示出 HTML 页面。 </p><p>   DOCTYPE是docunment type（文档定义）的简写，用来说明web设计中所用的html或xhtml的类型，指出浏览器或者其他阅读程序按照什么样的规则集去解释文档中的标记.</p><h2 id="5-meta标签都用来做什么的？"><a href="#5-meta标签都用来做什么的？" class="headerlink" title="5.meta标签都用来做什么的？"></a>5.meta标签都用来做什么的？</h2><p>   meta标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。<br>   典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。<br>   meta标签始终位于 head 元素中。<br>   元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p><h2 id="6-Web语义化是什么，是为了解决什么问题"><a href="#6-Web语义化是什么，是为了解决什么问题" class="headerlink" title="6.Web语义化是什么，是为了解决什么问题"></a>6.Web语义化是什么，是为了解决什么问题</h2><p>   简单说来就是让机器可以读懂内容。由编写者对网页内容进行语义化主要可以让不同的人和机器对这段内容的作用和所属有清晰的认识，从而查看或者找到自己需要的内容</p><p>   Web语义化是指使用语义恰当的标签，使页面有良好的结构，页面元素有含义，能够让人和搜索引擎都容易理解。如果可以在合适的位置使用恰当的标签，那么写出来的页面语义明确，结构清晰，搜索引擎也可以认出哪些是页面重要内容，予以较高的权值。</p><p>   web语义化的好处</p><ol><li><p>去掉或者丢失样式的时候能够让页面呈现出清晰的结构</p></li><li><p>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</p></li><li><p>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</p></li><li><p>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p></li></ol><h2 id="7-链接是什么概念，对应什么标签？"><a href="#7-链接是什么概念，对应什么标签？" class="headerlink" title="7.链接是什么概念，对应什么标签？"></a>7.链接是什么概念，对应什么标签？</h2><p>   HTML 使用超级链接与网络上的另一个文档相连。对应a标签。</p><p>   超链接使互联网成为互联的网络。超链接使我们能够将我们的文档链接到任何其他文档（或其他资源），也可以链接到文档的指定部分，我们可以在一个简单的网址上提供应用程序（与必须先安装的本地应用程序或其他东西相比）。几乎任何网络内容都可以转换为链接，点击（或激活）超链接将使网络浏览器转到另一个网址（<a href="https://developer.mozilla.org/en-US/docs/Glossary/URL" target="_blank" rel="noopener">URL</a>）</p><h2 id="8-常用标签都有哪些，都适合用在什么场景"><a href="#8-常用标签都有哪些，都适合用在什么场景" class="headerlink" title="8.常用标签都有哪些，都适合用在什么场景"></a>8.常用标签都有哪些，都适合用在什么场景</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span> 用于超链接。<span class="tag">&lt; <span class="attr">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span>some text<span class="tag">&lt;/ <span class="attr">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span> 用于一篇文章。<span class="tag">&lt; <span class="attr">article</span>&gt;</span>a self-contained article<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span> 用于页面的侧边栏。<span class="tag">&lt;<span class="name">aside</span>&gt;</span>some content<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span> 用于大段的引用内容。<span class="tag">&lt; <span class="attr">blockquote</span>&gt;</span>some big texts<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> 页面上显示的所有内容都被包含在<span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>里</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span> 用于显示一个按钮</span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span> 用于一包裹一段代码内容</span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span> 用于一个dl列表的某个dt名词的描述</span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span> 用于删除一些不需要的文字</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 用于包裹住一些其他的标签，制造一个容器</span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span> 用于制作一个名词和对应解释的列表</span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span> 用于一个dl列表的某个dt名词</span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span> 用于强调一些文本内容</span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span> 用于一张图表的说明文字</span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span> 用于一张图表</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> 用于包裹页面的底部内容</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span> 用于制作一个表单</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>-<span class="tag">&lt;<span class="name">h6</span>&gt;</span> 用于标记标题，从h1到h6重要性依次递减</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> 用于包裹页面的元数据，如<span class="tag">&lt;<span class="name">meta</span>&gt;</span>, <span class="tag">&lt;<span class="name">link</span>&gt;</span>, <span class="tag">&lt;<span class="name">title</span>&gt;</span>等</span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span> 用于包裹页面的头部内容</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> 整个 HTML 文档的根元素，包裹住其他所有的元素</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> &gt;</span> 用于嵌入另一个小页面到一个页面中</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span> 用于显示一张图片</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span> 用于显示一个表格输入控件</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span> 用于给一个表格输入控件打上一个标签，说明输入控件的作用</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> 用于<span class="tag">&lt;<span class="name">ul</span>&gt;</span>和<span class="tag">&lt;<span class="name">ol</span>&gt;</span>标签，代表一个列表项</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span>&gt;</span> 用于链接外部CSS文件</span><br><span class="line"><span class="tag">&lt;<span class="name">mark</span>&gt;</span> 用于高亮显示某些文本</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span> 用于下达一些元数据指令，或者对页面进行说明</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span> 用于包裹住一个导航条的内容</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span> 用于制作一个有序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 用于显示一个段落</span><br><span class="line"><span class="tag">&lt;<span class="name">q</span>&gt;</span> 用于一小段引用文字</span><br><span class="line"><span class="tag">&lt; <span class="attr">script</span>&gt;</span> 用于一段JavaScript脚本代码，或者引入一个外部JavaScript脚本文件</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span> 用于包裹一部分有逻辑关第的页面内容</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span> 用于制作一个下拉列表选框</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span> 用于包裹住一小段文字，作为一个容器</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span> 用于着重强调重要的文本内容</span><br><span class="line"><span class="tag">&lt; <span class="attr">style</span>&gt;</span> 用于给页面元素加上样式</span><br><span class="line"><span class="tag">&lt; <span class="attr">table</span>&gt;</span> 用于制作一个表格</span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span> 用于表格里的主体部分</span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span> 用于表格里的某一个单元格</span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span> 用于制作一大块文本输入框</span><br><span class="line"><span class="tag">&lt;<span class="name">tfoot</span>&gt;</span> 用于表格里的底部</span><br><span class="line"><span class="tag">&lt;<span class="name">th</span>&gt;</span> 用于表格里的表头的单元格</span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span> 用于表格里的表头</span><br><span class="line"><span class="tag">&lt;<span class="name">time</span>&gt;</span> 用于页面内容中的时间</span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span> 用于显示整个页面的标题（显示在浏览器的tab上）</span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span> 用于标记表格里的一行</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> 用于制作一个无序列表</span><br></pre></td></tr></table></figure><h2 id="9-表单标签都有哪些，对应着什么功能，都有哪些属性"><a href="#9-表单标签都有哪些，对应着什么功能，都有哪些属性" class="headerlink" title="9.表单标签都有哪些，对应着什么功能，都有哪些属性"></a>9.表单标签都有哪些，对应着什么功能，都有哪些属性</h2><p>   表单元素是允许用户在表单中(比如:文本域,下拉列表,单选框,复选框等等)输入信息的元素，最主要的作用就是收集信息。表单元素是页面中不可缺少的元素。一般来说，表单包含如下几个部分：</p><ol><li><p>提示信息：表单中包含的说明性文字</p></li><li><p>表单控件：包含了具体的表单功能项</p></li><li><p>表单域：容纳所有表单控件和提示信息</p><p>常用的表单元素，包括：</p></li><li><p>form: 定义供用户输入的表单。</p></li><li><p>fieldset: 定义域。即输入区加有文字的边框。</p></li><li><p>legend：定义域的标题，即边框上的文字。</p></li><li><p>label：定义一个控制的标签。如输入框前的文字，用以关联用户的选择。</p></li><li><p>input: 定义输入域，常用。可设置type属性，从而具有不同功能。</p></li><li><p>textarea: 定义文本域(一个多行的输入控件)，默认可通过鼠标拖动调整大小。</p></li><li><p>button: 定义一个按钮。</p></li><li><p>select: 定义一个选择列表，即下拉列表。</p></li><li><p>option: 定义下拉列表中的选项。</p><p>接下来是对这些表单元素的具体分析。</p><p><code>&lt;form name=&quot;&quot; action=&quot;&quot; method=&quot;get&quot;&gt;……&lt;/form&gt;</code><br>name : 表单名称；action : 用来指定表单处理程序的位置（url）；method : 定义表单结果从浏览器传送到服务器的方式，默认为”get”（也可以是post）<br><code>&lt;input type=&quot;&quot; name=&quot;&quot; value=&quot;&quot; size=&quot;&quot;&gt;</code><br>name:控件名称；value:input控件默认文本值；size:input控件在页面中的显示宽度（必须是正整数）<br>input常用type属性如下：</p></li><li><p>text：单行文本输入框，可以通过正整数的size控制框长度。</p></li><li><p>password：密码输入框。</p></li><li><p>radio：单选按钮，同一组的单选按钮必须要有相同的name。</p></li><li><p>checkbox：复选框，同一组的单选按钮必须要有相同的name。</p></li><li><p>button：普通按钮。</p></li><li><p>submit：提交按钮，每出现一次，一个 Submit 对象就会被创建。</p></li><li><p>reset：重置按钮，会重置当前表单中全部的内容。</p></li><li><p>image：图像形式的提交按钮，写法是“”。</p></li><li><p>hidden：隐藏域，隐藏字段对于用户是不可见的。</p></li><li><p>file：文件域，用于文件上传。</p><p><code>&lt;selectt size=&quot;&quot; multiple=&quot;multiple&quot;&gt;</code><br><code>&lt;option hidden&gt;选项1&lt;/option&gt;</code><br>size：下拉菜单的可见选项数；multiple：多选。<br>在最新的html5中，有一些表单的新增属性，多用于js，如<br>datalist : 定义填写一个input时，提示几个option用于提示。可通过input的list特性与此元素作关联。<br>output : 表示计算的结果。可通过for特性与其它能够影响运算的元素（如input）作关联。<br>还有一些新增的type属性：</p></li><li><p>search：input会呈现为搜索框（与text类型的唯一区别在于当鼠标覆盖时尾部出现叉号可快速清除输入的内容）。</p></li><li><p>url：编辑url的控件，提交时换行符与首位的空格都将自动去除。</p></li><li><p>email：可输入一个邮件地址。</p></li><li><p>color : 选择颜色的控件。</p></li><li><p>date : 选择年月日的控件。<br>此外，还有time、datetime、datetime-local、month、week、number、range类型</p></li></ol><h2 id="10-ol-ul-li-dl-dd-dt等这些标签都适合用在什么地方，举个例子"><a href="#10-ol-ul-li-dl-dd-dt等这些标签都适合用在什么地方，举个例子" class="headerlink" title="10.ol, ul, li, dl, dd, dt等这些标签都适合用在什么地方，举个例子"></a>10.<strong>ol, ul, li, dl, dd, dt等这些标签都适合用在什么地方，举个例子</strong></h2><pre><code>ol为有序列表,即为一个需要排序的列表内容进行排列; （问路）ul为无序列表,即为一个需要列表但不需要排顺序的内容排列; （早点清单）li为列表的内容; dl为定义列表; dt为定义列表内的标题或项目名称; dd为定义定义列表中项目的描述(独白旁白)</code></pre><hr><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-CSS选择器类型、优先级"><a href="#1-CSS选择器类型、优先级" class="headerlink" title="1.CSS选择器类型、优先级"></a>1.<strong>CSS选择器类型、优先级</strong></h2><p> 　 1.标签选择器(如：body,div,p,ul,li)</p><p>　　2.类选择器(如：class=”head”,class=”head_logo”)</p><p>　　3.ID选择器(如：id=”name”,id=”name_txt”)</p><p>　　4.全局选择器(如：*号)</p><p>　　5.组合选择器(如：.head .head_logo,注意两选择器用空格键分开)</p><p>　　6.后代选择器 (如：#head .nav ul li 从父集到子孙集的选择器)</p><p>　　7.群组选择器 div,span,img {color:Red} 即具有相同样式的标签分组显示</p><p>　　8.继承选择器(如：div p,注意两选择器用空格键分开)</p><p>　　9.伪类选择器(如：就是链接样式,a元素的伪类，4种不同的状态：link、visited、active、hover。)</p><p>　　10.字符串匹配的属性选择符(^ $ *三种，分别对应开始、结尾、包含)</p><p>　　11.子选择器 (如：div&gt;p ,带大于号&gt;)</p><p>　　12.CSS 相邻兄弟选择器器 (如：h1+p,带加号+)  </p><p> <strong>总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</strong></p><h2 id="2-CSS继承，层叠，样式优先级机制"><a href="#2-CSS继承，层叠，样式优先级机制" class="headerlink" title="2.CSS继承，层叠，样式优先级机制"></a>2.<strong>CSS继承，层叠，样式优先级机制</strong></h2><p>当多个相互冲突的CSS声明应用于同一个元素时，CSS层叠算法会根据一定的机制，从最高权重到最低权重的顺序列出</p><p>在CSS中，每个CSS属性定义的概述都指出了这个属性是默认继承的还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算值。当元素的一个</p><p>继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值；当元素的一个非继承属性没有指定值时，则取属性的初始值。</p><h2 id="3-文本，边框，背景，行高等相关属性"><a href="#3-文本，边框，背景，行高等相关属性" class="headerlink" title="3.文本，边框，背景，行高等相关属性"></a>3.<strong>文本，边框，背景，行高等相关属性</strong></h2><p>border:1px solid red;</p><p>background-color: cornflowerblue;</p><p>background-image: url(‘1.jpg’);</p><p>background-repeat: no-repeat;(repeat:平铺满)</p><p>background-position: right(左右距离) top（上下距离）（20px 20px）;(横向：left center right)(纵向：top center bottom)</p><p>简写：&lt; body style=”background: 20px 20px no-repeat #ff4 url(‘1.jpg’)”&gt;</p><p>&lt; div style=”width: 300px;height: 300px;background: 20px 20px no-repeat #ff4 url(‘1.jpg’)”&gt;</p><h2 id="4-块状元素，内联元素和内联块状元素的概念"><a href="#4-块状元素，内联元素和内联块状元素的概念" class="headerlink" title="4.块状元素，内联元素和内联块状元素的概念"></a>4.<strong>块状元素，内联元素和内联块状元素的概念</strong></h2><p>块级元素特点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;、&lt;<span class="selector-tag">p</span>&gt;、&lt;<span class="selector-tag">h1</span>&gt;<span class="selector-tag">-</span>&lt;<span class="selector-tag">h6</span>&gt;、&lt;<span class="selector-tag">ol</span>&gt;、&lt;<span class="selector-tag">ul</span>&gt;、&lt;<span class="selector-tag">dl</span>&gt;、&lt;<span class="selector-tag">table</span>&gt;、&lt;<span class="selector-tag">address</span>&gt;、&lt;<span class="selector-tag">blockquote</span>&gt; 、&lt;<span class="selector-tag">form</span>&gt;</span><br></pre></td></tr></table></figure><p>1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。</p><p>2、元素的高度、宽度、行高以及顶和底边距都可设置。</p><p>3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致）。默认高度等于子元素高度。父子均是块级元素时，子块的高度可能冲破父级的限制</p><p>内联元素特点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span>&gt;、&lt;<span class="selector-tag">span</span>&gt;、&lt;<span class="selector-tag">br</span>&gt;、&lt;<span class="selector-tag">i</span>&gt;、&lt;<span class="selector-tag">em</span>&gt;、&lt;<span class="selector-tag">strong</span>&gt;、&lt;<span class="selector-tag">label</span>&gt;、&lt;<span class="selector-tag">q</span>&gt;、&lt;<span class="selector-tag">var</span>&gt;、&lt;<span class="selector-tag">cite</span>&gt;、&lt;<span class="selector-tag">code</span>&gt;</span><br></pre></td></tr></table></figure><p>1.和其他内联元素都在一行上；</p><p>2.可以通过margin、padding来改变左右的距离，但不可以改变上下的距离，导致width、height、line-height失效或。可以使用border。</p><p>3.内联元素之间有空白区域，空白区域的形成是因为<span>之间有回车，在html中，空格、制表符、回车都属于空白符，多个空白符都会视为一个空格，空格的大小由父级<div>的font-size决定。注意：只有内联(内联块)与内联(内联块)之间的空白符才会形成一个空格，文本元素(除空白符)也是属于内联元素。常用解决方法，给<div>设置font-size: 0;，在<span>上把font-size设置回去</span></div></div></span></p><p>inline-block 元素特点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span>&gt;、&lt;<span class="selector-tag">input</span>&gt;</span><br></pre></td></tr></table></figure><p>1.和其他元素都在一行上；</p><p>2.元素的高度、宽度、行高以及顶和底边距都可设置。</p><p>3.它也会有元素间出现空白区域的问题</p><h2 id="5-盒模型的所有概念，学习如何计算各种盒模型"><a href="#5-盒模型的所有概念，学习如何计算各种盒模型" class="headerlink" title="5.盒模型的所有概念，学习如何计算各种盒模型"></a>5.<strong>盒模型的所有概念，学习如何计算各种盒模型</strong></h2><p>IE盒子：宽高包括padding和border</p><p>W3C盒子：宽高为content的宽高</p><p>如果想要切换盒模型也很简单，这里需要借助css3的<code>box-sizing</code>属性</p><blockquote><ul><li><code>box-sizing: content-box</code> 是W3C盒子模型</li><li><code>box-sizing: border-box</code>   是IE盒子模型</li></ul></blockquote><h2 id="6-position的相关知识，position有几种，absolute和relative的区别"><a href="#6-position的相关知识，position有几种，absolute和relative的区别" class="headerlink" title="6.position的相关知识，position有几种，absolute和relative的区别"></a>6.<strong>position的相关知识，position有几种，absolute和relative的区别</strong></h2><p><code>position: static | relative | absolute | fixed | sticky</code></p><ul><li><p><code>static</code></p><p>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code>属性无效</p></li><li><p><code>relative</code></p><p>​    该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative  对 table-*-group, table-row, table-column, table-cell, table-caption  元素无效。</p><p>​    相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移，<strong>未脱离文档流。（其他元素的位置不会受该元素的影响发生位置改变来弥补该元素偏移后剩下的空隙）</strong></p></li><li><p><code>absolute</code></p><p>不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并，<strong>脱离了文档流</strong>。</p></li><li><p><code>fixed</code></p><p>固定定位与绝对定位相似，但元素的包含块为 viewport 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。</p><p>不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。<code>fixed</code> 属性会创建新的层叠上下文。当元素祖先的 <code>transform</code>  属性非 <code>none</code> 时，容器由视口改为该祖先。</p></li><li><p><code>sticky</code>  </p><p>盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 <code>table 时</code>），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<code>position: sticky</code>对 <code>table</code> 元素的效果与 <code>position: relative</code>相同。</p><p>粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。</p></li></ul><h2 id="7-float的相关知识"><a href="#7-float的相关知识" class="headerlink" title="7.float的相关知识"></a>7.<strong>float的相关知识</strong></h2><p>float CSS属性指定一个元素应沿其容器的左侧或右侧放置，<strong>允许文本和内联元素环绕它</strong>。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性（与<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position#Absolute_positioning" target="_blank" rel="noopener">绝对定位</a>相反）。</p><blockquote><p>当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到<strong>另外一个浮动的元素</strong>。</p></blockquote><hr><p>对于浮动，需要了解的是：</p><p> *浮动会将元素从文档流中删除，他的空间会被其它元素补上。</p><p> *浮动的参数物是父元素，是在父元素这个容器中飘。</p><p> *为了清除浮动造成的对浮动元素之后元素的影响，我们在浮动元素之后加一个div，并将这个div的clear设置为both。</p><p> *如果两个元素都设置了浮动，则两个元素并不会重叠，第一个元素占据一定空间，第二个元素紧跟其后。如果不想让第二个元素紧跟其后，可以对第二个浮动的元素使用clear。</p><hr><p><strong>浮动元素</strong>是 <code>float</code> 的计算值非 <code>none</code> 的元素。</p><h2 id="8-基本的布局方式"><a href="#8-基本的布局方式" class="headerlink" title="8.基本的布局方式"></a>8.<strong>基本的布局方式</strong></h2><p>   固定布局、流式（百分比）布局、弹性布局、浮动布局、定位布局</p><h2 id="9-Grid-Flexbox等布局方式"><a href="#9-Grid-Flexbox等布局方式" class="headerlink" title="9.Grid,Flexbox等布局方式"></a>9.<strong>Grid,Flexbox等布局方式</strong></h2><p>   弹性布局是指通过调整其内元素的宽高，从而在任何显示设备上实现对可用显示空间最佳填充的能力。弹性容器扩展其内元素来填充可用空间，或将其收缩来避免溢出。</p><p>   这二者都是 CSS  工作组为在不同用户代理、不同书写模式和其他灵活性要求下的网页应用程序有更好的互操作性而做出的更广泛的努力的一部分。都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。flex主要适用于应用程序的组件及小规模的布局，而（新兴的）栅格布局则针对大规模的布局。</p><p>   Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。</p><h2 id="10-神马圣杯布局、双飞翼布局都是些什么东西"><a href="#10-神马圣杯布局、双飞翼布局都是些什么东西" class="headerlink" title="10.神马圣杯布局、双飞翼布局都是些什么东西"></a>10.<strong>神马圣杯布局、双飞翼布局都是些什么东西</strong></h2><h2 id="11-强大的负外边距都能干嘛"><a href="#11-强大的负外边距都能干嘛" class="headerlink" title="11.强大的负外边距都能干嘛"></a>11.<strong>强大的负外边距都能干嘛</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">影响元素在文档流中的位置、增加元素宽度、对浮动元素的影响、对居中的影响</span><br></pre></td></tr></table></figure><h2 id="12-display的几个属性，及其区别"><a href="#12-display的几个属性，及其区别" class="headerlink" title="12.display的几个属性，及其区别"></a>12.<strong>display的几个属性，及其区别</strong></h2><ul><li>inline:<ol><li>使元素变成行内元素，拥有行内元素的特性，即可以与其他行内元素共享一行，不会独占一行. </li><li>不能更改元素的height，width的值，大小由内容撑开. </li><li>可以使用padding，margin的left和right产生边距效果，但是top和bottom就不行.</li></ol></li><li>block:<ol><li>使元素变成块级元素，独占一行，在不设置自己的宽度的情况下，块级元素会默认填满父级元素的宽度. </li><li>能够改变元素的height，width的值. </li><li>可以设置padding，margin的各个属性值，top，left，bottom，right都能够产生边距效果.</li></ol></li><li>inline-block:<ol><li>结合了inline与block的一些特点，结合了上述inline的第1个特点和block的第2,3个特点.</li></ol></li></ul><h2 id="13-display-none与visibility-hidden的区别"><a href="#13-display-none与visibility-hidden的区别" class="headerlink" title="13.display:none与visibility:hidden的区别"></a>13.<strong>display:none与visibility:hidden的区别</strong></h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:none</span>是彻底消失，不在文档流中占位，浏览器也不会解析该元素；<span class="selector-tag">visibility</span><span class="selector-pseudo">:hidden</span>是视觉上消失了，可以理解为透明度为0的效果，在文档流中占位，浏览器会解析该元素；</span><br></pre></td></tr></table></figure><h2 id="14-浏览器清除浮动的方式及其原理"><a href="#14-浏览器清除浮动的方式及其原理" class="headerlink" title="14.浏览器清除浮动的方式及其原理"></a>14.<strong>浏览器清除浮动的方式及其原理</strong></h2><p>1》添加额外的标签：在浮动元素末尾添加一个空的标签例如 &lt; div style=”clear:both”&gt;，其他标签br等亦可</p><p>2》使用 br标签和其自身的 html属性：&lt; br clear=”all” /&gt;</p><p>3》父元素设置 overflow：hidden</p><p>4》父元素设置 overflow：auto 属性</p><p>5》父元素也设置浮动</p><p>6》父元素设置display:table</p><p>7》使用 :after 伪元素</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`.clearfix:after &#123;content:"."; display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1; &#125;`</span><br></pre></td></tr></table></figure><h2 id="15-BFC"><a href="#15-BFC" class="headerlink" title="15.BFC"></a>15.<strong>BFC</strong></h2><p>(1).BFC的特性:</p><p>​    ①块级格式化上下文会阻止外边距叠加</p><p>​    ②块级格式化上下文不会重叠浮动元素</p><p>​    ③块级格式化上下文通常可以包含浮动</p><p>创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC任然属于文档中的普通流。</p><p>2.触发BFC的条件</p><p>　    1、float 除了none以外的值</p><p>　　2、overflow 除了visible 以外的值（hidden，auto，scroll ）</p><p>　　3、display (table-cell，table-caption，inline-block)</p><p>　　4、position（absolute，fixed）</p><p>　　5、fieldset元素</p><h2 id="16-src与href的区别"><a href="#16-src与href的区别" class="headerlink" title="16.src与href的区别"></a>16.<strong>src与href的区别</strong></h2><pre><code>href表示超文本引用。用来建立当前文档和引用资源之间的链接。常用的有：link、a。src是source的缩写，是引入。src指向的内容会嵌入到文档中当前标签所在的位置。常用的有：img、script、iframe 简而言之，src用于替换当前元素；href用于在当前文档和引用资源之间建立联系。</code></pre><h2 id="17-px、em、rem的区别"><a href="#17-px、em、rem的区别" class="headerlink" title="17.px、em、rem的区别"></a>17.<strong>px、em、rem的区别</strong></h2><pre><code>都是用于设置字体的大小以及盒子的宽高，但是px不会因为浏览器尺寸的改变而改变，而em和rem会因为浏览器尺寸的变化而变化像素是相对于显示器屏幕分辨率而言的em是一个相对长度的单位，是相对于当前对象内文本的字体尺寸。如过我们未设置当前文本的字体尺寸，那么em就会相对于浏览器的默认字体尺寸， em大小不是固定的，会继承父级元素的字体大小。rem相对的只是HTML根元素，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。</code></pre><h2 id="18-为什么要使用css-sprites"><a href="#18-为什么要使用css-sprites" class="headerlink" title="18.为什么要使用css sprites"></a>18.<strong>为什么要使用css sprites</strong></h2><pre><code>CSS Sprites其实就是把网页中一些[背景图片]整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出[背景图片]的位置。当页面加载时，不是加载每个单独图片，而是一次加载整个组合图片。这是一个了不起的改进，它大大减少了[HTTP请求]的次数，减轻服务器压力，同时缩短了悬停加载图片所需要的时间延迟，使效果更流畅，不会停顿。缺点：就是在拼图时，比较麻烦，还有后期维护也比较麻烦，比如做好的图，然后一个图标改了大小，但是图标之间留的位置不够，那你就要重写很多css。因为每次的图片改动都得往这个图片删除或添加内容，显得稍微繁琐</code></pre><h2 id="19-什么是CSS及CSS怎么运作"><a href="#19-什么是CSS及CSS怎么运作" class="headerlink" title="19.什么是CSS及CSS怎么运作"></a>19.<strong>什么是CSS及CSS怎么运作</strong></h2><pre><code>CSS (Cascading Style Sheets) 是用来样式化和排版你的网页的 —— 例如更改网页内容的字体、颜色、大小和间距，将内容分割成多列或者加入动画以及别的装饰型效果。是一种用于向用户指定文档如何呈现的语言。Web浏览器将CSS规则应用于文档以影响它们的显示方式。</code></pre><h2 id="20-居中"><a href="#20-居中" class="headerlink" title="20.居中"></a>20.居中</h2><p> <a href="..\CSS\居中.xmind">居中.xmind</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-了解什么是Web&quot;&gt;&lt;a href=&quot;#1-了解什么是Web&quot; class=&quot;headerlink&quot; title=&quot;1.了解什么是Web&quot;&gt;&lt;/a&gt;1.了解什么是Web&lt;/h2&gt;&lt;p&gt;   web即全球广域网，也称万维网。它是一种基于超文本和HTTP的、全球性
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面试2</title>
    <link href="http://yoursite.com/2019/07/15/JavaScript%E9%9D%A2%E8%AF%952/"/>
    <id>http://yoursite.com/2019/07/15/JavaScript面试2/</id>
    <published>2019-07-15T03:09:04.943Z</published>
    <updated>2019-07-15T03:19:02.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-你觉得js是一门怎样的语言，它与你学过的其他语言有什么不同"><a href="#1-你觉得js是一门怎样的语言，它与你学过的其他语言有什么不同" class="headerlink" title="1.你觉得js是一门怎样的语言，它与你学过的其他语言有什么不同"></a>1.你觉得js是一门怎样的语言，它与你学过的其他语言有什么不同</h2><p>javaScript</p><p>​      一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。JavaScript兼容于ECMA标准，因此也称为ECMAScript。</p><p>Javascript的特点：</p><p>一、简单性：</p><p>JavaScript是一种基于Java基本语句和控制流之上的简单而紧凑的设计，从而对于学习Java是一种非常好的过渡。它的变量类型是采用弱类型，并未使用严格的数据类型。</p><p>二、动态性：</p><p> avaScript是动态的，它可以直接对用户或客户输入做出响应，无须经过Web服务程序。它对用户的反映响应，是采用以事件驱动的方式进行的。所谓事件驱动，就是指在主页(Home Page)中执行了某种操作所产生的动作，就称为“事件”(Event)。比如按下鼠标、移动窗口、选择菜单等都可以视为事件。当事件发生后，可能会引起相应的事件响应。</p><p>三、跨平台性：</p><p>JavaScript是依赖于浏览器本身，与操作环境无关，只要能运行浏览器的计算机，并支持JavaScript的浏览器就可正确执行。从而实现了“编写一次,走遍天下”的梦想。</p><p>四、安全性：</p><p>JavaScript是一种安全性语言，它不允许访问本地的硬盘，并不能将数据存入到服务器上，不允许对网络文档进行修改和删除，只能通过浏览器实现信息浏览或动态交互。从而有效地防止数据的丢失。</p><p><strong>2</strong>。从静态类型还是动态类型来看 </p><p>静态类型，编译的时候就能够知道每个变量的类型，编程的时候也需要给定类型，如Java中的整型int，浮点型float等。C、C++、Java都属于静态类型语言。 </p><p>  动态类型，运行的时候才知道每个变量的类型，编程的时候无需显示指定类型，如JavaScript中的var、PHP中的$。JavaScript、Ruby、Python都属于动态类型语言。 </p><p>  静态类型还是动态类型对语言的性能有很大影响。 </p><p>  对于静态类型，在编译后会大量利用已知类型的优势，如int类型，占用4个字节，编译后的代码就可以用内存地址加偏移量的方法存取变量，而地址加偏移量的算法汇编很容易实现。 </p><p>  对于动态类型，会当做字符串通通存下来，之后存取就用字符串匹配。 </p><p>  从编译型还是解释型来看 </p><p>  编译型语言，像C、C++，需要编译器编译成本地可执行程序后才能运行，由开发人员在编写完成后手动实施。用户只使用这些编译好的本地代码，这些本地代码由系统加载器执行，由操作系统的CPU直接执行，无需其他额外的虚拟机等。 </p><p>  源代码=》抽象语法树=》中间表示=》本地代码 </p><p>  解释性语言，像JavaScript、Python，开发语言写好后直接将代码交给用户，用户使用脚本解释器将脚本文件解释执行。对于脚本语言，没有开发人员的编译过程，当然，也不绝对。 </p><p>  源代码=》抽象语法树=》解释器解释执行。 </p><p>  对于JavaScript，随着Java虚拟机JIT技术的引入，工作方式也发生了改变。可以将抽象语法树转成中间表示（字节码），再转成本地代码，如JavaScriptCore，这样可以大大提高执行效率。也可以从抽象语法树直接转成本地代码，如V8 </p><p>​    Java语言，分为两个阶段。首先像C++语言一样，经过编译器编译。和C++的不同，C++编译生成本地代码，Java编译后，生成字节码，字节码与平台无关。第二阶段，由Java的运行环境也就是Java虚拟机运行字节码，使用解释器执行这些代码。一般情况下，Java虚拟机都引入了JIT技术，将字节码转换成本地代码来提高执行效率。  </p><p>  注意，在上述情况中，编译器的编译过程没有时间要求，所以编译器可以做大量的代码优化措施。 </p><p>  对于JavaScript与Java它们还有的不同： </p><p>  对于Java，Java语言将源代码编译成字节码，这个同执行阶段是分开的。也就是从源代码到抽象语法树到字节码这段时间的长短是无所谓的。 </p><p>  对于JavaScript，这些都是在网页和JavaScript文件下载后同执行阶段一起在网页的加载和渲染过程中实施的，所以对于它们的处理时间有严格要求</p><h2 id="2-js基本数据类型"><a href="#2-js基本数据类型" class="headerlink" title="2.js基本数据类型"></a>2.js基本数据类型</h2><p>字符串值，数值，布尔值，数组，undefined，null，对象。<br>基本类型数据<br>1.基本数据类型值是指简单的数据段，五种基本类型都是按值访问的（可以操作保存在变量中的实际值）；<br>2.基本类型的值在内存中占据固定大小的空间，被保存在栈内存中。（从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本）；<br>3.不能给基本类型的值添加属性。<br>引用类型数据：object（还有array、function）<br>1.引用类型值是指那些可以由多个值构成的对象。js不允许直接访问内存中的位置，也就是不能直接访问操作对象的内存空间，在操作对象时，实际上是在操作对象的引用而不是实际的对象；<br>2.引用类型的值是对象，保存在堆内存中，包含引用类型值的变量实际上包含的并不是对象本身，而是指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终指向同一个对象。<br>3.对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性和方法。<br>4.在ECMAScript中用var关键字来定义变量，因为js是弱类型的，所以无法确定变量一定会存储什么值，也就不知道变量到底会是什么类型，而且变量的类型可以随时改变。这就是ECMAScript是松散类型的来由，所谓松散类型就是可以用来保存任何类型的数据。<br>在es6中新增了let命令来声明变量，const命令声明一个只读的常量<br>let的用法类似于var，但是所声明的变量，只有在let代码块内才有效；const一旦声明，常量的值就不能改变。</p><p><a href="https://www.cnblogs.com/zhengyeye/p/6485124.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengyeye/p/6485124.html</a></p><h2 id="3-js如何判断变量数据类型"><a href="#3-js如何判断变量数据类型" class="headerlink" title="3.js如何判断变量数据类型"></a>3.js如何判断变量数据类型</h2><p>typeof（typeof的局限性在于 数组、对象、null都为object；typeof运算符把函数返回function）、instanceof（[1,2] instanceof Array 只对数组有用)、Array.isArray()方法确定某个值是否为数组、Object.prototype.toString.call()（最理想，能够十分准确检测出全部类型）、constructor（引用了初始化该对象的构造函数来判断 （(“123”).constructor === String）</p><h2 id="4-类数组和数组"><a href="#4-类数组和数组" class="headerlink" title="4.类数组和数组"></a>4.类数组和数组</h2><p><strong>类数组定义</strong><br>1）拥有length属性，其它属性（索引）为非负整数（对象中的索引会被当做字符串来处理）；<br>2）不具有数组所具有的方法；<br>javascript中常见的类数组有 <code>arguments</code>对象和 DOM方法的返回结果。比如 <code>document.getElementsByTagName()</code>。</p><p>判断是否是类数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isLikeArray</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> o === <span class="string">'object'</span>&amp;&amp; <span class="built_in">isFinite</span>(o.length) &amp;&amp;  o.length &gt;= <span class="number">0</span> &amp;&amp; o.length &lt; <span class="number">4294967296</span>)&#123;<span class="comment">// 4294967296: 2^32</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-将类数组转换为数组"><a href="#5-将类数组转换为数组" class="headerlink" title="5.将类数组转换为数组"></a>5.将类数组转换为数组</h2><ol><li>创建一个新的数组，然后将将类数组中的元素添加到新数组里面</li><li>Array.prototype.slice.call()</li><li>Array.form(arguments)</li></ol><h2 id="6-如何遍历数组"><a href="#6-如何遍历数组" class="headerlink" title="6.如何遍历数组"></a>6.如何遍历数组</h2><p>1.普通for循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = arr.length; i &lt; len; i++)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; arr[i] != <span class="literal">null</span>; i++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.for in 循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.forEach循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//数组自带的foreach循环，使用频率较高，实际上性能比普通for循环弱</span></span><br></pre></td></tr></table></figure><p>4.map遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>))</span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>5.for of 遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> arr)&#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这种方式是es6里面用到的，性能好于for in，但仍比不上普通for循环</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/function__/article/details/79555301" target="_blank" rel="noopener">https://blog.csdn.net/function__/article/details/79555301</a></p><h2 id="7-ARRAY常用方法"><a href="#7-ARRAY常用方法" class="headerlink" title="7.ARRAY常用方法"></a>7.ARRAY常用方法</h2><p>push(),pop(),shift(),unshift(),splice(),sort(),reverse(),map(),forEach(),isArray(),toString()等</p><h2 id="8-STRING常用方法"><a href="#8-STRING常用方法" class="headerlink" title="8.STRING常用方法"></a>8.STRING常用方法</h2><p><strong>toUpperCase()</strong>：把一个字符串全部变为大写</p><p><strong>toLowerCase()</strong>：把一个字符串全部变为小写</p><p><strong>indexOf()</strong>：会搜索制定字符串出现的位置，有返回索引，没有返回-1</p><p><strong>substring()</strong>：返回制定索引区间的子串（传一个参数的话表示从该参数索引位置开始到结束；传两个参数的话表示从开始索引到结束索引）</p><p><strong>slice()</strong>：使用与substring()基本相同，可以传负数，负数则从字符串尾部算起；substring()不能传负数</p><p><strong>substr()</strong>：用法与上面两个相似，但是第二个参数表示截取的字符串最大长度（三种字符串截取方法，未填第二参数时，自动截取起始位置到字符串末尾）</p><p><strong>toString()</strong>：可以将其他数据类型转换为字符串</p><p><strong>split()</strong>：对字符串进行分割，返回一个数组（如果只传一个参数则表示以哪个字符进行分割；传两个参数的话第二个参数表示返回的字符串数组的最大长度）</p><p><strong>replace()</strong>：字符串替换，默认只进行第一次匹配操作的替换，想要全局替换，需要加上正则全局标识g。例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　　　var mystr=&quot;wozaijinxingzifuchuantihuancaozuo,zifuchuantihuano&quot;;</span><br><span class="line">　　　　var replaceStr=mystr.replace(&quot;zifuchuan&quot;,&quot; &quot;);    //wozaijinxing tihuancaozuo,zifuchuantihuano</span><br><span class="line">　　　　var replaceStr=mystr.replace(/zifuchuan/,&quot; &quot;);    //wozaijinxing tihuancaozuo,zifuchuantihuano</span><br><span class="line">　　　　var replaceStr=mystr.replace(/zifuchuan/g,&quot; &quot;);    //wozaijinxing tihuancaozuo, tihuano</span><br></pre></td></tr></table></figure><p><strong>length</strong>：获取字符串长度</p><p><strong>indexOf()</strong>：查询子字符串，对大小写敏感，返回字符串中子串第一处出现的索引（从左到右）。如果没有匹配项，返回-1。</p><p><strong>lastIndexOf()</strong>：查询子字符串，对大小写敏感，返回字符串中子串第一处出现的索引（从右到左）。如果没有匹配项，返回-1。</p><p><strong>charAt()</strong>：返回制定位置的字符</p><p><strong>match()</strong>：字符串匹配。若有相匹配的字符，则返回所要匹配的字符串；没有相匹配的，返回null（也可定义一个变量为正则表达式进行匹配）</p><p><strong>exec()</strong>：字符串匹配。与match()效果相同，用法相反</p><p><strong>search()</strong>：进行正则匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回-1</p><p><strong>trim()</strong>：删除字符串前后的空格</p><h2 id="9-DOM-事件级别"><a href="#9-DOM-事件级别" class="headerlink" title="9.DOM 事件级别"></a>9.DOM 事件级别</h2><p>dom0级事件就是在js中写到 element.onclick=function(){},是一种比较传统的方式：把一个函数(或者匿名函数)赋值给一个事件的处理程序属性。</p><blockquote><p>优势（兼容所有浏览器）</p><p>缺点：不能给元素添加多个事件处理程序，只能添加一个，如果添加多个事件处理程序，后面的会覆盖前面的</p></blockquote><p> 2 DOM1级主要是映射文档，<strong>没有事件</strong>。  </p><p> 3 DOM2级事件 element.addEventListerner(‘click’,function(){},false)  false指的是冒泡，早期浏览器都支持冒泡，为了兼容基本上最后一个参数都是false.</p><blockquote><p>删除事件：element.removeEventListener(‘click’,function(){},false)，这样的删除方式只能删除DOM2级添加的事件。删除的时候传递的参数必须跟添加时传递的参数一样才能正确删除事件。</p><p>优点，可以给元素添加多个事件处理程序，这些事件处理程序按照他们的顺序执行。</p></blockquote><p>4 Dom3级事件跟dom2级事件写法一样的，只是增加了许多事件类型，包括点击事件和键盘事件。</p><h2 id="10-DOM-事件类型"><a href="#10-DOM-事件类型" class="headerlink" title="10.DOM 事件类型"></a>10.DOM 事件类型</h2><p>Web浏览器中可能发生的事件有很多类型。不同的事件类型具有不同的信息，而“DOM3级事件”规定了以下几类事件：</p><ul><li>UI（用户界面）事件，当用户与界面上的元素交互时触发</li><li>焦点事件，当元素获得或失去焦点时触发</li><li>鼠标事件，当用户通过鼠标在页面上执行操作时触发</li><li>滚轮事件，当使用鼠标滚轮时触发</li><li>文本事件，当在文档中输入文本时触发</li><li>键盘事件，当用户通过键盘在页面上执行操作时触发</li><li>合成事件，当为IME输入字符时触发</li><li>变动事件，当底层DOM结构发生变化时触发</li></ul><h2 id="11-DOM-事件流"><a href="#11-DOM-事件流" class="headerlink" title="11.DOM 事件流"></a>11.DOM 事件流</h2><p>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。<br>事件捕获阶段<br>处于目标阶段<br>事件冒泡阶段</p><p>首先发生的是事件捕获，为截获事件提供了机会；然后是实际的目标接收到事件；最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。</p><p>addEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。<br>IE只支持事件冒泡。 </p><h2 id="12-描述一下冒泡-事件捕获的具体流程"><a href="#12-描述一下冒泡-事件捕获的具体流程" class="headerlink" title="12.描述一下冒泡/事件捕获的具体流程"></a><img src="https://images2015.cnblogs.com/blog/315302/201606/315302-20160621155328756-279009443.png" alt="img">12.描述一下冒泡/事件捕获的具体流程</h2><p>1.事件冒泡：即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p><p>2.事件捕获：思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。</p><h2 id="13-html、dom0、dom2是如何注册事件"><a href="#13-html、dom0、dom2是如何注册事件" class="headerlink" title="13.html、dom0、dom2是如何注册事件"></a>13.html、dom0、dom2是如何注册事件</h2><p>1.在html代码元素中添加事件为Html事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"按钮"</span> id=<span class="string">"btn1"</span> onclick=<span class="string">"showMess()"</span>/&gt;</span><br></pre></td></tr></table></figure><p>2.使用元素的onclick方法为DOM0级事件处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn2.onclick=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>3.使用事件添加方法为元素添加事件（</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrome:addEventListener,removeEventListener</span><br><span class="line">IE:attachEvent,detachEvent</span><br></pre></td></tr></table></figure><p>）为DOM2级事件处理。</p><h2 id="14-事件流"><a href="#14-事件流" class="headerlink" title="14.事件流"></a>14.事件流</h2><p>JavaScript高级程序设计–p345</p><h2 id="15-事件委托-代理"><a href="#15-事件委托-代理" class="headerlink" title="15.事件委托(代理)"></a>15.事件委托(代理)</h2><p><a href="https://www.jianshu.com/p/a77d8928c5c9" target="_blank" rel="noopener">https://www.jianshu.com/p/a77d8928c5c9</a></p><h2 id="16-自定义事件"><a href="#16-自定义事件" class="headerlink" title="16.自定义事件"></a>16.自定义事件</h2><p>　1.<strong>Event()</strong> 构造函数, 创建一个新的事件对象 <code>Event</code><br>　2.<strong>CustomEvent()</strong>  创建一个自定义事件<br>　3.<strong>document.createEvent()</strong> <code>创建一个新的事件（Event），随之必须调用自身的 init 方法进行初始化</code><br>  4.<a href="https://www.cnblogs.com/shapeY/p/7923353.html" target="_blank" rel="noopener">https://www.cnblogs.com/shapeY/p/7923353.html</a></p><h2 id="17-怎么防止冒泡"><a href="#17-怎么防止冒泡" class="headerlink" title="17.怎么防止冒泡"></a>17.怎么防止冒泡</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopBubble</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line"><span class="comment">//如果提供了事件对象，则这是一个非IE浏览器 </span></span><br><span class="line"><span class="keyword">if</span> ( e &amp;&amp; e.stopPropagation ) </span><br><span class="line">    <span class="comment">//因此它支持W3C的stopPropagation()方法 </span></span><br><span class="line">    e.stopPropagation(); </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="comment">//否则，我们需要使用IE的方式来取消事件冒泡 </span></span><br><span class="line">    <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻止默认行为</p><p><a href="http://caibaojian.com/javascript-stoppropagation-preventdefault.html" target="_blank" rel="noopener">http://caibaojian.com/javascript-stoppropagation-preventdefault.html</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻止浏览器的默认行为 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopDefault</span>(<span class="params"> e </span>) </span>&#123; </span><br><span class="line">    <span class="comment">//阻止默认浏览器动作(W3C) </span></span><br><span class="line">    <span class="keyword">if</span> ( e &amp;&amp; e.preventDefault ) </span><br><span class="line">        e.preventDefault(); </span><br><span class="line">    <span class="comment">//IE中阻止函数器默认动作的方式 </span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-谈谈innerHTML、-nodeValue与-textContent之间的区别"><a href="#18-谈谈innerHTML、-nodeValue与-textContent之间的区别" class="headerlink" title="18.谈谈innerHTML、 nodeValue与 textContent之间的区别"></a>18.谈谈innerHTML、 nodeValue与 textContent之间的区别</h2><p>nodeValue：是节点的值</p><p>innerHTML:浏览器会将内容解析为HTML代码</p><p>textContent：使用纯文本而不是解析为HTML</p><h2 id="19-简单说一下DOM操作中如何查找元素"><a href="#19-简单说一下DOM操作中如何查找元素" class="headerlink" title="19.简单说一下DOM操作中如何查找元素"></a>19.简单说一下DOM操作中如何查找元素</h2><p>document.getElementById(id) 通过元素 id 来查找元素 </p><p>document.getElementsByTagName(name) 通过标签名来查 </p><p> document.getElementsByClassName(name) 通过类名来查 </p><p>document.getElementsByName();//name属性值，一般不用</p><p>* 通过css选择器查找HTML元素 (document.querySelector()返回与该模式匹配的第一个元素，结果为一个元素；如果没找到匹配的元素，则返回null)</p><p>* 通过HTML对象选择器查找HTML对象</p><h2 id="20-dom节点获取，及其特性"><a href="#20-dom节点获取，及其特性" class="headerlink" title="20.dom节点获取，及其特性"></a>20.dom节点获取，及其特性</h2><p>通过 JavaScript，您可以使用以下节点属性在节点之间导航： </p><p> parentNode </p><p> childNodes[nodenumber] </p><p> firstChild </p><p> lastChild </p><p> nextSibling </p><p> previousSibling</p><h2 id="21-如果一个-ul-下面有-5个-li-如何给他们添加点击事情的方法"><a href="#21-如果一个-ul-下面有-5个-li-如何给他们添加点击事情的方法" class="headerlink" title="21.如果一个 ul 下面有 5个 li 如何给他们添加点击事情的方法"></a>21.如果一个 ul 下面有 5个 li 如何给他们添加点击事情的方法</h2><p><a href="https://blog.csdn.net/caoPengFlying/article/details/78495310" target="_blank" rel="noopener">js为li列表添加点击事件 - caoPengFlying的博客 - CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_42445490/article/details/88819063" target="_blank" rel="noopener">JS中for循环出现的问题：如何给li元素绑定事件，点击每个li元素弹出对应的 - 骆小胖~ - CSDN博客</a></p><h2 id="22-window-document-对象是什么？"><a href="#22-window-document-对象是什么？" class="headerlink" title="22.window document 对象是什么？"></a>22.window document 对象是什么？</h2><p>window对象</p><p>代表浏览器中的一个打开的窗口或者框架，window对象会在<body>或者<frameset>每次出现时被自动创建，在客户端JavaScript中，Window对象是全局对象，所有的表达式都在当前的环境中计算，要引用当前的窗口不需要特殊的语法，可以把那个窗口属性作为全局变量使用，例如：可以只写document，而不必写window.document。同样可以把窗口的对象方法当做函数来使用，如：只写alert（），而不必写window.alert</frameset></body></p><p>window对象实现了核心JavaScript所定义的全局属性和方法。</p><p>indow对象的window属性和self属性引用都是他自己。</p><p>document对象</p><p>代表整个HTML文档，可以用来访问页面中的所有元素 。</p><p>每一个载入浏览器的HTML文档都会成为document对象。document对象使我们可以从脚本中对HTML页面中的所有元素进行访问。<br> document对象是window对象的一部分可以通过window.document属性对其进行访问<br> HTMLDocument接口进行了扩展，定义HTML专用的属性和方法，很多属性和方法都是HTMLCollection对象，其中保存了对锚、表单、链接以及其他可脚本元素的引用。</p><h2 id="23-setTimeout-和-setInteval-的区别和使用方法"><a href="#23-setTimeout-和-setInteval-的区别和使用方法" class="headerlink" title="23.setTimeout 和 setInteval 的区别和使用方法"></a>23.setTimeout 和 setInteval 的区别和使用方法</h2><p><a href="https://blog.csdn.net/HandSome_He/article/details/81676640" target="_blank" rel="noopener">https://blog.csdn.net/HandSome_He/article/details/81676640</a></p><h2 id="24-异步同步"><a href="#24-异步同步" class="headerlink" title="24.异步同步"></a>24.异步同步</h2><p><strong>异步</strong></p><p>如果在函数返回的时候，调用者还不能购得到预期结果，而是将来通过一定的手段得到（例如回调函数），这就是异步。例如ajax操作。<br>如果函数是异步的，发出调用之后，马上返回，但是不会马上返回预期结果。调用者不必主动等待，当被调用者得到结果之后会通过回调函数主动通知调用者。</p><p><strong>同步</strong></p><p>如果在函数返回结果的时候，调用者能够拿到预期的结果(就是函数计算的结果)，那么这个函数就是同步的.如果函数是同步的，即使调用函数执行任务比较耗时，也会一致等待直到得到执行结果。</p><h2 id="25-如何实现页面跳转"><a href="#25-如何实现页面跳转" class="headerlink" title="25.如何实现页面跳转"></a>25.如何实现页面跳转</h2><p><strong>第一种：直接跳转加参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &lt;script language=<span class="string">"javascript"</span> type=<span class="string">"text/javascript"</span>&gt;           <span class="built_in">window</span>.location.href=<span class="string">"login.jsp?backurl="</span>+<span class="built_in">window</span>.location.href;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>直接跳转无参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">window</span>.location.href=<span class="string">'http://www.baidu.com'</span>;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>第二种：返回上一次预览界面</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;alert(<span class="string">"返回"</span>);<span class="built_in">window</span>.history.back(<span class="number">-1</span>);<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>标签嵌套：</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"javascript:history.go(-1)"</span>&gt;返回上一步&lt;a&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%=Request.ServerVariables("</span><span class="attr">HTTP_REFERER</span>")%&gt;</span>"&gt;返回上一步<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>第三种：指定跳转页面 对框架无效。。。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;       <span class="built_in">window</span>.navigate(<span class="string">"top.jsp"</span>);  <span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>第四种：指定自身跳转页面 对框架无效。。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"JavaScript"</span>&gt;          self.location=<span class="string">'top.htm'</span>;   <span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>第五种：指定自身跳转页面 对框架有效。。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;          alert(<span class="string">"非法访问！"</span>);          top.location=<span class="string">'xx.aspx'</span>;   <span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>第六种：按钮式 在button按钮添加 事件跳转。。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=<span class="string">"pclog"</span> type=<span class="string">"button"</span> value=<span class="string">"GO"</span> onClick=<span class="string">"location.href='login.aspx'"</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>第七种：在新窗口打开：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　&lt;a href=<span class="string">"javascript:"</span> onClick=<span class="string">"window.open('login.aspx','','height=500,width=611,scrollbars=yes,status=yes')"</span>&gt;开新窗口&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><h2 id="26-children-和-childNodes-的区别"><a href="#26-children-和-childNodes-的区别" class="headerlink" title="26.children 和 childNodes 的区别"></a>26.children 和 childNodes 的区别</h2><p>childNodes：获取节点，不同浏览器表现不同；</p><p>　　IE：只获取元素节点；</p><p>　　非IE：获取元素节点与文本节点；</p><p>　　解决方案：if(childNode.nodeName==”#text”) continue 或者 if(childNode.nodeType != ‘3’) continue </p><p>2、children：获取元素节点，浏览器表现相同。</p><p>　　因此建议使用children。</p><h2 id="27-如何实现insertAfter"><a href="#27-如何实现insertAfter" class="headerlink" title="27.如何实现insertAfter"></a>27.如何实现insertAfter</h2><p><code>parent.insertBefore(newElement,targetElement.nextSibling)</code>他的三部分为 父节点 新节点 目标节点 他会把新节点创建在目标节点之前 需要注意的是 父节点并无需获取 你通过目标节点.parentNode就可以获取<br>但是js并没有提供插入在目标节点之后的方法 我们可以自己写一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertAfter</span>(<span class="params">newElement,targetElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parent = targetElement.parentNode;</span><br><span class="line">    <span class="keyword">if</span>(parent.lastChild == targetElement)&#123;</span><br><span class="line">        parent.appendChild(newElement);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;           parent.insertBefore(newElement,targetElement.nextSibling);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先 他把目标节点的父节点找到包装在parent里 然后进行对比 如果这个父节点的最后一个节点是目标节点 那么无需插入在中间 因为appendChild默认就是将节点插入到末尾 </p><p>如果不是 目标节点游在中间 那么他会调用Before方法 把新节点插入到 目标节点的后面一个节点之前 其实也就是他的节点之后 绕了一点</p><h2 id="28-变量提升"><a href="#28-变量提升" class="headerlink" title="28.变量提升"></a>28.变量提升</h2><p><a href="https://cloud.tencent.com/developer/article/1405726" target="_blank" rel="noopener">JavaScript 变量提升 - 云+社区 - 腾讯云</a></p><h2 id="29-执行环境与作用域"><a href="#29-执行环境与作用域" class="headerlink" title="29.执行环境与作用域"></a>29.执行环境与作用域</h2><p><a href="https://www.jb51.net/article/83585.htm" target="_blank" rel="noopener">https://www.jb51.net/article/83585.htm</a></p><h2 id="30-克隆对象"><a href="#30-克隆对象" class="headerlink" title="30.克隆对象"></a>30.克隆对象</h2><h2 id="31-this以及修改this"><a href="#31-this以及修改this" class="headerlink" title="31.this以及修改this"></a>31.this以及修改this</h2><p><a href="https://www.cnblogs.com/yummylucky/p/10225066.html" target="_blank" rel="noopener">https://www.cnblogs.com/yummylucky/p/10225066.html</a></p><h2 id="32-call和apply区别"><a href="#32-call和apply区别" class="headerlink" title="32.call和apply区别"></a>32.call和apply区别</h2><p>通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2…这种形式（两者区别仅在于接收参数的方式不同。apply()方法第二个参数可以是Array的实例也可以是argument对象，call()方法必须明确地传入每一个参数）。通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。  </p><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。 </p><p> call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。 </p><p> bind除了返回是函数以外，它的参数和call一样。 </p><h2 id="33-闭包"><a href="#33-闭包" class="headerlink" title="33.闭包"></a>33.闭包</h2><p>  一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。 </p><p>  （1）什么是闭包：  闭包是指有权访问另外一个函数作用域中的变量的函数。闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。 </p><p>（2）为什么要用：  匿名自执行函数：我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。  结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p><h2 id="34-js运行机制"><a href="#34-js运行机制" class="headerlink" title="34.js运行机制"></a>34.js运行机制</h2><p><a href="https://www.baidu.com/link?url=HbzsQy4I1L5Y8RWr5NEReBaQkfm4vCCrb7qa9KYGo0tAglavxUxtAFUCZ2uxKxsEFl3ToD2XukSuaPtSDSDgcWGQmN2PlrmRRrj-ZRpq7g7&amp;wd=&amp;eqid=bfa5949d0000d54b000000065d294ed0" target="_blank" rel="noopener">https://www.baidu.com/link?url=HbzsQy4I1L5Y8RWr5NEReBaQkfm4vCCrb7qa9KYGo0tAglavxUxtAFUCZ2uxKxsEFl3ToD2XukSuaPtSDSDgcWGQmN2PlrmRRrj-ZRpq7g7&amp;wd=&amp;eqid=bfa5949d0000d54b000000065d294ed0</a></p><h2 id="35-js对象的创建方法"><a href="#35-js对象的创建方法" class="headerlink" title="35.js对象的创建方法"></a>35.js对象的创建方法</h2><p><a href="https://www.jb51.net/article/157045.htm" target="_blank" rel="noopener">js中对象与对象创建方法的各种方法_javascript技巧_脚本之家</a></p><h2 id="36-原型链"><a href="#36-原型链" class="headerlink" title="36.原型链"></a>36.原型链</h2><p><a href="https://blog.csdn.net/sinat_21274091/article/details/52741788" target="_blank" rel="noopener">JS重点整理之JS原型链彻底搞清楚 - sinat_21274091的博客 - CSDN博客</a></p><h2 id="37-对象的继承机制"><a href="#37-对象的继承机制" class="headerlink" title="37.对象的继承机制"></a>37.对象的继承机制</h2><p><a href="https://www.cnblogs.com/jofun/p/8727814.html" target="_blank" rel="noopener">详解JavaScript对象继承方式 - 雨霖月寒 - 博客园</a></p><h2 id="38-JS垃圾回收机制"><a href="#38-JS垃圾回收机制" class="headerlink" title="38.JS垃圾回收机制"></a>38.JS垃圾回收机制</h2><p><a href="https://blog.csdn.net/yingzizizizizizzz/article/details/77333996" target="_blank" rel="noopener">面试题——js垃圾回收机制和引起内存泄漏的操作 - yingzizizizizizzz的专栏 - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-你觉得js是一门怎样的语言，它与你学过的其他语言有什么不同&quot;&gt;&lt;a href=&quot;#1-你觉得js是一门怎样的语言，它与你学过的其他语言有什么不同&quot; class=&quot;headerlink&quot; title=&quot;1.你觉得js是一门怎样的语言，它与你学过的其他语言有什么不
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript面试1</title>
    <link href="http://yoursite.com/2019/07/15/JavaScript%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/07/15/JavaScript面试/</id>
    <published>2019-07-15T03:09:04.940Z</published>
    <updated>2019-07-15T03:20:54.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="几个很实用的BOM属性对象方法？"><a href="#几个很实用的BOM属性对象方法？" class="headerlink" title="几个很实用的BOM属性对象方法？"></a>几个很实用的BOM属性对象方法？</h2><p>Bom是浏览器对象。<br>(1)location对象<br>     location.href– 返回或设置当前文档的URL<br>     location.search – 返回URL中的查询字符串部分。例    如<code>http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu</code>返回包括(?)后面的内容?id=5&amp;name=dreamdu<br>     location.hash – 返回URL#后面的内容，如果没有#，返回空<br>     location.host – 返回URL中的域名部分，例如<code>[www.dreamdu.com](http://www.dreamdu.com)</code><br>     location.hostname – 返回URL中的主域名部分，例如dreamdu.com<br>     location.pathname – 返回URL的域名后的部分。例如 <code>http://www.dreamdu.com/xhtml/</code> 返回/xhtml/<br>     location.port – 返回URL中的端口部分。例如 <code>http://www.dreamdu.com:8080/xhtml/</code> 返回8080<br>     location.protocol – 返回URL中的协议部分。例如 <code>http://www.dreamdu.com:8080/xhtml/</code>返回(//)前面的内容http:<br>    location.assign – 设置当前文档的URL<br>    location.replace() – 设置当前文档的URL，并且在history对象的地址列表中移除这个URL<br>    location.replace(url);<br>     location.reload() – 重载当前页面<br>  (2)history对象<br>     history.go() – 前进或后退指定的页面数 history.go(num);<br>    history.back() – 后退一页<br>     history.forward() – 前进一页<br>  (3)Navigator对象<br>     navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)<br>     navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie </p><h2 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="Doctype作用?严格模式与混杂模式如何区分？它们有何意义?"></a>Doctype作用?严格模式与混杂模式如何区分？它们有何意义?</h2><p>  Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。<br>  严格模式的排版和JS 运作模式是 以该浏览器支持的最高标准运行。<br>  混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。 </p><h2 id="click在ios上有300ms延迟，原因及如何解决？"><a href="#click在ios上有300ms延迟，原因及如何解决？" class="headerlink" title="click在ios上有300ms延迟，原因及如何解决？"></a>click在ios上有300ms延迟，原因及如何解决？</h2><p>  (1)粗暴型，禁用缩放<br>  &lt; meta name=”viewport” content=”width=device-width, user-scalable=no”&gt;<br>  (2)利用FastClick，其原理是：<br>  检测到touchend事件后，立刻出发模拟click事件，并且把浏览器300毫秒之后真正出发的事件给阻断掉 </p><h2 id="addEventListener参数"><a href="#addEventListener参数" class="headerlink" title="addEventListener参数"></a>addEventListener参数</h2><p>  addEventListener(event, function, useCapture)<br>  其中，event指定事件名；function指定要事件触发时执行的函数；useCapture指定事件是否在捕获或冒泡阶段执行。 </p><h2 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h2><p>  降低请求量：合并资源，减少HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。<br>  加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。<br>  缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。<br>  渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline。 </p><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><p>  get和post是http常见的请求方法，还有很多比如patch、delete、put、options等等<br>  get参数通过url传递，post放在request body中。<br>  get请求在url中传递的参数是有长度限制的，而post没有。<br>  get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。<br>  get请求只能进行url编码，而post支持多种编码方式<br>  get请求会浏览器主动cache，而post支持多种编码方式。<br>  get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。<br>  GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。<br>  GET产生一个TCP数据包；POST产生两个TCP数据包。 </p><h2 id="说一下浏览器缓存"><a href="#说一下浏览器缓存" class="headerlink" title="说一下浏览器缓存"></a>说一下浏览器缓存</h2><pre><code>缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。强缓存相关字段有expires，cache-control。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。协商缓存相关字段有Last-Modified/If-Modified-Since，Etag/If-None-Match </code></pre><h2 id="浏览器在生成页面的时候，会生成那两颗树？"><a href="#浏览器在生成页面的时候，会生成那两颗树？" class="headerlink" title="浏览器在生成页面的时候，会生成那两颗树？"></a>浏览器在生成页面的时候，会生成那两颗树？</h2><pre><code>构造两棵树，DOM树和CSSOM规则树.当浏览器接收到服务器相应来的HTML文档后，会遍历文档节点，生成DOM树，CSSOM规则树由浏览器解析CSS文件生成， </code></pre><h2 id="怎么看网站的性能如何"><a href="#怎么看网站的性能如何" class="headerlink" title="怎么看网站的性能如何"></a>怎么看网站的性能如何</h2><pre><code>检测页面加载时间一般有两种方式，一种是被动去测：就是在被检测的页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析，另一种主动监测的方式，即主动的搭建分布式受控环境，模拟用户发起页面访问请求，主动采集性能数据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如说性能极客 </code></pre><h2 id="浏览器输入网址到页面渲染全过程"><a href="#浏览器输入网址到页面渲染全过程" class="headerlink" title="浏览器输入网址到页面渲染全过程"></a>浏览器输入网址到页面渲染全过程</h2><pre><code>DNS解析 TCP连接发送 HTTP请求服务器 处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束 </code></pre><h2 id="HTML5和CSS3用的多吗？你了解它们的新属性吗？有在项目中用过吗？"><a href="#HTML5和CSS3用的多吗？你了解它们的新属性吗？有在项目中用过吗？" class="headerlink" title="HTML5和CSS3用的多吗？你了解它们的新属性吗？有在项目中用过吗？"></a>HTML5和CSS3用的多吗？你了解它们的新属性吗？有在项目中用过吗？</h2><p> html5：<br>    1）标签增删<br>    8个语义元素 header section footer aside nav main article figure<br>    内容元素mark高亮 progress进度<br>    新的表单控件calander date time email url search<br>    新的input类型 color date datetime datetime-local email<br>    移除过时标签big font frame frameset<br>    2）canvas绘图，支持内联SVG。支持MathML<br>    3）多媒体audio video source embed track<br>    4）本地离线存储，把需要离线存储在本地的文件列在一个manifest配置文件<br>    5）web存储。localStorage、SessionStorage<br> css3：<br>    CSS3边框如border-radius，box-shadow等；CSS3背景如background-size，background-origin等；CSS3 2D，3D转换如transform等；CSS3动画如animation等。</p><h2 id="link标签和-import标签的区别"><a href="#link标签和-import标签的区别" class="headerlink" title="link标签和@import标签的区别"></a>link标签和@import标签的区别</h2><pre><code>link属于html标签，而@import是css提供的页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。link方式样式的权重高于@import的。 </code></pre><h2 id="transition和animation的区别"><a href="#transition和animation的区别" class="headerlink" title="transition和animation的区别"></a>transition和animation的区别</h2><pre><code>animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。 </code></pre><h2 id="BFC（块级格式化上下文，用于清楚浮动，防止margin重叠等）"><a href="#BFC（块级格式化上下文，用于清楚浮动，防止margin重叠等）" class="headerlink" title="BFC（块级格式化上下文，用于清楚浮动，防止margin重叠等）"></a>BFC（块级格式化上下文，用于清楚浮动，防止margin重叠等）</h2><pre><code>直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。BFC区域不会与float box重叠BFC是页面上的一个独立容器，子元素不会影响到外面计算BFC的高度时，浮动元素也会参与计算那些元素会生成BFC：根元素float不为none的元素position为fixed和absolute的元素display为inline-block、table-cell、table-caption，flex，inline-flex的元素overflow不为visible的元素 </code></pre><h2 id="visibility-hidden-opacity-0，display-none"><a href="#visibility-hidden-opacity-0，display-none" class="headerlink" title="visibility=hidden, opacity=0，display:none"></a>visibility=hidden, opacity=0，display:none</h2><pre><code>opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</code></pre><h2 id="双边距重叠问题（外边距折叠）"><a href="#双边距重叠问题（外边距折叠）" class="headerlink" title="双边距重叠问题（外边距折叠）"></a>双边距重叠问题（外边距折叠）</h2><pre><code>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠折叠的结果为：两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。两个外边距一正一负时，折叠结果是两者的相加的和。 </code></pre><h2 id="position属性-比较"><a href="#position属性-比较" class="headerlink" title="position属性 比较"></a>position属性 比较</h2><pre><code>固定定位fixed：元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed定位使元素的位置与文档流无关，因此不占据空间。 Fixed定位的元素和其他元素重叠。相对定位relative：如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。绝对定位absolute：绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。粘性定位sticky：元素先按照普通文档流定位，然后相对于该元素在流中的flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。默认定位Static：默认值。没有定位，元素出现在正常的流中（忽略top, bottom, left, right 或者 z-index 声明）。inherit:规定应该从父元素继承position 属性的值。 </code></pre><h2 id="z-index的定位方法"><a href="#z-index的定位方法" class="headerlink" title="z-index的定位方法"></a>z-index的定位方法</h2><pre><code>z-index属性设置元素的堆叠顺序，拥有更好堆叠顺序的元素会处于较低顺序元素之前，z-index可以为负，且z-index只能在定位元素上奏效，该属性设置一个定位元素沿z轴的位置，如果为正数，离用户越近，为负数，离用户越远，它的属性值有auto，默认，堆叠顺序与父元素相等，number，inherit，从父元素继承z-index属性的值 </code></pre><h2 id="line-height和height的区别"><a href="#line-height和height的区别" class="headerlink" title="line-height和height的区别"></a>line-height和height的区别</h2><pre><code>line-height一般是指布局里面一段文字上下行之间的高度，是针对字体来设置的，height一般是指容器的整体高度</code></pre><h2 id="设置一个元素的背景颜色，背景颜色会填充哪些区域？"><a href="#设置一个元素的背景颜色，背景颜色会填充哪些区域？" class="headerlink" title="设置一个元素的背景颜色，背景颜色会填充哪些区域？"></a>设置一个元素的背景颜色，背景颜色会填充哪些区域？</h2><pre><code>background-color设置的背景颜色会填充元素的content、padding、border区域</code></pre><h2 id="知道属性选择器和伪类选择器的优先级吗"><a href="#知道属性选择器和伪类选择器的优先级吗" class="headerlink" title="知道属性选择器和伪类选择器的优先级吗"></a>知道属性选择器和伪类选择器的优先级吗</h2><pre><code>属性选择器和伪类选择器优先级相同 </code></pre><h2 id="inline-block、inline和block的区别；为什么img是inline还可以设置宽高"><a href="#inline-block、inline和block的区别；为什么img是inline还可以设置宽高" class="headerlink" title="inline-block、inline和block的区别；为什么img是inline还可以设置宽高"></a>inline-block、inline和block的区别；为什么img是inline还可以设置宽高</h2><p>   Block是块级元素，其前后都会有换行符，能设置宽度，高度，margin/padding水平垂直方向都有效。<br>   Inline：设置width和height无效，margin在竖直方向上无效，padding在水平方向垂直方向都有效，前后无换行符<br>   Inline-block：能设置宽度高度，margin/padding水平垂直方向 都有效，前后无换行符 </p><h2 id="overflow的原理"><a href="#overflow的原理" class="headerlink" title="overflow的原理"></a>overflow的原理</h2><p>   要讲清楚这个解决方案的原理，首先需要了解块格式化上下文，A block formatting context is a part of a visual CSS rendering of a Web page. It is the region in which the layout of block boxes occurs and in which floats interact with each other.翻译过来就是块格式化上下文是CSS可视化渲染的一部分，它是一块区域，规定了内部块盒 的渲染方式，以及浮动相互之间的影响关系<br>   当元素设置了overflow样式且值部位visible时，该元素就构建了一个BFC，BFC在计算高度时，内部浮动元素的高度也要计算在内，也就是说技术BFC区域内只有一个浮动元素，BFC的高度也不会发生塌缩，所以达到了清除浮动的目的</p><h2 id="css布局"><a href="#css布局" class="headerlink" title="css布局"></a>css布局</h2><p>   六种布局方式总结：圣杯布局、双飞翼布局、Flex布局、绝对定位布局、表格布局、网格布局。<br>   圣杯布局是指布局从上到下分为header、container、footer，然后container部分定为三栏布局。这种布局方式同样分为header、container、footer。圣杯布局的缺陷在于 center 是在 container 的padding中的，因此宽度小的时候会出现混乱。<br>   双飞翼布局给center 部分包裹了一个 main 通过设置margin主动地把页面撑开。<br>   Flex布局是由CSS3提供的一种方便的布局方式。<br>   绝对定位布局是给container 设置position: relative和overflow: hidden，因为绝对定位的元素的参照物为第一个postion不为static的祖先元素。 left 向左浮动，right 向右浮动。center 使用绝对定位，通过设置left和right并把两边撑开。 center 设置top: 0和bottom: 0使其高度撑开。<br>   表格布局的好处是能使三栏的高度统一。<br>   网格布局可能是最强大的布局方式了，使用起来极其方便，但目前而言，兼容性并不好。网格布局，可以将页面分割成多个区域，或者用来定义内部元素的大小，位置，图层关系。 </p><h2 id="说一下闭包"><a href="#说一下闭包" class="headerlink" title="说一下闭包"></a>说一下闭包</h2><p>   一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。 </p><p>  （1）什么是闭包：  闭包是指有权访问另外一个函数作用域中的变量的函数。闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。当在一个函数内定义另外一个函数就会产生闭包。 </p><p>（2）为什么要用：  匿名自执行函数：我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。  结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。  </p><h2 id="类的继承和创建"><a href="#类的继承和创建" class="headerlink" title="类的继承和创建"></a>类的继承和创建</h2><p> （1）类的创建（es5）：new一个function，在这个function的prototype里面增加属性和方法。<br>下面来创建一个Animal类：<br>// 定义一个动物类<br>function Animal (name) {<br>// 属性<br>this.name = name || ‘Animal’;<br>// 实例方法<br>this.sleep = function(){<br>console.log(this.name + ‘正在睡觉！’);<br>}<br>}<br>// 原型方法<br>Animal.prototype.eat = function(food) {<br>console.log(this.name + ‘正在吃：’ + food);<br>};<br>这样就生成了一个Animal类，实力化生成对象后，有方法和属性。<br>（2）类的继承——原型链继承<br>–原型链继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.name = <span class="string">'cat'</span>;</span><br><span class="line"><span class="comment">//　Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.eat(<span class="string">'fish'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>介绍：在这里我们可以看到new了一个空对象,这个空对象指向Animal并且Cat.prototype指向了这个空对象，这种就是基于原型链的继承。<br>特点：基于原型链，既是父类的实例，也是子类的实例<br>缺点：无法实现多继承<br>（3）构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">Animal.call(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>特点：可以实现多继承<br>缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。<br>（4）实例继承和拷贝继承<br>实例继承：为父类实例添加新特性，作为子类实例返回<br>拷贝继承：拷贝父类元素上的属性和方法<br>上述两个实用性不强，不一一举例。<br>（5）组合继承：相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">Animal.call(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>特点：可以继承实例属性/方法，也可以继承原型属性/方法<br>缺点：调用了两次父类构造函数，生成了两份实例<br>（6）寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">Animal.call(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name || <span class="string">'Tom'</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br></pre></td></tr></table></figure><p>// 创建一个没有实例方法的类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Super.prototype = Animal.prototype;</span><br></pre></td></tr></table></figure><p>//将实例作为子类的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// Test Code</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat.name);</span><br><span class="line"><span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>较为推荐 </p><h2 id="说说前端中的事件流"><a href="#说说前端中的事件流" class="headerlink" title="说说前端中的事件流"></a>说说前端中的事件流</h2><p>HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。<br>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。<br>事件捕获阶段<br>处于目标阶段<br>事件冒泡阶段<br>addEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。<br>IE只支持事件冒泡。 </p><h2 id="如何让事件先冒泡后捕获"><a href="#如何让事件先冒泡后捕获" class="headerlink" title="如何让事件先冒泡后捕获"></a>如何让事件先冒泡后捕获</h2><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。 </p><h2 id="说一下事件委托"><a href="#说一下事件委托" class="headerlink" title="说一下事件委托"></a>说一下事件委托</h2><p>事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。<br>举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。<br>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。 </p><h2 id="mouseover和mouseenter的区别"><a href="#mouseover和mouseenter的区别" class="headerlink" title="mouseover和mouseenter的区别"></a>mouseover和mouseenter的区别</h2><p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout<br>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave </p><h2 id="js的new操作符做了哪些事情"><a href="#js的new操作符做了哪些事情" class="headerlink" title="js的new操作符做了哪些事情"></a>js的new操作符做了哪些事情</h2><p>new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。 </p><h2 id="改变函数内部this指针的指向函数（bind，apply，call的区别）"><a href="#改变函数内部this指针的指向函数（bind，apply，call的区别）" class="headerlink" title="改变函数内部this指针的指向函数（bind，apply，call的区别）"></a>改变函数内部this指针的指向函数（bind，apply，call的区别）</h2><p>通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2…这种形式。通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。  </p><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。 </p><p> call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。 </p><p> bind除了返回是函数以外，它的参数和call一样。 </p><h2 id="js的各种位置，比如clientHeight-scrollHeight-offsetHeight-以及scrollTop-offsetTop-clientTop的区别？"><a href="#js的各种位置，比如clientHeight-scrollHeight-offsetHeight-以及scrollTop-offsetTop-clientTop的区别？" class="headerlink" title="js的各种位置，比如clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？"></a>js的各种位置，比如clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？</h2><p>clientHeight：表示的是可视区域的高度，不包含border和滚动条<br>offsetHeight：表示可视区域的高度，包含了border和滚动条<br>scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。<br>clientTop：表示边框border的厚度，在未指定的情况下一般为0<br>scrollTop：滚动后被隐藏的高度，获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)距离顶端的高度。 </p><h2 id="js拖拽功能的实现"><a href="#js拖拽功能的实现" class="headerlink" title="js拖拽功能的实现"></a>js拖拽功能的实现</h2><p>首先是三个事件，分别是mousedown，mousemove，mouseup<br>当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mousemove里面的具体方法。<br>clientX，clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用offsetX和offsetY来表示元素的元素的初始坐标，移动的举例应该是：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标。<br>也就是说定位信息为：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.<br>还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的left<br>以及top等等值。<br>补充：也可以通过html5的拖放（Drag 和 drop）来实现 </p><h2 id="JS中的垃圾回收机制"><a href="#JS中的垃圾回收机制" class="headerlink" title="JS中的垃圾回收机制"></a>JS中的垃圾回收机制</h2><p> 必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。<br>这段话解释了为什么需要系统需要垃圾回收，JS不像C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：<br>var a=”hello world”;<br>var b=”world”;<br>var a=b;<br>//这时，会释放掉”hello world”，释放内存以便再引用<br>垃圾回收的方法：标记清除、计数引用。<br>标记清除<br>这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。<br>垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。<br>引用计数法<br>另一种不太常见的方法就是引用计数法，引用计数法的意思就是每个值没引用的次数，当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减1，当这个值的引用次数为0的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为0的这些值。<br>用引用计数法会存在内存泄露，下面来看原因：<br>function problem() {<br>var objA = new Object();<br>var objB = new Object();<br>objA.someOtherObject = objB;<br>objB.anotherObject = objA;<br>}<br>在这个例子里面，objA和objB通过各自的属性相互引用，这样的话，两个对象的引用次数都为2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为0，这样的相互引用如果大量存在就会导致内存泄露。<br>特别是在DOM对象中，也容易存在这种问题：<br>var element=document.getElementById（’‘）；<br>var myObj=new Object();<br>myObj.element=element;<br>element.someObject=myObj;<br>这样就不会有垃圾回收的过程。 </p><h2 id="eval是做什么的"><a href="#eval是做什么的" class="headerlink" title="eval是做什么的"></a>eval是做什么的</h2><p>它的功能是将对应的字符串解析成js并执行，应该避免使用js，因为非常消耗性能（2次，一次解析成js，一次执行） </p><h2 id="如何理解前端模块化"><a href="#如何理解前端模块化" class="headerlink" title="如何理解前端模块化"></a>如何理解前端模块化</h2><p>前端模块化就是复杂的文件编程一个一个独立的模块，比如js文件等等，分成独立的模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问题，所以有了commonJS规范，AMD，CMD规范等等，以及用于js打包（编译等处理）的工具webpack </p><h2 id="对象深度克隆的简单实现"><a href="#对象深度克隆的简单实现" class="headerlink" title="对象深度克隆的简单实现"></a>对象深度克隆的简单实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> newObj= obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? []:&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> obj)&#123;</span><br><span class="line"><span class="keyword">var</span> temple= <span class="keyword">typeof</span> obj[item] == <span class="string">'object'</span> ? deepClone(obj[item]):obj[item];</span><br><span class="line">newObj[item] = temple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5的常用的对象克隆的一种方式。注意数组是对象，但是跟对象又有一定区别，所以我们一开始判断了一些类型，决定newObj是对象还是数组</p><h2 id="实现一个once函数，传入函数参数只执行一次"><a href="#实现一个once函数，传入函数参数只执行一次" class="headerlink" title="实现一个once函数，传入函数参数只执行一次"></a>实现一个once函数，传入函数参数只执行一次</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ones</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> tag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag==<span class="literal">true</span>)&#123;</span><br><span class="line">func.apply(<span class="literal">null</span>,<span class="built_in">arguments</span>);</span><br><span class="line">tag=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js监听对象属性的改变"><a href="#js监听对象属性的改变" class="headerlink" title="js监听对象属性的改变"></a>js监听对象属性的改变</h2><p> 我们假设这里有一个user对象,<br>(1)在ES5中可以通过Object.defineProperty来实现已有属性的监听<br>Object.defineProperty(user,’name’,{<br>set：function(key,value){<br>}<br>})<br>缺点：如果id不在user对象中，则不能监听id的变化<br>(2)在ES6中可以通过Proxy来实现<br>var  user = new Proxy({}，{<br>set：function(target,key,value,receiver){<br>}<br>})<br>这样即使有属性在user中不存在，通过user.id来定义也同样可以这样监听这个属性的变化哦~ </p><h2 id="如何实现一个私有变量，用getName方法可以访问，不能直接访问"><a href="#如何实现一个私有变量，用getName方法可以访问，不能直接访问" class="headerlink" title="如何实现一个私有变量，用getName方法可以访问，不能直接访问"></a>如何实现一个私有变量，用getName方法可以访问，不能直接访问</h2><p>(1)通过defineProperty来实现<br>obj={<br>name:yuxiaoliang,<br>getName:function(){<br>return this.name<br>}<br>}<br>object.defineProperty(obj,”name”,{<br>//不可枚举不可配置<br>});<br>(2)通过函数的创建形式<br>function product(){<br>var name=’yuxiaoliang’;<br>this.getName=function(){<br>return name;<br>}<br>}<br>var obj=new product();</p><h2 id="和-、以及Object-is的区别"><a href="#和-、以及Object-is的区别" class="headerlink" title="==和===、以及Object.is的区别"></a><code>==</code>和<code>===</code>、以及Object.is的区别</h2><p> (1)<code>==</code><br>主要存在：强制转换成number,null==undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" "</span>==<span class="number">0</span>  <span class="comment">//true</span></span><br><span class="line"><span class="string">"0"</span>==<span class="number">0</span>  <span class="comment">//true</span></span><br><span class="line"><span class="string">" "</span> !=<span class="string">"0"</span> <span class="comment">//true</span></span><br><span class="line"><span class="number">123</span>==<span class="string">"123"</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">null</span>==<span class="literal">undefined</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>(2)Object.js<br>主要的区别就是<code>+0！=-0</code>而<code>NaN==NaN</code><br>(相对比<code>===</code>和<code>==</code>的改进) </p><h2 id="setTimeout、setInterval和requestAnimationFrame之间的区别"><a href="#setTimeout、setInterval和requestAnimationFrame之间的区别" class="headerlink" title="setTimeout、setInterval和requestAnimationFrame之间的区别"></a>setTimeout、setInterval和requestAnimationFrame之间的区别</h2><p>这里有一篇文章讲的是requestAnimationFrame：<a href="http://www.cnblogs.com/xiaohuochai/p/5777186.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaohuochai/p/5777186.html</a><br>与setTimeout和setInterval不同，requestAnimationFrame不需要设置时间间隔，<br>大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms。<br>RAF采用的是系统时间间隔，不会因为前面的任务，不会影响RAF，但是如果前面的任务多的话，<br>会响应setTimeout和setInterval真正运行时的时间间隔。<br>特点：<br>（1）requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。<br>（2）在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量<br>（3）requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。 </p><h2 id="实现一个两列等高布局，讲讲思路"><a href="#实现一个两列等高布局，讲讲思路" class="headerlink" title="实现一个两列等高布局，讲讲思路"></a>实现一个两列等高布局，讲讲思路</h2><p>为了实现两列等高，可以给每列加上 padding-bottom:9999px;<br>margin-bottom:-9999px;同时父元素设置overflow:hidden; </p><h2 id="this的指向-哪几种"><a href="#this的指向-哪几种" class="headerlink" title="this的指向 哪几种"></a>this的指向 哪几种</h2><p>默认绑定：全局环境中，this默认绑定到window。<br>隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，this隐式绑定到该直接对象。<br>隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到window。显式绑定：通过call()、apply()、bind()方法把对象绑定到this上，叫做显式绑定。<br>new绑定：如果函数或者方法调用之前带有关键字new，它就构成构造函数调用。对于this绑定来说，称为new绑定。<br>【1】构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。<br>【2】如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。<br>【3】如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象。 </p><h2 id="数组移除第一个元素的方法"><a href="#数组移除第一个元素的方法" class="headerlink" title="数组移除第一个元素的方法"></a>数组移除第一个元素的方法</h2><p>splice和shift方法</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>把一个元素响应事件（click、keydown……）的函数委托到另一个元素；<br>优点：减少内存消耗、动态绑定事件。 </p><h2 id="dom是什么，你的理解？"><a href="#dom是什么，你的理解？" class="headerlink" title="dom是什么，你的理解？"></a>dom是什么，你的理解？</h2><p>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。 </p><h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>事件代理是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件代理，代理它们父级代为执行事件。   事件代理/事件委托：利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的事件，   简而言之：事件代理就是说我们将事件添加到本来要添加的事件的父节点，将事件委托给父节点来触发处理函数，这通常会使用在大量的同级元素需要添加同一类事件的时候，比如一个动态的非常多的列表，需要为每个列表项都添加点击事件，这时就可以使用事件代理，通过判断e.target.nodeName来判断发生的具体元素，这样做的好处是减少事件绑定，同事动态的DOM结构任然可以监听，事件代理发生在冒泡阶段  </p><h2 id="箭头函数和function的区别"><a href="#箭头函数和function的区别" class="headerlink" title="箭头函数和function的区别"></a>箭头函数和function的区别</h2><p>箭头函数根本就没有绑定自己的this，在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用 </p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>arguments是类数组对象，有length属性，不能调用数组方法<br>可用Array.from()转换 </p><h2 id="箭头函数获取arguments"><a href="#箭头函数获取arguments" class="headerlink" title="箭头函数获取arguments"></a>箭头函数获取arguments</h2><p>可用…rest参数获取</p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>法一：indexOf循环去重<br>法二：ES6 Set去重；Array.from(new Set(array))<br>法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。 </p><h2 id="es6的常用"><a href="#es6的常用" class="headerlink" title="es6的常用"></a>es6的常用</h2><p>promise，await/async，let，const，块级作用域，箭头函数</p><h2 id="引用类型常见的对象"><a href="#引用类型常见的对象" class="headerlink" title="引用类型常见的对象"></a>引用类型常见的对象</h2><p>Object、Array、RegExp、Date、Function、特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)等 </p><h2 id="JS的数据类型"><a href="#JS的数据类型" class="headerlink" title="JS的数据类型"></a>JS的数据类型</h2><p>字符串，数字，布尔，数组，null，Undefined，symbol，对象。 </p><h2 id="JavaScript中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？"><a href="#JavaScript中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？" class="headerlink" title="JavaScript中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？"></a>JavaScript中的轮播实现原理？假如一个页面上有两个轮播，你会怎么实现？</h2><p>图片轮播的原理就是图片排成一行，然后准备一个只有一张图片大小的容器，对这个容器设置超出部分隐藏，在控制定时器来让这些图片整体左移或右移，这样呈现出来的效果就是图片在轮播了。<br>如果有两个轮播，可封装一个轮播组件，供两处调用 </p><h2 id="js对象类型，基本对象类型以及引用对象类型的区别"><a href="#js对象类型，基本对象类型以及引用对象类型的区别" class="headerlink" title="js对象类型，基本对象类型以及引用对象类型的区别"></a>js对象类型，基本对象类型以及引用对象类型的区别</h2><p>分为基本对象类型和引用对象类型<br>基本数据类型：按值访问，可操作保存在变量中的实际的值。基本类型值指的是简单的数据段。基本数据类型有这六种:undefined、null、string、number、boolean、symbol。<br>引用类型：当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。引用类型值指那些可能为多个值构成的对象。<br>引用类型有这几种：Object、Array、RegExp、Date、Function、特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)。 </p><h2 id="js加载过程阻塞，解决方法。"><a href="#js加载过程阻塞，解决方法。" class="headerlink" title="js加载过程阻塞，解决方法。"></a>js加载过程阻塞，解决方法。</h2><p>指定script标签的async属性。<br>如果async=”async”，脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）<br>如果不使用async 且 defer=”defer”：脚本将在页面完成解析时执行 </p><h2 id="private和public"><a href="#private和public" class="headerlink" title="private和public"></a>private和public</h2><p>public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用<br>private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用 </p><h2 id="怎么获得对象上的属性：比如说通过Object-key（）"><a href="#怎么获得对象上的属性：比如说通过Object-key（）" class="headerlink" title="怎么获得对象上的属性：比如说通过Object.key（）"></a>怎么获得对象上的属性：比如说通过Object.key（）</h2><p>从ES5开始，有三种方法可以列出对象的属性<br>for（let I in obj）该方法依次访问一个对象及其原型链中所有可枚举的类型<br>object.keys:返回一个数组，包括所有可枚举的属性名称<br>object.getOwnPropertyNames:返回一个数组包含不可枚举的属性 </p><h2 id="js原型链，原型链的顶端是什么？Object的原型是什么？Object的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法"><a href="#js原型链，原型链的顶端是什么？Object的原型是什么？Object的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法" class="headerlink" title="js原型链，原型链的顶端是什么？Object的原型是什么？Object的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法"></a>js原型链，原型链的顶端是什么？Object的原型是什么？Object的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法</h2><p>能够把这个讲清楚弄明白是一件很困难的事，<br>首先明白原型是什么，在ES6之前，JS没有类和继承的概念，JS是通过原型来实现继承的，在JS中一个构造函数默认带有一个prototype属性，这个的属性值是一个对象，同时这个prototype对象自带有一个constructor属性，这个属性指向这个构造函数，同时每一个实例都会有一个<em>proto_属性指向这个prototype对象，我们可以把这个叫做隐式原型，我们在使用一个实例的方法的时候，会先检查这个实例中是否有这个方法，没有的话就会检查这个prototype对象是否有这个方法，<br>基于这个规则，如果让原型对象指向另一个类型的实例，即constructor1.protoytpe=instance2，这时候如果试图引用constructor1构造的实例instance1的某个属性p1,<br>首先会在instance1内部属性中找一遍，<br>接着会在instance1._proto_（constructor1.prototype）即是instance2中寻找p1<br>搜寻轨迹：instance1-&gt;instance2-&gt;constructor2.prototype……-&gt;Object.prototype;这即是原型链，原型链顶端是Object.prototype<br>补充学习：<br>每个函数都有一个prototype属性，这个属性指向了一个对象，这个对象正是调用该函数而创建的实例的原型，那么什么是原型呢，可以这样理解，每一个JavaScript对象在创建的时候就会预制管理另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性，如图：  <img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552431147224_7A94EFA1E3409049184A20DD1711F1B6" alt="img"><br>那么怎么表示实例与实例原型的关系呢，这时候就要用到第二个属性_proto</em><br>这是每一个JS对象都会有的一个属性，指向这个对象的原型，如图：  <img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552431218799_241BFEF25322EAB2AC14C47F68A7E31F" alt="img"><br>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢，指向实例是没有的，因为一个构造函数可以生成多个实例，但是原型有属性可以直接指向构造函数，通过constructor即可<br>接下来讲解实例和原型的关系：<br>当读取实例的属性时，如果找不到，就会查找与对象相关的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层，那么原型的原型是什么呢，首先，原型也是一个对象，既然是对象，我们就可以通过构造函数的方式创建它，所以原型对象就是通过Object构造函数生成的，如图：<img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552431256187_AE645DCD4DDEE468730F9EE81F7D1983" alt="img"><br>那么Object.prototype的原型呢，我们可以打印console.log(Object.prototype.<strong>proto</strong> === null)，返回true<br>null表示没有对象，即该处不应有值，所以Object.prototype没有原型，如图：  <img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552431329816_BC67B14895C30FC45BA53BF8B01127BF" alt="img"><br>图中这条蓝色的线即是原型链，<br>最后补充三点：<br>constructor：<br>function Person(){<br>}<br>var person = new Person();<br>console.log(Person === person.constructor);<br>原本person中没有constructor属性，当不能读取到constructor属性时，会从person的原型中读取，所以指向构造函数Person<br><strong>proto</strong>：<br>绝大部分浏览器支持这个非标准的方法访问原型，然而它并不存在与Person.prototype中，实际上它来自Object.prototype，当使用obj.<strong>proto</strong>时，可以理解为返回来Object.getPrototype(obj)<br>继承：<br>前面说到，每个对象都会从原型继承属性，但是引用《你不知道的JS》中的话，继承意味着复制操作，然而JS默认不会复制对象的属性，相反，JS只是在两个对象之间创建一个关联，这样子一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，叫委托更合适</p><h2 id="let-const-var的区别-，什么是块级作用域，如何用ES5的方法实现块级作用域（立即执行函数），ES6-呢"><a href="#let-const-var的区别-，什么是块级作用域，如何用ES5的方法实现块级作用域（立即执行函数），ES6-呢" class="headerlink" title="let const var的区别 ，什么是块级作用域，如何用ES5的方法实现块级作用域（立即执行函数），ES6 呢"></a>let const var的区别 ，什么是块级作用域，如何用ES5的方法实现块级作用域（立即执行函数），ES6 呢</h2><p>提起这三个最明显的区别是var声明的变量是全局或者整个函数块的，而let,const声明的变量是块级的变量，var声明的变量存在变量提升，let,const不存在，let声明的变量允许重新赋值，const不允许</p><h2 id="JS中string的startwith和indexof两种方法的区别"><a href="#JS中string的startwith和indexof两种方法的区别" class="headerlink" title="JS中string的startwith和indexof两种方法的区别"></a>JS中string的startwith和indexof两种方法的区别</h2><p> JS中startwith函数，其参数有3个，stringObj,要搜索的字符串对象，str，搜索的字符串，position，可选，从哪个位置开始搜索，如果以position开始的字符串以搜索字符串开头，则返回true，否则返回false<br>Indexof函数，indexof函数可返回某个指定字符串在字符串中首次出现的位置</p><h2 id="有了解过事件模型吗，DOM0级和DOM2级有什么区别，DOM的分级是什么"><a href="#有了解过事件模型吗，DOM0级和DOM2级有什么区别，DOM的分级是什么" class="headerlink" title="有了解过事件模型吗，DOM0级和DOM2级有什么区别，DOM的分级是什么"></a>有了解过事件模型吗，DOM0级和DOM2级有什么区别，DOM的分级是什么</h2><p>JSDOM事件流存在如下三个阶段：<br>事件捕获阶段<br>处于目标阶段<br>事件冒泡阶段<br>JSDOM标准事件流的触发的先后顺序为：先捕获再冒泡，点击DOM节点时，事件传播顺序：事件捕获阶段，从上往下传播，然后到达事件目标节点，最后是冒泡阶段，从下往上传播<br>DOM节点添加事件监听方法addEventListener，中参数capture可以指定该监听是添加在事件捕获阶段还是事件冒泡阶段，为false是事件冒泡，为true是事件捕获，并非所有的事件都支持冒泡，比如focus，blur等等，我们可以通过event.bubbles来判断<br>事件模型有三个常用方法：<br>event.stopPropagation:阻止捕获和冒泡阶段中，当前事件的进一步传播，<br>event.stopImmediatePropagetion，阻止调用相同事件的其他侦听器，<br>event.preventDefault，取消该事件（假如事件是可取消的）而不停止事件的进一步传播，<br>event.target：指向触发事件的元素，在事件冒泡过程中这个值不变<br>event.currentTarget = this，时间帮顶的当前元素，只有被点击时目标元素的target才会等于currentTarget，<br>最后，对于执行顺序的问题，如果DOM节点同时绑定了两个事件监听函数，一个用于捕获，一个用于冒泡，那么两个事件的执行顺序真的是先捕获在冒泡吗，答案是否定的，绑定在被点击元素的事件是按照代码添加顺序执行的，其他函数是先捕获再冒泡 </p><h2 id="setTimeout-fn-100-100毫秒是如何权衡的"><a href="#setTimeout-fn-100-100毫秒是如何权衡的" class="headerlink" title="setTimeout(fn,100);100毫秒是如何权衡的"></a>setTimeout(fn,100);100毫秒是如何权衡的</h2><p>etTimeout()函数只是将事件插入了任务列表，必须等到当前代码执行完，主线程才会去执行它指定的回调函数，有可能要等很久，所以没有办法保证回调函数一定会在setTimeout指定的时间内执行，100毫秒是插入队列的时间+等待的时间 </p><h2 id="深浅拷贝的区别和实现"><a href="#深浅拷贝的区别和实现" class="headerlink" title="深浅拷贝的区别和实现"></a>深浅拷贝的区别和实现</h2><p>数组的浅拷贝：<br>如果是数组，我们可以利用数组的一些方法，比如slice，concat方法返回一个新数组的特性来实现拷贝，但假如数组嵌套了对象或者数组的话，使用concat方法克隆并不完整，如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化，我们把这种复制引用的拷贝方法称为浅拷贝，<br>深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也互相分离，修改一个对象的属性，不会影响另一个<br>如何深拷贝一个数组<br>1、这里介绍一个技巧，不仅适用于数组还适用于对象！那就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'old'</span>, <span class="number">1</span>, <span class="literal">true</span>, [<span class="string">'old1'</span>, <span class="string">'old2'</span>], &#123;<span class="attr">old</span>: <span class="number">1</span>&#125;]</span><br><span class="line"><span class="keyword">var</span> new_arr = <span class="built_in">JSON</span>.parse( <span class="built_in">JSON</span>.stringify(arr) );</span><br><span class="line"><span class="built_in">console</span>.log(new_arr);</span><br></pre></td></tr></table></figure><p>原理是JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象，通过这两个方法，也可以实现对象的深复制。<br>但是这个方法不能够拷贝函数<br>浅拷贝的实现：<br>以上三个方法concat,slice ,JSON.stringify都是技巧类，根据实际项目情况选择使用，我们可以思考下如何实现一个对象或数组的浅拷贝，遍历对象，然后把属性和属性值都放在一个新的对象里即可    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shallowCopy = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 只拷贝对象</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 根据obj的类型判断是新建一个数组还是对象</span></span><br><span class="line"><span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line"><span class="comment">// 遍历obj，并且判断是obj的属性才拷贝</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">newObj[key] = obj[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深拷贝的实现<br>那如何实现一个深拷贝呢？说起来也好简单，我们在拷贝的时候判断一下属性值的类型，如果是对象，我们递归调用深拷贝函数不就好了~    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deepCopy = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">newObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ? deepCopy(obj[key]) : obj[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同数据类型的值的比较，是怎么转换的，有什么规则"><a href="#不同数据类型的值的比较，是怎么转换的，有什么规则" class="headerlink" title="不同数据类型的值的比较，是怎么转换的，有什么规则   "></a>不同数据类型的值的比较，是怎么转换的，有什么规则   <img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552428573113_1325658F6CAFABD8492C05155F5B8281" alt="img"></h2><h2 id="去除字符串首尾空格"><a href="#去除字符串首尾空格" class="headerlink" title="去除字符串首尾空格"></a>去除字符串首尾空格</h2><p>使用正则(^\s<em>)|(\s</em>$)即可 </p><h2 id="如何判断一个数组-讲到typeof差点掉坑里"><a href="#如何判断一个数组-讲到typeof差点掉坑里" class="headerlink" title="如何判断一个数组(讲到typeof差点掉坑里)"></a>如何判断一个数组(讲到typeof差点掉坑里)</h2><p>instanceof<br>Object.prototype.call.toString()</p><h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><p>push()，pop()，shift()，unshift()，splice()，sort()，reverse()，map()等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试&quot;&gt;&lt;a href=&quot;#面试&quot; class=&quot;headerlink&quot; title=&quot;面试&quot;&gt;&lt;/a&gt;面试&lt;/h1&gt;&lt;h2 id=&quot;几个很实用的BOM属性对象方法？&quot;&gt;&lt;a href=&quot;#几个很实用的BOM属性对象方法？&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="前端学习" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>简单使用hexo</title>
    <link href="http://yoursite.com/2019/07/15/Hexo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/07/15/Hexo简单使用/</id>
    <published>2019-07-15T01:23:08.989Z</published>
    <updated>2019-07-15T03:06:09.550Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
